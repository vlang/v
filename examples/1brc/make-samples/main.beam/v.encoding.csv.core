module 'v.encoding.csv' ['csv_reader_from_string'/1,
                'csv_reader'/1,
                'RandomAccessReader.dispose_csv_reader'/1,
                'RandomAccessReader.fill_buffer'/2,
                'RandomAccessReader.copy_configuration'/2,
                'RandomAccessReader.map_csv'/1,
                'RandomAccessReader.get_row'/2,
                'RandomAccessReader.get_cell'/2,
                'RandomAccessReader.get_cellt'/2,
                'RandomAccessReader.build_header_dict'/2,
                'RandomAccessReader.rows_count'/1,
                'csv_sequential_reader'/1,
                'SequentialReader.dispose_csv_reader'/1,
                'SequentialReader.has_data'/1,
                'SequentialReader.fill_buffer'/2,
                'SequentialReader.get_next_row'/1,
                'CommentIsDelimiterError.msg'/1,
                'InvalidDelimiterError.msg'/1,
                'EndOfFileError.msg'/1,
                'InvalidLineEndingError.msg'/1,
                'new_reader'/2,
                'Reader.read'/1,
                'Reader.read_line'/1,
                'Reader.read_record'/1,
                'valid_delim'/1,
                'decode'/1,
                'string_to_bool'/1,
                'get_column'/2,
                'new_reader_from_file'/2,
                'new_writer'/1,
                'Writer.write'/2,
                'Writer.field_needs_quotes'/2,
                'Writer.str'/1,
                'ColumType__static__from'/1,
                'SequentialReadingState__static__from'/1,
                'module_info'/0,
                'module_info'/1]
        attributes []
    'csv_reader_from_string'/1 =
        fun (In_str) ->
            try apply 'csv_reader'/1(~{'scr_buf'=>call 'erlang':'map_get'('str', In_str),'scr_buf_len'=>call 'erlang':'length'(In_str),{'vbeam','type'}=>'RandomAccessReaderConfig'}~) of <_cor1> when 'true' -> _cor1 catch <_cor_c1,_cor_r1,_cor_s1> when 'true' -> 'ok'
    'csv_reader'/1 =
        fun (Cfg) ->
            let <Cr> =
                ~{{'vbeam','type'}=>'RandomAccessReader'}~
            in  do  call 'erlang':'map_get'('start_index', Cfg)
                    do  call 'erlang':'map_get'('end_index', Cfg)
                        do  case call 'erlang':'and'(call 'erlang':'=/='(call 'erlang':'map_get'('scr_buf', Cfg), 0), call 'erlang':'>'(call 'erlang':'map_get'('scr_buf_len', Cfg), 0)) of <'true'> when 'true' -> 
                            do  1
                                do  call 'erlang':'map_get'('scr_buf', Cfg)
                                    do  call 'erlang':'map_get'('scr_buf_len', Cfg)
                                        do  case call 'erlang':'=:='(call 'erlang':'map_get'('end_index', Cfg), -1) of <'true'> when 'true' -> 'ok' <'false'> when 'true' -> 'ok' end
                                            'ok'
                         <'false'> when 'true' -> case call 'erlang':'>'(call 'erlang':'length'(call 'erlang':'map_get'('file_path', Cfg)), 0) of <'true'> when 'true' -> 
                            case call 'erlang':'not'(call 'filelib':'is_regular'(call 'erlang':'binary_to_list'(call 'erlang':'map_get'('file_path', Cfg)))) of
                                <'true'> when 'true' -> call 'erlang':'error'(call 'erlang':'iolist_to_binary'([#{#<69>(8,1,'integer',['unsigned'|['big']]),#<82>(8,1,'integer',['unsigned'|['big']]),#<82>(8,1,'integer',['unsigned'|['big']]),#<79>(8,1,'integer',['unsigned'|['big']]),#<82>(8,1,'integer',['unsigned'|['big']]),#<58>(8,1,'integer',['unsigned'|['big']]),#<32>(8,1,'integer',['unsigned'|['big']]),#<102>(8,1,'integer',['unsigned'|['big']]),#<105>(8,1,'integer',['unsigned'|['big']]),#<108>(8,1,'integer',['unsigned'|['big']]),#<101>(8,1,'integer',['unsigned'|['big']]),#<32>(8,1,'integer',['unsigned'|['big']])}#|[call 'erlang':'map_get'('file_path', Cfg)|[#{#<32>(8,1,'integer',['unsigned'|['big']]),#<110>(8,1,'integer',['unsigned'|['big']]),#<111>(8,1,'integer',['unsigned'|['big']]),#<116>(8,1,'integer',['unsigned'|['big']]),#<32>(8,1,'integer',['unsigned'|['big']]),#<102>(8,1,'integer',['unsigned'|['big']]),#<111>(8,1,'integer',['unsigned'|['big']]),#<117>(8,1,'integer',['unsigned'|['big']]),#<110>(8,1,'integer',['unsigned'|['big']]),#<100>(8,1,'integer',['unsigned'|['big']]),#<33>(8,1,'integer',['unsigned'|['big']])}#|[]]]]))
                                <'false'> when 'true' -> 
                                    do  0
                                        do  try {'ok', ~{{'vbeam','type'}=>'File'}~} of <_cor1> when 'true' -> _cor1 catch <_cor_c1,_cor_r1,_cor_s1> when 'true' -> 'ok'
                                            do  try 'ok' of <_cor2> when 'true' -> _cor2 catch <_cor_c2,_cor_r2,_cor_s2> when 'true' -> 'ok'
                                                do  try 0 of <_cor3> when 'true' -> _cor3 catch <_cor_c3,_cor_r3,_cor_s3> when 'true' -> 'ok'
                                                    do  try 'ok' of <_cor4> when 'true' -> _cor4 catch <_cor_c4,_cor_r4,_cor_s4> when 'true' -> 'ok'
                                                        do  try 0 of <_cor5> when 'true' -> _cor5 catch <_cor_c5,_cor_r5,_cor_s5> when 'true' -> 'ok'
                                                            do  case call 'erlang':'=:='(call 'erlang':'map_get'('end_index', Cfg), -1) of <'true'> when 'true' -> 'ok' <'false'> when 'true' -> 'ok' end
                                                                case call 'erlang':'=:='(call 'erlang':'map_get'('index', Cr), 0) of <'true'> when 'true' -> 
                                                                    do  case call 'erlang':'=:='(try apply 'File.read_into_ptr'/3(call 'erlang':'map_get'('f', Cr), call 'erlang':'map_get'('mem_buf', Cr), 4) of <_cor6> when 'true' -> _cor6 catch <_cor_c6,_cor_r6,_cor_s6> when 'true' -> 'ok', 4) of <'true'> when 'true' -> 'ok' <'false'> when 'true' -> 'ok' end
                                                                        try 'ok' of <_cor7> when 'true' -> _cor7 catch <_cor_c7,_cor_r7,_cor_s7> when 'true' -> 'ok'
                                                                 <'false'> when 'true' -> 'ok' end
                            end
                         <'false'> when 'true' -> 'ok' end end
                            do  call 'erlang':'map_get'('default_cell', Cfg)
                                do  call 'erlang':'map_get'('empty_cell', Cfg)
                                    do  call 'erlang':'map_get'('end_line_len', Cfg)
                                        do  call 'erlang':'map_get'('separator', Cfg)
                                            do  call 'erlang':'map_get'('comment', Cfg)
                                                do  call 'erlang':'map_get'('quote_remove', Cfg)
                                                    do  call 'erlang':'map_get'('quote', Cfg)
                                                        do  call 'erlang':'map_get'('create_map_csv', Cfg)
                                                            do  case call 'erlang':'map_get'('create_map_csv', Cr) of <'true'> when 'true' -> try apply 'RandomAccessReader.map_csv'/1(Cr) of <_cor8> when 'true' -> _cor8 catch <_cor_c8,_cor_r8,_cor_s8> when 'true' -> 'ok' <'false'> when 'true' -> 'ok' end
                                                                Cr
    'RandomAccessReader.dispose_csv_reader'/1 =
        fun (Cr) ->
            case call 'erlang':'=:='(call 'erlang':'map_get'('mem_buf_type', Cr), 1) of <'true'> when 'true' -> 'ok' <'false'> when 'true' -> case call 'erlang':'=:='(call 'erlang':'map_get'('mem_buf_type', Cr), 0) of <'true'> when 'true' -> 
                do  case call 'erlang':'map_get'('is_opened', call 'erlang':'map_get'('f', Cr)) of <'true'> when 'true' -> 'ok' <'false'> when 'true' -> 'ok' end
                    case call 'erlang':'>'(call 'erlang':'map_get'('mem_buf_size', Cr), 0) of <'true'> when 'true' -> 
                        do  apply 'free'/1(call 'erlang':'map_get'('mem_buf', Cr))
                            do  'nil'
                                'ok'
                     <'false'> when 'true' -> 'ok' end
             <'false'> when 'true' -> 'ok' end end
    'RandomAccessReader.fill_buffer'/2 =
        fun (Cr, I) ->
            do  case call 'erlang':'=:='(call 'erlang':'map_get'('mem_buf_type', Cr), 1) of <'true'> when 'true' -> 
                do  I
                    do  call 'erlang':'map_get'('mem_buf_size', Cr)
                        let <Read_bytes_count> =
                            call 'erlang':'-'(call 'erlang':'map_get'('mem_buf_end', Cr), call 'erlang':'map_get'('mem_buf_start', Cr))
                        in  Read_bytes_count
             <'false'> when 'true' -> case call 'erlang':'=:='(call 'erlang':'map_get'('mem_buf_type', Cr), 0) of <'true'> when 'true' -> 
                do  I
                    do  try 'ok' of <_cor1> when 'true' -> _cor1 catch <_cor_c1,_cor_r1,_cor_s1> when 'true' -> 'ok'
                        let <Read_bytes_count_2> =
                            try apply 'File.read_into_ptr'/3(call 'erlang':'map_get'('f', Cr), call 'erlang':'map_get'('mem_buf', Cr), call 'erlang':'map_get'('mem_buf_size', Cr)) of <_cor3> when 'true' -> _cor3 catch <_cor_c3,_cor_r3,_cor_s3> when 'true' -> 'ok'
                        in  do  I
                                do  call 'erlang':'+'(I, Read_bytes_count_2)
                                    Read_bytes_count_2
             <'false'> when 'true' -> 'ok' end end
                -1
    'RandomAccessReader.copy_configuration'/2 =
        fun (Cr, Src_cr) ->
            do  call 'erlang':'map_get'('header_row', Src_cr)
                'ok'
    'RandomAccessReader.map_csv'/1 =
        fun (Cr) ->
            let <Count> =
                0
            in  let <I> =
                    0
                in  let <Capture_flag> =
                        'true'
                    in  let <Drop_row> =
                            'false'
                        in  let <Quote_flag> =
                                'false'
                            in  do  case call 'erlang':'=:='(call 'erlang':'map_get'('mem_buf_type', Cr), 0) of <'true'> when 'true' -> try 'ok' of <_cor1> when 'true' -> _cor1 catch <_cor_c1,_cor_r1,_cor_s1> when 'true' -> 'ok' <'false'> when 'true' -> 'ok' end
                                    do  case call 'erlang':'<'(call 'erlang':'length'(call 'lists':'nth'(call 'erlang':'+'(call 'erlang':'-'(call 'erlang':'length'(call 'erlang':'map_get'('csv_map', Cr)), 1), 1), call 'erlang':'map_get'('csv_map', Cr))), 2) of <'true'> when 'true' -> call 'lists':'delete'(call 'erlang':'-'(call 'erlang':'length'(call 'erlang':'map_get'('csv_map', Cr)), 1), call 'erlang':'map_get'('csv_map', Cr)) <'false'> when 'true' -> 'ok' end
                                        do  case call 'erlang':'=:='(call 'erlang':'map_get'('mem_buf_type', Cr), 0) of <'true'> when 'true' -> try 'ok' of <_cor2> when 'true' -> _cor2 catch <_cor_c2,_cor_r2,_cor_s2> when 'true' -> 'ok' <'false'> when 'true' -> 'ok' end
                                            'ok'
    'RandomAccessReader.get_row'/2 =
        fun (Cr, Y) ->
            let <H> =
                []
            in  do  case call 'erlang':'>'(call 'erlang':'length'(call 'erlang':'map_get'('csv_map', Cr)), 1) of <'true'> when 'true' -> 'ok' <'false'> when 'true' -> 'ok' end
                    H
    'RandomAccessReader.get_cell'/2 =
        fun (Cr, Cfg) ->
            do  case call 'erlang':'and'(call 'erlang':'<'(call 'erlang':'map_get'('y', Cfg), call 'erlang':'length'(call 'erlang':'map_get'('csv_map', Cr))), call 'erlang':'<'(call 'erlang':'map_get'('x', Cfg), call 'erlang':'-'(call 'erlang':'length'(call 'lists':'nth'(call 'erlang':'+'(call 'erlang':'map_get'('y', Cfg), 1), call 'erlang':'map_get'('csv_map', Cr))), 1))) of <'true'> when 'true' -> 
                let <Start> =
                    call 'lists':'nth'(call 'erlang':'+'(call 'erlang':'map_get'('x', Cfg), 1), call 'lists':'nth'(call 'erlang':'+'(call 'erlang':'map_get'('y', Cfg), 1), call 'erlang':'map_get'('csv_map', Cr)))
                in  let <End> =
                        call 'lists':'nth'(call 'erlang':'+'(call 'erlang':'+'(call 'erlang':'map_get'('x', Cfg), 1), 1), call 'lists':'nth'(call 'erlang':'+'(call 'erlang':'map_get'('y', Cfg), 1), call 'erlang':'map_get'('csv_map', Cr)))
                    in  do  case call 'erlang':'>'(call 'erlang':'map_get'('x', Cfg), 0) of <'true'> when 'true' -> Start <'false'> when 'true' -> 'ok' end
                            let <Len> =
                                call 'erlang':'-'(End, Start)
                            in  case call 'erlang':'=<'(Len, 0) of
                                    <'true'> when 'true' -> call 'erlang':'map_get'('empty_cell', Cr)
                                    <'false'> when 'true' -> 
                                        do  case call 'erlang':'not'(call 'erlang':'and'(call 'erlang':'>='(Start, call 'erlang':'map_get'('mem_buf_start', Cr)), call 'erlang':'<'(End, call 'erlang':'map_get'('mem_buf_end', Cr)))) of <'true'> when 'true' -> try apply 'RandomAccessReader.fill_buffer'/2(Cr, Start) of <_cor1> when 'true' -> _cor1 catch <_cor_c1,_cor_r1,_cor_s1> when 'true' -> 'ok' <'false'> when 'true' -> 'ok' end
                                            'ok'
                                end
             <'false'> when 'true' -> 'ok' end
                call 'erlang':'map_get'('default_cell', Cr)
    'RandomAccessReader.get_cellt'/2 =
        fun (Cr, Cfg) ->
            do  case call 'erlang':'and'(call 'erlang':'>='(call 'erlang':'map_get'('header_row', Cr), 0), call 'erlang':'<'(call 'erlang':'map_get'('x', Cfg), call 'erlang':'length'(call 'erlang':'map_get'('header_list', Cr)))) of <'true'> when 'true' -> 
                let <H> =
                    call 'lists':'nth'(call 'erlang':'+'(call 'erlang':'map_get'('x', Cfg), 1), call 'erlang':'map_get'('header_list', Cr))
                in  let <Res> =
                        try apply 'RandomAccessReader.get_cell'/2(Cr, Cfg) of <_cor1> when 'true' -> _cor1 catch <_cor_c1,_cor_r1,_cor_s1> when 'true' -> 'ok'
                    in  case call 'erlang':'map_get'('htype', H) of <'int'> when 'true' -> call 'erlang':'binary_to_integer'(call 'string':'trim'(Res)) <'string'> when 'true' -> Res <'f32'> when 'true' -> apply 'string.f32'/1(call 'string':'trim'(Res)) end
             <'false'> when 'true' -> 'ok' end
                try apply 'RandomAccessReader.get_cell'/2(Cr, Cfg) of <_cor2> when 'true' -> _cor2 catch <_cor_c2,_cor_r2,_cor_s2> when 'true' -> 'ok'
    'RandomAccessReader.build_header_dict'/2 =
        fun (Cr, Cfg) ->
            do  case call 'erlang':'and'(call 'erlang':'and'(call 'erlang':'>'(call 'erlang':'length'(call 'erlang':'map_get'('csv_map', Cr)), 1), call 'erlang':'>='(call 'erlang':'map_get'('header_row', Cfg), 0)), call 'erlang':'<'(call 'erlang':'map_get'('header_row', Cfg), call 'erlang':'length'(call 'erlang':'map_get'('csv_map', Cr)))) of <'true'> when 'true' -> 
                do  call 'erlang':'map_get'('header_row', Cfg)
                    'ok'
             <'false'> when 'true' -> 'ok' end
                'ok'
    'RandomAccessReader.rows_count'/1 =
        fun (Cr) ->
            let <Count> =
                0
            in  let <I> =
                    0
                in  do  case call 'erlang':'=:='(call 'erlang':'map_get'('mem_buf_type', Cr), 0) of <'true'> when 'true' -> try 'ok' of <_cor1> when 'true' -> _cor1 catch <_cor_c1,_cor_r1,_cor_s1> when 'true' -> 'ok' <'false'> when 'true' -> 'ok' end
                        do  case call 'erlang':'=:='(call 'erlang':'map_get'('mem_buf_type', Cr), 0) of <'true'> when 'true' -> try 'ok' of <_cor2> when 'true' -> _cor2 catch <_cor_c2,_cor_r2,_cor_s2> when 'true' -> 'ok' <'false'> when 'true' -> 'ok' end
                            Count
    'csv_sequential_reader'/1 =
        fun (Cfg) ->
            let <Cr> =
                ~{{'vbeam','type'}=>'SequentialReader'}~
            in  do  call 'erlang':'map_get'('start_index', Cfg)
                    do  call 'erlang':'map_get'('end_index', Cfg)
                        do  case call 'erlang':'and'(call 'erlang':'=/='(call 'erlang':'map_get'('scr_buf', Cfg), 0), call 'erlang':'>'(call 'erlang':'map_get'('scr_buf_len', Cfg), 0)) of <'true'> when 'true' -> 
                            do  1
                                do  call 'erlang':'map_get'('scr_buf', Cfg)
                                    do  call 'erlang':'map_get'('scr_buf_len', Cfg)
                                        do  case call 'erlang':'=:='(call 'erlang':'map_get'('end_index', Cfg), -1) of <'true'> when 'true' -> 'ok' <'false'> when 'true' -> 'ok' end
                                            do  0
                                                'ok'
                         <'false'> when 'true' -> case call 'erlang':'>'(call 'erlang':'length'(call 'erlang':'map_get'('file_path', Cfg)), 0) of <'true'> when 'true' -> 
                            case call 'erlang':'not'(call 'filelib':'is_regular'(call 'erlang':'binary_to_list'(call 'erlang':'map_get'('file_path', Cfg)))) of
                                <'true'> when 'true' -> call 'erlang':'error'(call 'erlang':'iolist_to_binary'([#{#<69>(8,1,'integer',['unsigned'|['big']]),#<82>(8,1,'integer',['unsigned'|['big']]),#<82>(8,1,'integer',['unsigned'|['big']]),#<79>(8,1,'integer',['unsigned'|['big']]),#<82>(8,1,'integer',['unsigned'|['big']]),#<58>(8,1,'integer',['unsigned'|['big']]),#<32>(8,1,'integer',['unsigned'|['big']]),#<102>(8,1,'integer',['unsigned'|['big']]),#<105>(8,1,'integer',['unsigned'|['big']]),#<108>(8,1,'integer',['unsigned'|['big']]),#<101>(8,1,'integer',['unsigned'|['big']]),#<32>(8,1,'integer',['unsigned'|['big']])}#|[call 'erlang':'map_get'('file_path', Cfg)|[#{#<32>(8,1,'integer',['unsigned'|['big']]),#<110>(8,1,'integer',['unsigned'|['big']]),#<111>(8,1,'integer',['unsigned'|['big']]),#<116>(8,1,'integer',['unsigned'|['big']]),#<32>(8,1,'integer',['unsigned'|['big']]),#<102>(8,1,'integer',['unsigned'|['big']]),#<111>(8,1,'integer',['unsigned'|['big']]),#<117>(8,1,'integer',['unsigned'|['big']]),#<110>(8,1,'integer',['unsigned'|['big']]),#<100>(8,1,'integer',['unsigned'|['big']]),#<33>(8,1,'integer',['unsigned'|['big']])}#|[]]]]))
                                <'false'> when 'true' -> 
                                    do  0
                                        do  try {'ok', ~{{'vbeam','type'}=>'File'}~} of <_cor1> when 'true' -> _cor1 catch <_cor_c1,_cor_r1,_cor_s1> when 'true' -> 'ok'
                                            do  try 'ok' of <_cor2> when 'true' -> _cor2 catch <_cor_c2,_cor_r2,_cor_s2> when 'true' -> 'ok'
                                                do  try 0 of <_cor3> when 'true' -> _cor3 catch <_cor_c3,_cor_r3,_cor_s3> when 'true' -> 'ok'
                                                    do  try 'ok' of <_cor4> when 'true' -> _cor4 catch <_cor_c4,_cor_r4,_cor_s4> when 'true' -> 'ok'
                                                        do  try 0 of <_cor5> when 'true' -> _cor5 catch <_cor_c5,_cor_r5,_cor_s5> when 'true' -> 'ok'
                                                            do  case call 'erlang':'=:='(call 'erlang':'map_get'('end_index', Cfg), -1) of <'true'> when 'true' -> 'ok' <'false'> when 'true' -> 'ok' end
                                                                case call 'erlang':'=:='(call 'erlang':'map_get'('index', Cr), 0) of <'true'> when 'true' -> 
                                                                    do  case call 'erlang':'=:='(try apply 'File.read_into_ptr'/3(call 'erlang':'map_get'('f', Cr), call 'erlang':'map_get'('mem_buf', Cr), 4) of <_cor6> when 'true' -> _cor6 catch <_cor_c6,_cor_r6,_cor_s6> when 'true' -> 'ok', 4) of <'true'> when 'true' -> 'ok' <'false'> when 'true' -> 'ok' end
                                                                        try 'ok' of <_cor7> when 'true' -> _cor7 catch <_cor_c7,_cor_r7,_cor_s7> when 'true' -> 'ok'
                                                                 <'false'> when 'true' -> 'ok' end
                            end
                         <'false'> when 'true' -> 'ok' end end
                            do  call 'erlang':'map_get'('default_cell', Cfg)
                                do  call 'erlang':'map_get'('empty_cell', Cfg)
                                    do  call 'erlang':'map_get'('end_line_len', Cfg)
                                        do  call 'erlang':'map_get'('separator', Cfg)
                                            do  call 'erlang':'map_get'('comment', Cfg)
                                                do  call 'erlang':'map_get'('quote', Cfg)
                                                    Cr
    'SequentialReader.dispose_csv_reader'/1 =
        fun (Cr) ->
            case call 'erlang':'=:='(call 'erlang':'map_get'('mem_buf_type', Cr), 1) of <'true'> when 'true' -> 'ok' <'false'> when 'true' -> case call 'erlang':'=:='(call 'erlang':'map_get'('mem_buf_type', Cr), 0) of <'true'> when 'true' -> 
                do  case call 'erlang':'map_get'('is_opened', call 'erlang':'map_get'('f', Cr)) of <'true'> when 'true' -> 'ok' <'false'> when 'true' -> 'ok' end
                    case call 'erlang':'>'(call 'erlang':'map_get'('mem_buf_size', Cr), 0) of <'true'> when 'true' -> 
                        do  apply 'free'/1(call 'erlang':'map_get'('mem_buf', Cr))
                            do  'nil'
                                'ok'
                     <'false'> when 'true' -> 'ok' end
             <'false'> when 'true' -> 'ok' end end
    'SequentialReader.has_data'/1 =
        fun (Cr) ->
            call 'erlang':'-'(call 'erlang':'map_get'('end_index', Cr), call 'erlang':'map_get'('start_index', Cr))
    'SequentialReader.fill_buffer'/2 =
        fun (Cr, Index) ->
            do  case call 'erlang':'=:='(call 'erlang':'map_get'('mem_buf_type', Cr), 1) of <'true'> when 'true' -> 'ok' <'false'> when 'true' -> 
                do  try 'ok' of <_cor1> when 'true' -> _cor1 catch <_cor_c1,_cor_r1,_cor_s1> when 'true' -> 'ok'
                    let <Read_bytes_count> =
                        try apply 'File.read_into_ptr'/3(call 'erlang':'map_get'('f', Cr), call 'erlang':'map_get'('mem_buf', Cr), call 'erlang':'map_get'('mem_buf_size', Cr)) of <_cor2> when 'true' -> _cor2 catch <_cor_c2,_cor_r2,_cor_s2> when 'true' -> 'ok'
                    in  do  Index
                            'ok'
             end
                'ok'
    'SequentialReader.get_next_row'/1 =
        fun (Cr) ->
            let <Row_res> =
                []
            in  do  apply 'array.clear'/1(call 'erlang':'map_get'('ch_buf', Cr))
                    let <I> =
                        call 'erlang':'map_get'('start_index', Cr)
                    in  let <State> =
                            'cell'
                        in  let <P> =
                                call 'erlang':'map_get'('mem_buf', Cr)
                            in  do  I
                                    Row_res
    'CommentIsDelimiterError.msg'/1 =
        fun (Err) ->
            #{#<101>(8,1,'integer',['unsigned'|['big']]),#<110>(8,1,'integer',['unsigned'|['big']]),#<99>(8,1,'integer',['unsigned'|['big']]),#<111>(8,1,'integer',['unsigned'|['big']]),#<100>(8,1,'integer',['unsigned'|['big']]),#<105>(8,1,'integer',['unsigned'|['big']]),#<110>(8,1,'integer',['unsigned'|['big']]),#<103>(8,1,'integer',['unsigned'|['big']]),#<46>(8,1,'integer',['unsigned'|['big']]),#<99>(8,1,'integer',['unsigned'|['big']]),#<115>(8,1,'integer',['unsigned'|['big']]),#<118>(8,1,'integer',['unsigned'|['big']]),#<58>(8,1,'integer',['unsigned'|['big']]),#<32>(8,1,'integer',['unsigned'|['big']]),#<99>(8,1,'integer',['unsigned'|['big']]),#<111>(8,1,'integer',['unsigned'|['big']]),#<109>(8,1,'integer',['unsigned'|['big']]),#<109>(8,1,'integer',['unsigned'|['big']]),#<101>(8,1,'integer',['unsigned'|['big']]),#<110>(8,1,'integer',['unsigned'|['big']]),#<116>(8,1,'integer',['unsigned'|['big']]),#<32>(8,1,'integer',['unsigned'|['big']]),#<99>(8,1,'integer',['unsigned'|['big']]),#<97>(8,1,'integer',['unsigned'|['big']]),#<110>(8,1,'integer',['unsigned'|['big']]),#<110>(8,1,'integer',['unsigned'|['big']]),#<111>(8,1,'integer',['unsigned'|['big']]),#<116>(8,1,'integer',['unsigned'|['big']]),#<32>(8,1,'integer',['unsigned'|['big']]),#<98>(8,1,'integer',['unsigned'|['big']]),#<101>(8,1,'integer',['unsigned'|['big']]),#<32>(8,1,'integer',['unsigned'|['big']]),#<116>(8,1,'integer',['unsigned'|['big']]),#<104>(8,1,'integer',['unsigned'|['big']]),#<101>(8,1,'integer',['unsigned'|['big']]),#<32>(8,1,'integer',['unsigned'|['big']]),#<115>(8,1,'integer',['unsigned'|['big']]),#<97>(8,1,'integer',['unsigned'|['big']]),#<109>(8,1,'integer',['unsigned'|['big']]),#<101>(8,1,'integer',['unsigned'|['big']]),#<32>(8,1,'integer',['unsigned'|['big']]),#<97>(8,1,'integer',['unsigned'|['big']]),#<115>(8,1,'integer',['unsigned'|['big']]),#<32>(8,1,'integer',['unsigned'|['big']]),#<100>(8,1,'integer',['unsigned'|['big']]),#<101>(8,1,'integer',['unsigned'|['big']]),#<108>(8,1,'integer',['unsigned'|['big']]),#<105>(8,1,'integer',['unsigned'|['big']]),#<109>(8,1,'integer',['unsigned'|['big']]),#<105>(8,1,'integer',['unsigned'|['big']]),#<116>(8,1,'integer',['unsigned'|['big']]),#<101>(8,1,'integer',['unsigned'|['big']]),#<114>(8,1,'integer',['unsigned'|['big']])}#
    'InvalidDelimiterError.msg'/1 =
        fun (Err) ->
            #{#<101>(8,1,'integer',['unsigned'|['big']]),#<110>(8,1,'integer',['unsigned'|['big']]),#<99>(8,1,'integer',['unsigned'|['big']]),#<111>(8,1,'integer',['unsigned'|['big']]),#<100>(8,1,'integer',['unsigned'|['big']]),#<105>(8,1,'integer',['unsigned'|['big']]),#<110>(8,1,'integer',['unsigned'|['big']]),#<103>(8,1,'integer',['unsigned'|['big']]),#<46>(8,1,'integer',['unsigned'|['big']]),#<99>(8,1,'integer',['unsigned'|['big']]),#<115>(8,1,'integer',['unsigned'|['big']]),#<118>(8,1,'integer',['unsigned'|['big']]),#<58>(8,1,'integer',['unsigned'|['big']]),#<32>(8,1,'integer',['unsigned'|['big']]),#<105>(8,1,'integer',['unsigned'|['big']]),#<110>(8,1,'integer',['unsigned'|['big']]),#<118>(8,1,'integer',['unsigned'|['big']]),#<97>(8,1,'integer',['unsigned'|['big']]),#<108>(8,1,'integer',['unsigned'|['big']]),#<105>(8,1,'integer',['unsigned'|['big']]),#<100>(8,1,'integer',['unsigned'|['big']]),#<32>(8,1,'integer',['unsigned'|['big']]),#<100>(8,1,'integer',['unsigned'|['big']]),#<101>(8,1,'integer',['unsigned'|['big']]),#<108>(8,1,'integer',['unsigned'|['big']]),#<105>(8,1,'integer',['unsigned'|['big']]),#<109>(8,1,'integer',['unsigned'|['big']]),#<105>(8,1,'integer',['unsigned'|['big']]),#<116>(8,1,'integer',['unsigned'|['big']]),#<101>(8,1,'integer',['unsigned'|['big']]),#<114>(8,1,'integer',['unsigned'|['big']])}#
    'EndOfFileError.msg'/1 =
        fun (Err) ->
            #{#<101>(8,1,'integer',['unsigned'|['big']]),#<110>(8,1,'integer',['unsigned'|['big']]),#<99>(8,1,'integer',['unsigned'|['big']]),#<111>(8,1,'integer',['unsigned'|['big']]),#<100>(8,1,'integer',['unsigned'|['big']]),#<105>(8,1,'integer',['unsigned'|['big']]),#<110>(8,1,'integer',['unsigned'|['big']]),#<103>(8,1,'integer',['unsigned'|['big']]),#<46>(8,1,'integer',['unsigned'|['big']]),#<99>(8,1,'integer',['unsigned'|['big']]),#<115>(8,1,'integer',['unsigned'|['big']]),#<118>(8,1,'integer',['unsigned'|['big']]),#<58>(8,1,'integer',['unsigned'|['big']]),#<32>(8,1,'integer',['unsigned'|['big']]),#<101>(8,1,'integer',['unsigned'|['big']]),#<110>(8,1,'integer',['unsigned'|['big']]),#<100>(8,1,'integer',['unsigned'|['big']]),#<32>(8,1,'integer',['unsigned'|['big']]),#<111>(8,1,'integer',['unsigned'|['big']]),#<102>(8,1,'integer',['unsigned'|['big']]),#<32>(8,1,'integer',['unsigned'|['big']]),#<102>(8,1,'integer',['unsigned'|['big']]),#<105>(8,1,'integer',['unsigned'|['big']]),#<108>(8,1,'integer',['unsigned'|['big']]),#<101>(8,1,'integer',['unsigned'|['big']])}#
    'InvalidLineEndingError.msg'/1 =
        fun (Err) ->
            #{#<101>(8,1,'integer',['unsigned'|['big']]),#<110>(8,1,'integer',['unsigned'|['big']]),#<99>(8,1,'integer',['unsigned'|['big']]),#<111>(8,1,'integer',['unsigned'|['big']]),#<100>(8,1,'integer',['unsigned'|['big']]),#<105>(8,1,'integer',['unsigned'|['big']]),#<110>(8,1,'integer',['unsigned'|['big']]),#<103>(8,1,'integer',['unsigned'|['big']]),#<46>(8,1,'integer',['unsigned'|['big']]),#<99>(8,1,'integer',['unsigned'|['big']]),#<115>(8,1,'integer',['unsigned'|['big']]),#<118>(8,1,'integer',['unsigned'|['big']]),#<58>(8,1,'integer',['unsigned'|['big']]),#<32>(8,1,'integer',['unsigned'|['big']]),#<99>(8,1,'integer',['unsigned'|['big']]),#<111>(8,1,'integer',['unsigned'|['big']]),#<117>(8,1,'integer',['unsigned'|['big']]),#<108>(8,1,'integer',['unsigned'|['big']]),#<100>(8,1,'integer',['unsigned'|['big']]),#<32>(8,1,'integer',['unsigned'|['big']]),#<110>(8,1,'integer',['unsigned'|['big']]),#<111>(8,1,'integer',['unsigned'|['big']]),#<116>(8,1,'integer',['unsigned'|['big']]),#<32>(8,1,'integer',['unsigned'|['big']]),#<102>(8,1,'integer',['unsigned'|['big']]),#<105>(8,1,'integer',['unsigned'|['big']]),#<110>(8,1,'integer',['unsigned'|['big']]),#<100>(8,1,'integer',['unsigned'|['big']]),#<32>(8,1,'integer',['unsigned'|['big']]),#<97>(8,1,'integer',['unsigned'|['big']]),#<110>(8,1,'integer',['unsigned'|['big']]),#<121>(8,1,'integer',['unsigned'|['big']]),#<32>(8,1,'integer',['unsigned'|['big']]),#<118>(8,1,'integer',['unsigned'|['big']]),#<97>(8,1,'integer',['unsigned'|['big']]),#<108>(8,1,'integer',['unsigned'|['big']]),#<105>(8,1,'integer',['unsigned'|['big']]),#<100>(8,1,'integer',['unsigned'|['big']]),#<32>(8,1,'integer',['unsigned'|['big']]),#<108>(8,1,'integer',['unsigned'|['big']]),#<105>(8,1,'integer',['unsigned'|['big']]),#<110>(8,1,'integer',['unsigned'|['big']]),#<101>(8,1,'integer',['unsigned'|['big']]),#<32>(8,1,'integer',['unsigned'|['big']]),#<101>(8,1,'integer',['unsigned'|['big']]),#<110>(8,1,'integer',['unsigned'|['big']]),#<100>(8,1,'integer',['unsigned'|['big']]),#<105>(8,1,'integer',['unsigned'|['big']]),#<110>(8,1,'integer',['unsigned'|['big']]),#<103>(8,1,'integer',['unsigned'|['big']]),#<115>(8,1,'integer',['unsigned'|['big']])}#
    'new_reader'/2 =
        fun (Data, Config) ->
            ~{'data'=>Data,'delimiter'=>call 'erlang':'map_get'('delimiter', Config),'comment'=>call 'erlang':'map_get'('comment', Config),{'vbeam','type'}=>'Reader'}~
    'Reader.read'/1 =
        fun (R) ->
            let <L> =
                try apply 'Reader.read_record'/1(R) of <_cor1> when 'true' -> _cor1 catch <_cor_c1,_cor_r1,_cor_s1> when 'true' -> 'ok'
            in  L
    'Reader.read_line'/1 =
        fun (R) ->
            case call 'erlang':'>='(call 'erlang':'map_get'('row_pos', R), call 'erlang':'length'(call 'erlang':'map_get'('data', R))) of
                <'true'> when 'true' -> ~{{'vbeam','type'}=>'EndOfFileError'}~
                <'false'> when 'true' -> 
                    let <Le> =
                        case call 'erlang':'map_get'('is_mac_pre_osx_le', R) of <'true'> when 'true' -> #{#<92>(8,1,'integer',['unsigned'|['big']]),#<114>(8,1,'integer',['unsigned'|['big']])}# <'false'> when 'true' -> #{#<92>(8,1,'integer',['unsigned'|['big']]),#<110>(8,1,'integer',['unsigned'|['big']])}# end
                    in  let <I> =
                            try apply 'string.index_after'/3(call 'erlang':'map_get'('data', R), Le, call 'erlang':'map_get'('row_pos', R)) of <_cor1> when 'true' -> _cor1 catch <_cor_c1,_cor_r1,_cor_s1> when 'true' -> -1
                        in  do  case call 'erlang':'=:='(I, -1) of <'true'> when 'true' -> case call 'erlang':'=:='(call 'erlang':'map_get'('row_pos', R), 0) of <'true'> when 'true' -> 
                                let <I_2> =
                                    try apply 'string.index_after'/3(call 'erlang':'map_get'('data', R), #{#<92>(8,1,'integer',['unsigned'|['big']]),#<114>(8,1,'integer',['unsigned'|['big']])}#, call 'erlang':'map_get'('row_pos', R)) of <_cor3> when 'true' -> _cor3 catch <_cor_c3,_cor_r3,_cor_s3> when 'true' -> -1
                                in  case call 'erlang':'=/='(I_2, -1) of <'true'> when 'true' -> 'ok' <'false'> when 'true' -> ~{{'vbeam','type'}=>'InvalidLineEndingError'}~ end
                             <'false'> when 'true' -> 'ok' end <'false'> when 'true' -> 'ok' end
                                let <Line> =
                                    call 'lists':'nth'(call 'erlang':'+'(call 'lists':'seq'(call 'erlang':'map_get'('row_pos', R), I_2), 1), call 'erlang':'map_get'('data', R))
                                in  do  call 'erlang':'+'(I_2, 1)
                                        let <Line_4> =
                                            case call 'erlang':'and'(call 'erlang':'not'(call 'erlang':'map_get'('is_mac_pre_osx_le', R)), call 'erlang':'and'(call 'erlang':'>='(call 'erlang':'length'(Line), 1), call 'erlang':'=:='(call 'lists':'nth'(call 'erlang':'+'(call 'erlang':'-'(call 'erlang':'length'(Line), 1), 1), Line), 13))) of <'true'> when 'true' -> call 'lists':'nth'(call 'erlang':'+'(call 'lists':'seq'(0, call 'erlang':'-'(call 'erlang':'length'(Line), 1)), 1), Line) <'false'> when 'true' -> Line end
                                        in  Line_4
            end
    'Reader.read_record'/1 =
        fun (R) ->
            case call 'erlang':'=:='(call 'erlang':'map_get'('delimiter', R), call 'erlang':'map_get'('comment', R)) of
                <'true'> when 'true' -> ~{{'vbeam','type'}=>'CommentIsDelimiterError'}~
                <'false'> when 'true' -> 
                    case call 'erlang':'not'(apply 'valid_delim'/1(call 'erlang':'map_get'('delimiter', R))) of
                        <'true'> when 'true' -> ~{{'vbeam','type'}=>'InvalidDelimiterError'}~
                        <'false'> when 'true' -> 
                            let <Need_read> =
                                'true'
                            in  let <Keep_raw> =
                                    'false'
                                in  let <Line> =
                                        #{  }#
                                    in  let <Fields> =
                                            []
                                        in  let <I> =
                                                -1
                                            in  Fields
                    end
            end
    'valid_delim'/1 =
        fun (B) ->
            call 'erlang':'and'(call 'erlang':'and'(call 'erlang':'and'(call 'erlang':'=/='(B, 0), call 'erlang':'=/='(B, 34)), call 'erlang':'=/='(B, 13)), call 'erlang':'=/='(B, 10))
    'decode'/1 =
        fun (Data) ->
            let <Result> =
                []
            in  case call 'erlang':'=:='(Data, #{  }#) of
                    <'true'> when 'true' -> Result
                    <'false'> when 'true' -> 
                        let <Parser> =
                            apply 'new_reader'/1(Data)
                        in  let <Columns_names> =
                                []
                            in  let <I> =
                                    0
                                in  Result
                end
    'string_to_bool'/1 =
        fun (Val) ->
            let <L_val> =
                call 'string':'trim'(call 'string':'lowercase'(Val))
            in  case call 'erlang':'=:='(L_val, #{#<116>(8,1,'integer',['unsigned'|['big']]),#<114>(8,1,'integer',['unsigned'|['big']]),#<117>(8,1,'integer',['unsigned'|['big']]),#<101>(8,1,'integer',['unsigned'|['big']])}#) of
                    <'true'> when 'true' -> 'true'
                    <'false'> when 'true' -> 
                        let <I_val> =
                            call 'erlang':'binary_to_integer'(Val)
                        in  case call 'erlang':'=/='(I_val, 0) of
                                <'true'> when 'true' -> 'true'
                                <'false'> when 'true' -> 
                                    'false'
                            end
                end
    'get_column'/2 =
        fun (Name, Columns) ->
            do  let <_1> =
                fun (Val, I) ->
                    do  case call 'erlang':'=:='(Val, Name) of <'true'> when 'true' -> I <'false'> when 'true' -> 'ok' end
                        call 'erlang':'+'(I, 1)
            in  call 'lists':'foldl'(_1, 0, Columns)
                -1
    'new_reader_from_file'/2 =
        fun (Csv_file_path, Config) ->
            let <Csv_file_content> =
                try call 'file':'read_file'(Csv_file_path) of <_cor1> when 'true' -> _cor1 catch <_cor_c1,_cor_r1,_cor_s1> when 'true' -> 'ok'
            in  apply 'new_reader'/2(Csv_file_content, Config)
    'new_writer'/1 =
        fun (Config) ->
            ~{'sb'=>call 'v.strings':'new_builder'(200),'use_crlf'=>call 'erlang':'map_get'('use_crlf', Config),'delimiter'=>call 'erlang':'map_get'('delimiter', Config),{'vbeam','type'}=>'Writer'}~
    'Writer.write'/2 =
        fun (W, Record) ->
            case call 'erlang':'not'(apply 'valid_delim'/1(call 'erlang':'map_get'('delimiter', W))) of
                <'true'> when 'true' -> ~{{'vbeam','type'}=>'InvalidDelimiterError'}~
                <'false'> when 'true' -> 
                    let <Le> =
                        case call 'erlang':'map_get'('use_crlf', W) of <'true'> when 'true' -> #{#<92>(8,1,'integer',['unsigned'|['big']]),#<114>(8,1,'integer',['unsigned'|['big']]),#<92>(8,1,'integer',['unsigned'|['big']]),#<110>(8,1,'integer',['unsigned'|['big']])}# <'false'> when 'true' -> #{#<92>(8,1,'integer',['unsigned'|['big']]),#<110>(8,1,'integer',['unsigned'|['big']])}# end
                    in  do  let <_1> =
                            fun (Field_, N) ->
                                do  Field_
                                    do  case call 'erlang':'>'(N, 0) of <'true'> when 'true' -> apply 'Builder.write_string'/2(call 'erlang':'map_get'('sb', W), call 'erlang':'list_to_binary'([call 'erlang':'map_get'('delimiter', W)|[]])) <'false'> when 'true' -> 'ok' end
                                        do  case call 'erlang':'not'(apply 'Writer.field_needs_quotes'/2(W, Field)) of <'true'> when 'true' -> 
                                            do  apply 'Builder.write_string'/2(call 'erlang':'map_get'('sb', W), Field)
                                                'ok'
                                         <'false'> when 'true' -> 'ok' end
                                            do  apply 'Builder.write_string'/2(call 'erlang':'map_get'('sb', W), #{#<34>(8,1,'integer',['unsigned'|['big']])}#)
                                                do  'ok'
                                                    do  apply 'Builder.write_string'/2(call 'erlang':'map_get'('sb', W), #{#<34>(8,1,'integer',['unsigned'|['big']])}#)
                                                        call 'erlang':'+'(N, 1)
                        in  call 'lists':'foldl'(_1, 0, Record)
                            do  apply 'Builder.write_string'/2(call 'erlang':'map_get'('sb', W), Le)
                                'true'
            end
    'Writer.field_needs_quotes'/2 =
        fun (W, Field) ->
            case call 'erlang':'=:='(Field, #{  }#) of
                <'true'> when 'true' -> 'false'
                <'false'> when 'true' -> 
                    case call 'erlang':'or'(case call 'binary':'match'(Field, call 'erlang':'list_to_binary'([call 'erlang':'map_get'('delimiter', W)|[]])) of <'nomatch'> when 'true' -> 'false' <_> when 'true' -> 'true' end, call 'erlang':'=/='(apply 'string.index_any'/2(Field, #{#<34>(8,1,'integer',['unsigned'|['big']]),#<92>(8,1,'integer',['unsigned'|['big']]),#<114>(8,1,'integer',['unsigned'|['big']]),#<92>(8,1,'integer',['unsigned'|['big']]),#<110>(8,1,'integer',['unsigned'|['big']])}#), -1)) of
                        <'true'> when 'true' -> 'true'
                        <'false'> when 'true' -> 
                            'false'
                    end
            end
    'Writer.str'/1 =
        fun (W) ->
            apply 'Builder.str'/1(call 'erlang':'map_get'('sb', W))
    'ColumType__static__from'/1 =
        fun (Input) ->
            do  'ok'
                do  'ok'
                    call 'erlang':'error'(#{#<105>(8,1,'integer',['unsigned'|['big']]),#<110>(8,1,'integer',['unsigned'|['big']]),#<118>(8,1,'integer',['unsigned'|['big']]),#<97>(8,1,'integer',['unsigned'|['big']]),#<108>(8,1,'integer',['unsigned'|['big']]),#<105>(8,1,'integer',['unsigned'|['big']]),#<100>(8,1,'integer',['unsigned'|['big']]),#<32>(8,1,'integer',['unsigned'|['big']]),#<118>(8,1,'integer',['unsigned'|['big']]),#<97>(8,1,'integer',['unsigned'|['big']]),#<108>(8,1,'integer',['unsigned'|['big']]),#<117>(8,1,'integer',['unsigned'|['big']]),#<101>(8,1,'integer',['unsigned'|['big']])}#)
    'SequentialReadingState__static__from'/1 =
        fun (Input) ->
            do  'ok'
                do  'ok'
                    call 'erlang':'error'(#{#<105>(8,1,'integer',['unsigned'|['big']]),#<110>(8,1,'integer',['unsigned'|['big']]),#<118>(8,1,'integer',['unsigned'|['big']]),#<97>(8,1,'integer',['unsigned'|['big']]),#<108>(8,1,'integer',['unsigned'|['big']]),#<105>(8,1,'integer',['unsigned'|['big']]),#<100>(8,1,'integer',['unsigned'|['big']]),#<32>(8,1,'integer',['unsigned'|['big']]),#<118>(8,1,'integer',['unsigned'|['big']]),#<97>(8,1,'integer',['unsigned'|['big']]),#<108>(8,1,'integer',['unsigned'|['big']]),#<117>(8,1,'integer',['unsigned'|['big']]),#<101>(8,1,'integer',['unsigned'|['big']])}#)
    'module_info'/0 =
        fun () ->
            call 'erlang':'get_module_info'
                ('v.encoding.csv')
    'module_info'/1 =
        fun (_0) ->
            call 'erlang':'get_module_info'
                ('v.encoding.csv', _0)
    end
