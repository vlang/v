-module('v.math').
-export([inf/1, nan/0, is_nan/1, is_inf/2, is_finite/1, normalize/1, cbrt/1, mod/2, fmod/2, gcd/2, egcd/2, lcm/2, erf/1, erfc/1, exp/1, exp2/1, ldexp/2, frexp/1, expm1/1, expmulti/3, factorial/1, log_factorial/1, log_factorial_asymptotic_expansion/1, factoriali/1, floor/1, floorf/1, ceil/1, trunc/1, round/1, round_sig/2, round_to_even/1, safe_shift/2, is_neg_int/1, stirling/1, gamma/1, gamma_too_small/2, log_gamma/1, log_gamma_sign/1, sin_pi/1, hypot/2, mix/3, exp_decay/4, clip/3, remap/5, smoothstep/3, smootherstep/3, cubic_bezier/2, cubic_bezier_a/3, cubic_bezier_fa/3, cubic_bezier_coords/9, acosh/1, asinh/1, atanh/1, xatan/1, satan/1, atan/1, atan2/2, asin/1, acos/1, maxof/0, minof/0, log_n/2, log10/1, log2/1, log1p/1, log_b/1, ilog_b/1, ilog_b_/1, log/1, aprox_sin/1, aprox_cos/1, copysign/2, degrees/1, radians/1, angle_diff/2, digits/2, count_digits/1, minmax/2, clamp/3, sign/1, signi/1, signbit/1, tolerance/3, close/2, veryclose/2, alike/2, min/2, max/2, abs/1, modf/1, divide_truncated/2, divide_euclid/2, divide_floored/2, modulo_truncated/2, modulo_euclid/2, modulo_floored/2, nextafter32/2, nextafter/2, poly_n_eval/3, poly_n_1_eval/3, poly_eval/2, poly_1_eval/2, 'ChebSeries.eval_e'/2, powf/2, pow10/1, powi/2, is_odd_int/1, pow/2, q_rsqrt/1, scalbn/2, sin/1, cos/1, cosf/1, sinf/1, sincos/1, sinh/1, cosh/1, sqrt/1, sqrtf/1, sqrti/1, square/1, cube/1, tan/1, tanf/1, cot/1, tanh/1, f32_bits/1, f32_from_bits/1, f64_bits/1, f64_from_bits/1, with_set_low_word/2, with_set_high_word/2, get_high_word/1]).

inf(Sign) ->
    V = case Sign >= 0 of
        true -> todo;
        false -> todo
    end,
    f64_from_bits(V).

nan() ->
    f64_from_bits(todo).

is_nan(F) ->
    % TODO: unhandled stmt type
    ok    F /= F.

is_inf(F, Sign) ->
    (Sign >= 0 andalso F > todo) orelse (Sign =< 0 andalso F < todo).

is_finite(F) ->
    not is_nan(F) andalso not is_inf(F, 0).

normalize(X) ->
    Smallest_normal = 2.2250738585072014e-308,
    case abs(X) < Smallest_normal of
        true -> X * todo;
        false -> X
        end.

cbrt(A) ->
    X = A,
    B1 = 715094163,
    B2 = 696219795,
    C = 5.42857142857142815906e-01,
    D = -7.05306122448979611050e-01,
    E_ = 1.41428571428571436819e+00,
    F = 1.60714285714285720630e+00,
    G = 3.57142857142857150787e-01,
    Smallest_normal = 2.22507385850720138309e-308,
    case X == todo orelse is_nan(X) orelse is_inf(X, 0) of
        true -> X;
        false -> begin
            Sign = false,
            case X < 0 of
                true -> begin
                    X1 = -X,
                    Sign1 = true,
                end;
                false -> ok
            end,
            T = f64_from_bits(f64_bits(X1) div todo + (todo bsl 32)),
            case X1 < Smallest_normal of
                true -> begin
                    T1 = todo,
                    T2 = X1,
                    T3 = f64_from_bits(f64_bits(T2) div todo + (todo bsl 32)),
                end;
                false -> ok
            end,
            R = T3 * T3 / X1,
            S = C + R * T3,
            T4 = G + F / (S + E_ + D / S),
            T5 = f64_from_bits(f64_bits(T4) band (todo bsl 28) + (todo bsl 30)),
            S1 = T5 * T5,
            R1 = X1 / S1,
            W = T5 + T5,
            R2 = (R1 - T5) / (W + R1),
            T6 = T5 + T5 * R2,
            case Sign1 of
                true -> ok;
                false -> ok
            end,
            T6
        end
        end.

mod(X, Y) ->
    fmod(X, Y).

fmod(X, Y) ->
    case Y == 0 orelse is_inf(X, 0) orelse is_nan(X) orelse is_nan(Y) of
        true -> nan();
        false -> begin
            Abs_y = abs(Y),
            Abs_y_fr = element(1, frexp(Abs_y)),
            Abs_y_exp = element(2, frexp(Abs_y)),
            R = X,
            case X < 0 of
                true -> ok;
                false -> ok
            end,
            % TODO: unhandled stmt type
            ok            case X < 0 of
                true -> ok;
                false -> ok
            end,
            R
        end
        end.

gcd(A_, B_) ->
    A = A_,
    B = B_,
    case A < 0 of
        true -> ok;
        false -> ok
    end,
    case B < 0 of
        true -> ok;
        false -> ok
    end,
    % TODO: unhandled stmt type
    ok    A.

egcd(A, B) ->
    Old_r = A,
    R = B,
    Old_s = todo,
    S = todo,
    Old_t = todo,
    T = todo,
    % TODO: unhandled stmt type
    ok    case Old_r < 0 of
        true -> -Old_r;
        false -> Old_r
    end.

lcm(A, B) ->
    case A == 0 of
        true -> A;
        false -> begin
            Res = A * (B div gcd(B, A)),
            case Res < 0 of
                true -> -Res;
                false -> Res
                        end
        end
        end.

erf(A) ->
    X = A,
    Very_tiny = 2.848094538889218e-306,
    Small_ = todo / todo,
    case is_nan(X) of
        true -> nan();
        false -> 
            case is_inf(X, 1) of
                true -> 1.0;
                false -> 
                    case is_inf(X, -1) of
                        true -> todo;
                        false -> begin
                            Sign = false,
                            case X < 0 of
                                true -> begin
                                    X1 = -X,
                                    Sign1 = true,
                                end;
                                false -> ok
                            end,
                            case X1 < todo of
                                true -> Temp;
                                false -> 
                                    case X1 < todo of
                                        true -> todo + P / Q;
                                        false -> 
                                            case X1 >= 6 of
                                                true -> 1.0;
                                                false -> begin
                                                    S_ = todo / (X1 * X1),
                                                    R = 0.0,
                                                    S = 0.0,
                                                    case X1 < todo of
                                                        true -> begin
                                                            Tmp41 = S_ * (todo + S_ * (todo + S_ * todo)),
                                                            R1 = todo + S_ * (todo + S_ * (todo + S_ * (todo + S_ * (todo + Tmp41)))),
                                                            Tmp42 = S_ * (todo + S_ * (todo + S_ * (todo + S_ * todo))),
                                                            S1 = todo + S_ * (todo + S_ * (todo + S_ * (todo + S_ * (todo + Tmp42)))),
                                                        end;
                                                        false -> begin
                                                            Tmp31 = todo + S_ * (todo + S_ * todo),
                                                            R2 = todo + S_ * (todo + S_ * (todo + S_ * (todo + S_ * Tmp31))),
                                                            Tmp32 = todo + S_ * (todo + S_ * (todo + S_ * todo)),
                                                            S2 = todo + S_ * (todo + S_ * (todo + S_ * (todo + S_ * Tmp32))),
                                                        end
                                                    end,
                                                    Z = f64_from_bits(f64_bits(X1) band 16#ffffffff00000000),
                                                    R_ = exp(-Z * Z - todo) * exp((Z - X1) * (Z + X1) + R2 / S2),
                                                    case Sign1 of
                                                        true -> R_ / X1 - todo;
                                                        false -> todo - R_ / X1
                                                                                                        end
                                                end
                                                                                        end
                                                                                                                end
                                                                                        end
                        end
                                        end
                                        end
                end.

erfc(A) ->
    X = A,
    Tiny = todo / todo,
    case is_nan(X) of
        true -> nan();
        false -> 
            case is_inf(X, 1) of
                true -> 0.0;
                false -> 
                    case is_inf(X, -1) of
                        true -> 2.0;
                        false -> begin
                            Sign = false,
                            case X < 0 of
                                true -> begin
                                    X1 = -X,
                                    Sign1 = true,
                                end;
                                false -> ok
                            end,
                            case X1 < todo of
                                true -> todo - Temp;
                                false -> 
                                    case X1 < todo of
                                        true -> todo - P / Q;
                                        false -> 
                                            case X1 < 28 of
                                                true -> R_ / X1;
                                                false -> 
                                                    case Sign1 of
                                                        true -> 2.0;
                                                        false -> 0.0
                                                                                                        end
                                                                                                                                        end
                                                                                                                end
                                                                                        end
                        end
                                        end
                                        end
                end.

exp(X) ->
    Log2e = 1.44269504088896338700e+00,
    Overflow = 7.09782712893383973096e+02,
    Underflow = -7.45133219101941108420e+02,
    Near_zero = 1.0 / 268435456,
    case is_nan(X) orelse is_inf(X, 1) of
        true -> X;
        false -> 
            case is_inf(X, -1) of
                true -> 0.0;
                false -> 
                    case X > Overflow of
                        true -> inf(1);
                        false -> 
                            case X < Underflow of
                                true -> 0.0;
                                false -> 
                                    case -Near_zero < X andalso X < Near_zero of
                                        true -> todo + X;
                                        false -> begin
                                            K = 0,
                                            case X < 0 of
                                                true -> ok;
                                                false -> ok
                                            end,
                                            case X > 0 of
                                                true -> ok;
                                                false -> ok
                                            end,
                                            Hi = X - todo * todo,
                                            Lo = todo * todo,
                                            expmulti(Hi, Lo, K)
                                        end
                                                                        end
                                                                                        end
                                                                end
                                        end
                end.

exp2(X) ->
    Overflow = 1.0239999999999999e+03,
    Underflow = -1.0740e+03,
    case is_nan(X) orelse is_inf(X, 1) of
        true -> X;
        false -> 
            case is_inf(X, -1) of
                true -> 0;
                false -> 
                    case X > Overflow of
                        true -> inf(1);
                        false -> 
                            case X < Underflow of
                                true -> 0;
                                false -> begin
                                    K = 0,
                                    case X > 0 of
                                        true -> ok;
                                        false -> ok
                                    end,
                                    case X < 0 of
                                        true -> ok;
                                        false -> ok
                                    end,
                                    T = X - todo,
                                    Hi = T * todo,
                                    Lo = -T * todo,
                                    expmulti(Hi, Lo, K)
                                end
                                                        end
                                                                end
                                        end
                end.

ldexp(Frac, Exp) ->
    scalbn(Frac, Exp).

frexp(X) ->
    Y = f64_bits(X),
    Ee = todo,
    case Ee == 0 of
        true -> begin
            case X /= todo of
                true -> begin
                    X1p64 = f64_from_bits(todo),
                    Z = element(1, frexp(X * X1p64)),
                    E_ = element(2, frexp(X * X1p64)),
                    Z
                end;
                false -> ok
            end,
            X
        end;
        false -> case Ee == 16#7ff of
            true -> X;
            false -> ok
        end
    end,
    E_1 = Ee - 16#3fe,
    Y1 = todo,
    Y2 = todo,
    f64_from_bits(Y2).

expm1(X) ->
    case is_inf(X, 1) orelse is_nan(X) of
        true -> X;
        false -> 
            case is_inf(X, -1) of
                true -> todo;
                false -> case abs(X) < todo of
                    true -> begin
                        I = 1.0,
                        Sum = X,
                        Term = X / todo,
                        todo,
                        Term1 = X / todo,
                        Sum1 = Term1,
                        % TODO: unhandled stmt type
                        ok                        Sum1
                    end;
                    false -> exp(X) - 1
                end
                        end
                end.

expmulti(Hi, Lo, K) ->
    Exp_p1 = 1.66666666666666657415e-01,
    Exp_p2 = -2.77777777770155933842e-03,
    Exp_p3 = 6.61375632143793436117e-05,
    Exp_p4 = -1.65339022054652515390e-06,
    Exp_p5 = 4.13813679705723846039e-08,
    R = Hi - Lo,
    T = R * R,
    C = R - T * (Exp_p1 + T * (Exp_p2 + T * (Exp_p3 + T * (Exp_p4 + T * Exp_p5)))),
    Y = 1 - ((Lo - (R * C) / (2 - C)) - Hi),
    ldexp(Y, K).

factorial(N) ->
    case N >= length([1.000000000000000000000e+0, 1.000000000000000000000e+0, 2.000000000000000000000e+0, 6.000000000000000000000e+0, 2.400000000000000000000e+1, 1.200000000000000000000e+2, 7.200000000000000000000e+2, 5.040000000000000000000e+3, 4.032000000000000000000e+4, 3.628800000000000000000e+5, 3.628800000000000000000e+6, 3.991680000000000000000e+7, 4.790016000000000000000e+8, 6.227020800000000000000e+9, 8.717829120000000000000e+10, 1.307674368000000000000e+12, 2.092278988800000000000e+13, 3.556874280960000000000e+14, 6.402373705728000000000e+15, 1.216451004088320000000e+17, 2.432902008176640000000e+18, 5.109094217170944000000e+19, 1.124000727777607680000e+21, 2.585201673888497664000e+22, 6.204484017332394393600e+23, 1.551121004333098598400e+25, 4.032914611266056355840e+26, 1.088886945041835216077e+28, 3.048883446117138605015e+29, 8.841761993739701954544e+30, 2.652528598121910586363e+32, 8.222838654177922817726e+33, 2.631308369336935301672e+35, 8.683317618811886495518e+36, 2.952327990396041408476e+38, 1.033314796638614492967e+40, 3.719933267899012174680e+41, 1.376375309122634504632e+43, 5.230226174666011117600e+44, 2.039788208119744335864e+46, 8.159152832478977343456e+47, 3.345252661316380710817e+49, 1.405006117752879898543e+51, 6.041526306337383563736e+52, 2.658271574788448768044e+54, 1.196222208654801945620e+56, 5.502622159812088949850e+57, 2.586232415111681806430e+59, 1.241391559253607267086e+61, 6.082818640342675608723e+62, 3.041409320171337804361e+64, 1.551118753287382280224e+66, 8.065817517094387857166e+67, 4.274883284060025564298e+69, 2.308436973392413804721e+71, 1.269640335365827592597e+73, 7.109985878048634518540e+74, 4.052691950487721675568e+76, 2.350561331282878571829e+78, 1.386831185456898357379e+80, 8.320987112741390144276e+81, 5.075802138772247988009e+83, 3.146997326038793752565e+85, 1.982608315404440064116e+87, 1.268869321858841641034e+89, 8.247650592082470666723e+90, 5.443449390774430640037e+92, 3.647111091818868528825e+94, 2.480035542436830599601e+96, 1.711224524281413113725e+98, 1.197857166996989179607e+100, 8.504785885678623175212e+101, 6.123445837688608686152e+103, 4.470115461512684340891e+105, 3.307885441519386412260e+107, 2.480914081139539809195e+109, 1.885494701666050254988e+111, 1.451830920282858696341e+113, 1.132428117820629783146e+115, 8.946182130782975286851e+116, 7.156945704626380229481e+118, 5.797126020747367985880e+120, 4.753643337012841748421e+122, 3.945523969720658651190e+124, 3.314240134565353266999e+126, 2.817104114380550276949e+128, 2.422709538367273238177e+130, 2.107757298379527717214e+132, 1.854826422573984391148e+134, 1.650795516090846108122e+136, 1.485715964481761497310e+138, 1.352001527678402962552e+140, 1.243841405464130725548e+142, 1.156772507081641574759e+144, 1.087366156656743080274e+146, 1.032997848823905926260e+148, 9.916779348709496892096e+149, 9.619275968248211985333e+151, 9.426890448883247745626e+153, 9.332621544394415268170e+155, 9.332621544394415268170e+157, 9.425947759838359420852e+159, 9.614466715035126609269e+161, 9.902900716486180407547e+163, 1.029901674514562762385e+166, 1.081396758240290900504e+168, 1.146280563734708354534e+170, 1.226520203196137939352e+172, 1.324641819451828974500e+174, 1.443859583202493582205e+176, 1.588245541522742940425e+178, 1.762952551090244663872e+180, 1.974506857221074023537e+182, 2.231192748659813646597e+184, 2.543559733472187557120e+186, 2.925093693493015690688e+188, 3.393108684451898201198e+190, 3.969937160808720895402e+192, 4.684525849754290656574e+194, 5.574585761207605881323e+196, 6.689502913449127057588e+198, 8.094298525273443739682e+200, 9.875044200833601362412e+202, 1.214630436702532967577e+205, 1.506141741511140879795e+207, 1.882677176888926099744e+209, 2.372173242880046885677e+211, 3.012660018457659544810e+213, 3.856204823625804217357e+215, 4.974504222477287440390e+217, 6.466855489220473672507e+219, 8.471580690878820510985e+221, 1.118248651196004307450e+224, 1.487270706090685728908e+226, 1.992942746161518876737e+228, 2.690472707318050483595e+230, 3.659042881952548657690e+232, 5.012888748274991661035e+234, 6.917786472619488492228e+236, 9.615723196941089004197e+238, 1.346201247571752460588e+241, 1.898143759076170969429e+243, 2.695364137888162776589e+245, 3.854370717180072770522e+247, 5.550293832739304789551e+249, 8.047926057471991944849e+251, 1.174997204390910823948e+254, 1.727245890454638911203e+256, 2.556323917872865588581e+258, 3.808922637630569726986e+260, 5.713383956445854590479e+262, 8.627209774233240431623e+264, 1.311335885683452545607e+267, 2.006343905095682394778e+269, 3.089769613847350887959e+271, 4.789142901463393876336e+273, 7.471062926282894447084e+275, 1.172956879426414428192e+278, 1.853271869493734796544e+280, 2.946702272495038326504e+282, 4.714723635992061322407e+284, 7.590705053947218729075e+286, 1.229694218739449434110e+289, 2.004401576545302577600e+291, 3.287218585534296227263e+293, 5.423910666131588774984e+295, 9.003691705778437366474e+297, 1.503616514864999040201e+300, 2.526075744973198387538e+302, 4.269068009004705274939e+304, 7.257415615307998967397e+306]) of
        true -> 1.797693134862315708145274237317043567981e+308;
        false -> 
            case N == todo andalso N >= todo of
                true -> lists:nth(todo + 1, [1.000000000000000000000e+0, 1.000000000000000000000e+0, 2.000000000000000000000e+0, 6.000000000000000000000e+0, 2.400000000000000000000e+1, 1.200000000000000000000e+2, 7.200000000000000000000e+2, 5.040000000000000000000e+3, 4.032000000000000000000e+4, 3.628800000000000000000e+5, 3.628800000000000000000e+6, 3.991680000000000000000e+7, 4.790016000000000000000e+8, 6.227020800000000000000e+9, 8.717829120000000000000e+10, 1.307674368000000000000e+12, 2.092278988800000000000e+13, 3.556874280960000000000e+14, 6.402373705728000000000e+15, 1.216451004088320000000e+17, 2.432902008176640000000e+18, 5.109094217170944000000e+19, 1.124000727777607680000e+21, 2.585201673888497664000e+22, 6.204484017332394393600e+23, 1.551121004333098598400e+25, 4.032914611266056355840e+26, 1.088886945041835216077e+28, 3.048883446117138605015e+29, 8.841761993739701954544e+30, 2.652528598121910586363e+32, 8.222838654177922817726e+33, 2.631308369336935301672e+35, 8.683317618811886495518e+36, 2.952327990396041408476e+38, 1.033314796638614492967e+40, 3.719933267899012174680e+41, 1.376375309122634504632e+43, 5.230226174666011117600e+44, 2.039788208119744335864e+46, 8.159152832478977343456e+47, 3.345252661316380710817e+49, 1.405006117752879898543e+51, 6.041526306337383563736e+52, 2.658271574788448768044e+54, 1.196222208654801945620e+56, 5.502622159812088949850e+57, 2.586232415111681806430e+59, 1.241391559253607267086e+61, 6.082818640342675608723e+62, 3.041409320171337804361e+64, 1.551118753287382280224e+66, 8.065817517094387857166e+67, 4.274883284060025564298e+69, 2.308436973392413804721e+71, 1.269640335365827592597e+73, 7.109985878048634518540e+74, 4.052691950487721675568e+76, 2.350561331282878571829e+78, 1.386831185456898357379e+80, 8.320987112741390144276e+81, 5.075802138772247988009e+83, 3.146997326038793752565e+85, 1.982608315404440064116e+87, 1.268869321858841641034e+89, 8.247650592082470666723e+90, 5.443449390774430640037e+92, 3.647111091818868528825e+94, 2.480035542436830599601e+96, 1.711224524281413113725e+98, 1.197857166996989179607e+100, 8.504785885678623175212e+101, 6.123445837688608686152e+103, 4.470115461512684340891e+105, 3.307885441519386412260e+107, 2.480914081139539809195e+109, 1.885494701666050254988e+111, 1.451830920282858696341e+113, 1.132428117820629783146e+115, 8.946182130782975286851e+116, 7.156945704626380229481e+118, 5.797126020747367985880e+120, 4.753643337012841748421e+122, 3.945523969720658651190e+124, 3.314240134565353266999e+126, 2.817104114380550276949e+128, 2.422709538367273238177e+130, 2.107757298379527717214e+132, 1.854826422573984391148e+134, 1.650795516090846108122e+136, 1.485715964481761497310e+138, 1.352001527678402962552e+140, 1.243841405464130725548e+142, 1.156772507081641574759e+144, 1.087366156656743080274e+146, 1.032997848823905926260e+148, 9.916779348709496892096e+149, 9.619275968248211985333e+151, 9.426890448883247745626e+153, 9.332621544394415268170e+155, 9.332621544394415268170e+157, 9.425947759838359420852e+159, 9.614466715035126609269e+161, 9.902900716486180407547e+163, 1.029901674514562762385e+166, 1.081396758240290900504e+168, 1.146280563734708354534e+170, 1.226520203196137939352e+172, 1.324641819451828974500e+174, 1.443859583202493582205e+176, 1.588245541522742940425e+178, 1.762952551090244663872e+180, 1.974506857221074023537e+182, 2.231192748659813646597e+184, 2.543559733472187557120e+186, 2.925093693493015690688e+188, 3.393108684451898201198e+190, 3.969937160808720895402e+192, 4.684525849754290656574e+194, 5.574585761207605881323e+196, 6.689502913449127057588e+198, 8.094298525273443739682e+200, 9.875044200833601362412e+202, 1.214630436702532967577e+205, 1.506141741511140879795e+207, 1.882677176888926099744e+209, 2.372173242880046885677e+211, 3.012660018457659544810e+213, 3.856204823625804217357e+215, 4.974504222477287440390e+217, 6.466855489220473672507e+219, 8.471580690878820510985e+221, 1.118248651196004307450e+224, 1.487270706090685728908e+226, 1.992942746161518876737e+228, 2.690472707318050483595e+230, 3.659042881952548657690e+232, 5.012888748274991661035e+234, 6.917786472619488492228e+236, 9.615723196941089004197e+238, 1.346201247571752460588e+241, 1.898143759076170969429e+243, 2.695364137888162776589e+245, 3.854370717180072770522e+247, 5.550293832739304789551e+249, 8.047926057471991944849e+251, 1.174997204390910823948e+254, 1.727245890454638911203e+256, 2.556323917872865588581e+258, 3.808922637630569726986e+260, 5.713383956445854590479e+262, 8.627209774233240431623e+264, 1.311335885683452545607e+267, 2.006343905095682394778e+269, 3.089769613847350887959e+271, 4.789142901463393876336e+273, 7.471062926282894447084e+275, 1.172956879426414428192e+278, 1.853271869493734796544e+280, 2.946702272495038326504e+282, 4.714723635992061322407e+284, 7.590705053947218729075e+286, 1.229694218739449434110e+289, 2.004401576545302577600e+291, 3.287218585534296227263e+293, 5.423910666131588774984e+295, 9.003691705778437366474e+297, 1.503616514864999040201e+300, 2.526075744973198387538e+302, 4.269068009004705274939e+304, 7.257415615307998967397e+306]);
                false -> gamma(N + todo)
                        end
                end.

log_factorial(N) ->
    case N < 0 of
        true -> -1.797693134862315708145274237317043567981e+308;
        false -> begin
            case N /= todo of
                true -> log_gamma(N + 1);
                false -> case N < length([0.000000000000000000000e+0, 0.000000000000000000000e+0, 6.931471805599453094172e-1, 1.791759469228055000812e+0, 3.178053830347945619647e+0, 4.787491742782045994248e+0, 6.579251212010100995060e+0, 8.525161361065414300166e+0, 1.060460290274525022842e+1, 1.280182748008146961121e+1, 1.510441257307551529523e+1, 1.750230784587388583929e+1, 1.998721449566188614952e+1, 2.255216385312342288557e+1, 2.519122118273868150009e+1, 2.789927138384089156609e+1, 3.067186010608067280376e+1, 3.350507345013688888401e+1, 3.639544520803305357622e+1, 3.933988418719949403622e+1, 4.233561646075348502966e+1, 4.538013889847690802616e+1, 4.847118135183522387964e+1, 5.160667556776437357045e+1, 5.478472939811231919009e+1, 5.800360522298051993929e+1, 6.126170176100200198477e+1, 6.455753862700633105895e+1, 6.788974313718153498289e+1, 7.125703896716800901007e+1, 7.465823634883016438549e+1, 7.809222355331531063142e+1, 8.155795945611503717850e+1, 8.505446701758151741396e+1, 8.858082754219767880363e+1, 9.213617560368709248333e+1, 9.571969454214320248496e+1, 9.933061245478742692933e+1, 1.029681986145138126988e+2, 1.066317602606434591262e+2, 1.103206397147573954291e+2, 1.140342117814617032329e+2, 1.177718813997450715388e+2, 1.215330815154386339623e+2, 1.253172711493568951252e+2, 1.291239336391272148826e+2, 1.329525750356163098828e+2, 1.368027226373263684696e+2, 1.406739236482342593987e+2, 1.445657439463448860089e+2, 1.484777669517730320675e+2, 1.524095925844973578392e+2, 1.563608363030787851941e+2, 1.603311282166309070282e+2, 1.643201122631951814118e+2, 1.683274454484276523305e+2, 1.723527971391628015638e+2, 1.763958484069973517152e+2, 1.804562914175437710518e+2, 1.845338288614494905025e+2, 1.886281734236715911873e+2, 1.927390472878449024360e+2, 1.968661816728899939914e+2, 2.010093163992815266793e+2, 2.051681994826411985358e+2, 2.093425867525368356464e+2, 2.135322414945632611913e+2, 2.177369341139542272510e+2, 2.219564418191303339501e+2, 2.261905483237275933323e+2, 2.304390435657769523214e+2, 2.347017234428182677427e+2, 2.389783895618343230538e+2, 2.432688490029827141829e+2, 2.475729140961868839366e+2, 2.518904022097231943772e+2, 2.562211355500095254561e+2, 2.605649409718632093053e+2, 2.649216497985528010421e+2, 2.692910976510198225363e+2, 2.736731242856937041486e+2, 2.780675734403661429141e+2, 2.824742926876303960274e+2, 2.868931332954269939509e+2, 2.913239500942703075662e+2, 2.957666013507606240211e+2, 3.002209486470141317540e+2, 3.046868567656687154726e+2, 3.091641935801469219449e+2, 3.136528299498790617832e+2, 3.181526396202093268500e+2, 3.226634991267261768912e+2, 3.271852877037752172008e+2, 3.317178871969284731381e+2, 3.362611819791984770344e+2, 3.408150588707990178690e+2, 3.453794070622668541074e+2, 3.499541180407702369296e+2, 3.545390855194408088492e+2, 3.591342053695753987760e+2, 3.637393755555634901441e+2, 3.683544960724047495950e+2, 3.729794688856890206760e+2, 3.776141978739186564468e+2, 3.822585887730600291111e+2, 3.869125491232175524822e+2, 3.915759882173296196258e+2, 3.962488170517915257991e+2, 4.009309482789157454921e+2, 4.056222961611448891925e+2, 4.103227765269373054205e+2, 4.150323067282496395563e+2, 4.197508055995447340991e+2, 4.244781934182570746677e+2, 4.292143918666515701285e+2, 4.339593239950148201939e+2, 4.387129141861211848399e+2, 4.434750881209189409588e+2, 4.482457727453846057188e+2, 4.530248962384961351041e+2, 4.578123879812781810984e+2, 4.626081785268749221865e+2, 4.674121995716081787447e+2, 4.722243839269805962399e+2, 4.770446654925856331047e+2, 4.818729792298879342285e+2, 4.867092611368394122258e+2, 4.915534482232980034989e+2, 4.964054784872176206648e+2, 5.012652908915792927797e+2, 5.061328253420348751997e+2, 5.110080226652360267439e+2, 5.158908245878223975982e+2, 5.207811737160441513633e+2, 5.256790135159950627324e+2, 5.305842882944334921812e+2, 5.354969431801695441897e+2, 5.404169241059976691050e+2, 5.453441777911548737966e+2, 5.502786517242855655538e+2, 5.552202941468948698523e+2, 5.601690540372730381305e+2, 5.651248810948742988613e+2, 5.700877257251342061414e+2, 5.750575390247102067619e+2, 5.800342727671307811636e+2, 5.850178793888391176022e+2, 5.900083119756178539038e+2, 5.950055242493819689670e+2, 6.000094705553274281080e+2, 6.050201058494236838580e+2, 6.100373856862386081868e+2, 6.150612662070848845750e+2, 6.200917041284773200381e+2, 6.251286567308909491967e+2, 6.301720818478101958172e+2, 6.352219378550597328635e+2, 6.402781836604080409209e+2, 6.453407786934350077245e+2, 6.504096828956552392500e+2, 6.554848567108890661717e+2, 6.605662610758735291676e+2, 6.656538574111059132426e+2, 6.707476076119126755767e+2, 6.758474740397368739994e+2, 6.809534195136374546094e+2, 6.860654073019939978423e+2, 6.911834011144107529496e+2, 6.963073650938140118743e+2, 7.014372638087370853465e+2, 7.065730622457873471107e+2, 7.117147258022900069535e+2]) of
                    true -> lists:nth(todo + 1, [0.000000000000000000000e+0, 0.000000000000000000000e+0, 6.931471805599453094172e-1, 1.791759469228055000812e+0, 3.178053830347945619647e+0, 4.787491742782045994248e+0, 6.579251212010100995060e+0, 8.525161361065414300166e+0, 1.060460290274525022842e+1, 1.280182748008146961121e+1, 1.510441257307551529523e+1, 1.750230784587388583929e+1, 1.998721449566188614952e+1, 2.255216385312342288557e+1, 2.519122118273868150009e+1, 2.789927138384089156609e+1, 3.067186010608067280376e+1, 3.350507345013688888401e+1, 3.639544520803305357622e+1, 3.933988418719949403622e+1, 4.233561646075348502966e+1, 4.538013889847690802616e+1, 4.847118135183522387964e+1, 5.160667556776437357045e+1, 5.478472939811231919009e+1, 5.800360522298051993929e+1, 6.126170176100200198477e+1, 6.455753862700633105895e+1, 6.788974313718153498289e+1, 7.125703896716800901007e+1, 7.465823634883016438549e+1, 7.809222355331531063142e+1, 8.155795945611503717850e+1, 8.505446701758151741396e+1, 8.858082754219767880363e+1, 9.213617560368709248333e+1, 9.571969454214320248496e+1, 9.933061245478742692933e+1, 1.029681986145138126988e+2, 1.066317602606434591262e+2, 1.103206397147573954291e+2, 1.140342117814617032329e+2, 1.177718813997450715388e+2, 1.215330815154386339623e+2, 1.253172711493568951252e+2, 1.291239336391272148826e+2, 1.329525750356163098828e+2, 1.368027226373263684696e+2, 1.406739236482342593987e+2, 1.445657439463448860089e+2, 1.484777669517730320675e+2, 1.524095925844973578392e+2, 1.563608363030787851941e+2, 1.603311282166309070282e+2, 1.643201122631951814118e+2, 1.683274454484276523305e+2, 1.723527971391628015638e+2, 1.763958484069973517152e+2, 1.804562914175437710518e+2, 1.845338288614494905025e+2, 1.886281734236715911873e+2, 1.927390472878449024360e+2, 1.968661816728899939914e+2, 2.010093163992815266793e+2, 2.051681994826411985358e+2, 2.093425867525368356464e+2, 2.135322414945632611913e+2, 2.177369341139542272510e+2, 2.219564418191303339501e+2, 2.261905483237275933323e+2, 2.304390435657769523214e+2, 2.347017234428182677427e+2, 2.389783895618343230538e+2, 2.432688490029827141829e+2, 2.475729140961868839366e+2, 2.518904022097231943772e+2, 2.562211355500095254561e+2, 2.605649409718632093053e+2, 2.649216497985528010421e+2, 2.692910976510198225363e+2, 2.736731242856937041486e+2, 2.780675734403661429141e+2, 2.824742926876303960274e+2, 2.868931332954269939509e+2, 2.913239500942703075662e+2, 2.957666013507606240211e+2, 3.002209486470141317540e+2, 3.046868567656687154726e+2, 3.091641935801469219449e+2, 3.136528299498790617832e+2, 3.181526396202093268500e+2, 3.226634991267261768912e+2, 3.271852877037752172008e+2, 3.317178871969284731381e+2, 3.362611819791984770344e+2, 3.408150588707990178690e+2, 3.453794070622668541074e+2, 3.499541180407702369296e+2, 3.545390855194408088492e+2, 3.591342053695753987760e+2, 3.637393755555634901441e+2, 3.683544960724047495950e+2, 3.729794688856890206760e+2, 3.776141978739186564468e+2, 3.822585887730600291111e+2, 3.869125491232175524822e+2, 3.915759882173296196258e+2, 3.962488170517915257991e+2, 4.009309482789157454921e+2, 4.056222961611448891925e+2, 4.103227765269373054205e+2, 4.150323067282496395563e+2, 4.197508055995447340991e+2, 4.244781934182570746677e+2, 4.292143918666515701285e+2, 4.339593239950148201939e+2, 4.387129141861211848399e+2, 4.434750881209189409588e+2, 4.482457727453846057188e+2, 4.530248962384961351041e+2, 4.578123879812781810984e+2, 4.626081785268749221865e+2, 4.674121995716081787447e+2, 4.722243839269805962399e+2, 4.770446654925856331047e+2, 4.818729792298879342285e+2, 4.867092611368394122258e+2, 4.915534482232980034989e+2, 4.964054784872176206648e+2, 5.012652908915792927797e+2, 5.061328253420348751997e+2, 5.110080226652360267439e+2, 5.158908245878223975982e+2, 5.207811737160441513633e+2, 5.256790135159950627324e+2, 5.305842882944334921812e+2, 5.354969431801695441897e+2, 5.404169241059976691050e+2, 5.453441777911548737966e+2, 5.502786517242855655538e+2, 5.552202941468948698523e+2, 5.601690540372730381305e+2, 5.651248810948742988613e+2, 5.700877257251342061414e+2, 5.750575390247102067619e+2, 5.800342727671307811636e+2, 5.850178793888391176022e+2, 5.900083119756178539038e+2, 5.950055242493819689670e+2, 6.000094705553274281080e+2, 6.050201058494236838580e+2, 6.100373856862386081868e+2, 6.150612662070848845750e+2, 6.200917041284773200381e+2, 6.251286567308909491967e+2, 6.301720818478101958172e+2, 6.352219378550597328635e+2, 6.402781836604080409209e+2, 6.453407786934350077245e+2, 6.504096828956552392500e+2, 6.554848567108890661717e+2, 6.605662610758735291676e+2, 6.656538574111059132426e+2, 6.707476076119126755767e+2, 6.758474740397368739994e+2, 6.809534195136374546094e+2, 6.860654073019939978423e+2, 6.911834011144107529496e+2, 6.963073650938140118743e+2, 7.014372638087370853465e+2, 7.065730622457873471107e+2, 7.117147258022900069535e+2]);
                    false -> ok
                end
            end,
            log_factorial_asymptotic_expansion(todo)
        end
        end.

log_factorial_asymptotic_expansion(N) ->
    M = 6,
    Term = [],
    Xx = todo,
    Xj = todo,
    Log_factorial = todo - Xj + (Xj - todo) * log(Xj),
    I = 0,
    % TODO: unhandled stmt type
    ok    Sum = lists:nth(M - 1 + 1, Term),
    % TODO: unhandled stmt type
    ok    % TODO: unhandled stmt type
    ok    Log_factorial + Sum.

factoriali(N) ->
    case N =< 0 of
        true -> todo;
        false -> 
            case N < 21 of
                true -> todo;
                false -> todo
                        end
                end.

floor(X) ->
    case X == 0 orelse is_nan(X) orelse is_inf(X, 0) of
        true -> X;
        false -> 
            case X < 0 of
                true -> -D;
                false -> begin
                    D = element(1, modf(X)),
                    D
                end
                        end
                end.

floorf(X) ->
    todo.

ceil(X) ->
    -floor(-X).

trunc(X) ->
    case X == 0 orelse is_nan(X) orelse is_inf(X, 0) of
        true -> X;
        false -> begin
            D = element(1, modf(X)),
            D
        end
        end.

round(X) ->
    Bits = f64_bits(X),
    E_ = (Bits bsr 52) band 16#7FF,
    case E_ < 1023 of
        true -> begin
            Bits1 = todo,
            case E_ == 1022 of
                true -> ok;
                false -> ok
            end
        end;
        false -> case E_ < 1075 of
            true -> begin
                Half = todo bsl 51,
                E_1 = 1023,
                Bits2 = Half bsr E_1,
                Bits3 = bnot (todo bsr E_1),
            end;
            false -> ok
        end
    end,
    f64_from_bits(Bits3).

round_sig(X, Sig_digits) ->
    Ret_str = float_to_binary(X),
    case Sig_digits of
        0 -> ok;
        1 -> ok;
        2 -> ok;
        3 -> ok;
        4 -> ok;
        5 -> ok;
        6 -> ok;
        7 -> ok;
        8 -> ok;
        9 -> ok;
        10 -> ok;
        11 -> ok;
        12 -> ok;
        13 -> ok;
        14 -> ok;
        15 -> ok;
        16 -> ok;
        _ -> ok
    end,
    'string.f64'(Ret_str).

round_to_even(X) ->
    Bits = f64_bits(X),
    E_ = (Bits bsr 52) band 16#7FF,
    case E_ >= 1023 of
        true -> begin
            Half_minus_ulp = todo - 1,
            E_1 = todo,
            Bits1 = safe_shift(Half_minus_ulp + safe_shift(Bits, 52 - E_1) band 1, E_1),
            Bits2 = bnot safe_shift(todo, E_1),
        end;
        false -> case E_1 == 1022 andalso Bits2 band todo /= 0 of
            true -> ok;
            false -> ok
        end
    end,
    f64_from_bits(Bits2).

safe_shift(Value, Shift) ->
    case Shift > todo of
        true -> todo;
        false -> Value bsr Shift
    end.

is_neg_int(X) ->
    case X < 0 of
        true -> Xf == 0;
        false -> false
        end.

stirling(X) ->
    case X > 200 of
        true -> inf(1);
        false -> begin
            W = todo / X,
            W1 = todo + W * ((((lists:nth(1, [7.87311395793093628397e-04, -2.29549961613378126380e-04, -2.68132617805781232825e-03, 3.47222221605458667310e-03, 8.33333333333482257126e-02]) * W + lists:nth(2, [7.87311395793093628397e-04, -2.29549961613378126380e-04, -2.68132617805781232825e-03, 3.47222221605458667310e-03, 8.33333333333482257126e-02])) * W + lists:nth(3, [7.87311395793093628397e-04, -2.29549961613378126380e-04, -2.68132617805781232825e-03, 3.47222221605458667310e-03, 8.33333333333482257126e-02])) * W + lists:nth(4, [7.87311395793093628397e-04, -2.29549961613378126380e-04, -2.68132617805781232825e-03, 3.47222221605458667310e-03, 8.33333333333482257126e-02])) * W + lists:nth(5, [7.87311395793093628397e-04, -2.29549961613378126380e-04, -2.68132617805781232825e-03, 3.47222221605458667310e-03, 8.33333333333482257126e-02])),
            Y1 = exp(X),
            Y2 = 1.0,
            case X > todo of
                true -> begin
                    V = pow(X, todo * X - todo),
                    Y1_ = Y1,
                    Y11 = V,
                    Y21 = V / Y1_,
                end;
                false -> ok
            end,
            Y11
        end
        end.

gamma(A) ->
    X = A,
    case is_neg_int(X) orelse is_inf(X, -1) orelse is_nan(X) of
        true -> nan();
        false -> 
            case is_inf(X, 1) of
                true -> inf(1);
                false -> 
                    case X == todo of
                        true -> copysign(inf(1), X);
                        false -> begin
                            Q = abs(X),
                            P = floor(Q),
                            case Q > 33 of
                                true -> todo * Z;
                                false -> begin
                                    Z = 1.0,
                                    % TODO: unhandled stmt type
                                    ok                                    % TODO: unhandled stmt type
                                    ok                                    % TODO: unhandled stmt type
                                    ok                                    case X == 2 of
                                        true -> Z;
                                        false -> begin
                                            X1 = X - 2,
                                            P1 = (((((X1 * lists:nth(1, [1.60119522476751861407e-04, 1.19135147006586384913e-03, 1.04213797561761569935e-02, 4.76367800457137231464e-02, 2.07448227648435975150e-01, 4.94214826801497100753e-01, 9.99999999999999996796e-01]) + lists:nth(2, [1.60119522476751861407e-04, 1.19135147006586384913e-03, 1.04213797561761569935e-02, 4.76367800457137231464e-02, 2.07448227648435975150e-01, 4.94214826801497100753e-01, 9.99999999999999996796e-01])) * X1 + lists:nth(3, [1.60119522476751861407e-04, 1.19135147006586384913e-03, 1.04213797561761569935e-02, 4.76367800457137231464e-02, 2.07448227648435975150e-01, 4.94214826801497100753e-01, 9.99999999999999996796e-01])) * X1 + lists:nth(4, [1.60119522476751861407e-04, 1.19135147006586384913e-03, 1.04213797561761569935e-02, 4.76367800457137231464e-02, 2.07448227648435975150e-01, 4.94214826801497100753e-01, 9.99999999999999996796e-01])) * X1 + lists:nth(5, [1.60119522476751861407e-04, 1.19135147006586384913e-03, 1.04213797561761569935e-02, 4.76367800457137231464e-02, 2.07448227648435975150e-01, 4.94214826801497100753e-01, 9.99999999999999996796e-01])) * X1 + lists:nth(6, [1.60119522476751861407e-04, 1.19135147006586384913e-03, 1.04213797561761569935e-02, 4.76367800457137231464e-02, 2.07448227648435975150e-01, 4.94214826801497100753e-01, 9.99999999999999996796e-01])) * X1 + lists:nth(7, [1.60119522476751861407e-04, 1.19135147006586384913e-03, 1.04213797561761569935e-02, 4.76367800457137231464e-02, 2.07448227648435975150e-01, 4.94214826801497100753e-01, 9.99999999999999996796e-01]),
                                            Q1 = ((((((X1 * lists:nth(1, [-2.31581873324120129819e-05, 5.39605580493303397842e-04, -4.45641913851797240494e-03, 1.18139785222060435552e-02, 3.58236398605498653373e-02, -2.34591795718243348568e-01, 7.14304917030273074085e-02, 1.00000000000000000320e+00]) + lists:nth(2, [-2.31581873324120129819e-05, 5.39605580493303397842e-04, -4.45641913851797240494e-03, 1.18139785222060435552e-02, 3.58236398605498653373e-02, -2.34591795718243348568e-01, 7.14304917030273074085e-02, 1.00000000000000000320e+00])) * X1 + lists:nth(3, [-2.31581873324120129819e-05, 5.39605580493303397842e-04, -4.45641913851797240494e-03, 1.18139785222060435552e-02, 3.58236398605498653373e-02, -2.34591795718243348568e-01, 7.14304917030273074085e-02, 1.00000000000000000320e+00])) * X1 + lists:nth(4, [-2.31581873324120129819e-05, 5.39605580493303397842e-04, -4.45641913851797240494e-03, 1.18139785222060435552e-02, 3.58236398605498653373e-02, -2.34591795718243348568e-01, 7.14304917030273074085e-02, 1.00000000000000000320e+00])) * X1 + lists:nth(5, [-2.31581873324120129819e-05, 5.39605580493303397842e-04, -4.45641913851797240494e-03, 1.18139785222060435552e-02, 3.58236398605498653373e-02, -2.34591795718243348568e-01, 7.14304917030273074085e-02, 1.00000000000000000320e+00])) * X1 + lists:nth(6, [-2.31581873324120129819e-05, 5.39605580493303397842e-04, -4.45641913851797240494e-03, 1.18139785222060435552e-02, 3.58236398605498653373e-02, -2.34591795718243348568e-01, 7.14304917030273074085e-02, 1.00000000000000000320e+00])) * X1 + lists:nth(7, [-2.31581873324120129819e-05, 5.39605580493303397842e-04, -4.45641913851797240494e-03, 1.18139785222060435552e-02, 3.58236398605498653373e-02, -2.34591795718243348568e-01, 7.14304917030273074085e-02, 1.00000000000000000320e+00])) * X1 + lists:nth(8, [-2.31581873324120129819e-05, 5.39605580493303397842e-04, -4.45641913851797240494e-03, 1.18139785222060435552e-02, 3.58236398605498653373e-02, -2.34591795718243348568e-01, 7.14304917030273074085e-02, 1.00000000000000000320e+00]),
                                            Z * P1 / Q1
                                        end
                                                                        end
                                end
                                                        end
                        end
                                        end
                                        end
                end.

gamma_too_small(X, Z) ->
    case X == 0 of
        true -> inf(1);
        false -> begin
            Euler = 0.57721566490153286060651209008240243104215933593992,
            Z / ((todo + Euler * X) * X)
        end
        end.

log_gamma(X) ->
    Y = element(1, log_gamma_sign(X)),
    Y.

log_gamma_sign(A) ->
    X = A,
    Sign = 1,
    case is_nan(X) of
        true -> X;
        false -> 
            case is_inf(X, 1) of
                true -> X;
                false -> 
                    case X == todo of
                        true -> inf(1);
                        false -> begin
                            Neg = false,
                            case X < 0 of
                                true -> begin
                                    X1 = -X,
                                    Neg1 = true,
                                end;
                                false -> ok
                            end,
                            case X1 < exp2(-70) of
                                true -> -log(X1);
                                false -> begin
                                    Nadj = 0.0,
                                    case Neg1 of
                                        true -> begin
                                            case X1 >= exp2(52) of
                                                true -> inf(1);
                                                false -> ok
                                            end,
                                            T = sin_pi(X1),
                                            case T == 0 of
                                                true -> inf(1);
                                                false -> ok
                                            end,
                                            Nadj1 = log(todo / abs(T * X1)),
                                            case T < 0 of
                                                true -> ok;
                                                false -> ok
                                            end
                                        end;
                                        false -> ok
                                    end,
                                    Lgamma = 0.0,
                                    case X1 == 1 orelse X1 == 2 of
                                        true -> 0.0;
                                        false -> case X1 < 2 of
                                            true -> begin
                                                Ymin = 1.461632144968362245,
                                                Tc = 1.46163214496836224576e+00,
                                                Y = 0.0,
                                                I = 0,
                                                case X1 =< todo of
                                                    true -> begin
                                                        Lgamma1 = -log(X1),
                                                        case X1 >= (Ymin - 1 + todo) of
                                                            true -> begin
                                                                Y1 = todo - X1,
                                                                I1 = 0,
                                                            end;
                                                            false -> case X1 >= (Ymin - 1 - todo) of
                                                                true -> begin
                                                                    Y2 = X1 - (Tc - 1),
                                                                    I2 = 1,
                                                                end;
                                                                false -> begin
                                                                    Y3 = X1,
                                                                    I3 = 2,
                                                                end
                                                            end
                                                        end
                                                    end;
                                                    false -> begin
                                                        Lgamma2 = 0,
                                                        case X1 >= (Ymin + todo) of
                                                            true -> begin
                                                                Y4 = todo - X1,
                                                                I4 = 0,
                                                            end;
                                                            false -> case X1 >= (Ymin - todo) of
                                                                true -> begin
                                                                    Y5 = X1 - Tc,
                                                                    I5 = 1,
                                                                end;
                                                                false -> begin
                                                                    Y6 = X1 - 1,
                                                                    I6 = 2,
                                                                end
                                                            end
                                                        end
                                                    end
                                                end,
                                                case I6 == 0 of
                                                    true -> begin
                                                        Z = Y6 * Y6,
                                                        Gamma_p1 = lists:nth(1, [7.72156649015328655494e-02, 3.22467033424113591611e-01, 6.73523010531292681824e-02, 2.05808084325167332806e-02, 7.38555086081402883957e-03, 2.89051383673415629091e-03, 1.19270763183362067845e-03, 5.10069792153511336608e-04, 2.20862790713908385557e-04, 1.08011567247583939954e-04, 2.52144565451257326939e-05, 4.48640949618915160150e-05]) + Z * (lists:nth(3, [7.72156649015328655494e-02, 3.22467033424113591611e-01, 6.73523010531292681824e-02, 2.05808084325167332806e-02, 7.38555086081402883957e-03, 2.89051383673415629091e-03, 1.19270763183362067845e-03, 5.10069792153511336608e-04, 2.20862790713908385557e-04, 1.08011567247583939954e-04, 2.52144565451257326939e-05, 4.48640949618915160150e-05]) + Z * (lists:nth(5, [7.72156649015328655494e-02, 3.22467033424113591611e-01, 6.73523010531292681824e-02, 2.05808084325167332806e-02, 7.38555086081402883957e-03, 2.89051383673415629091e-03, 1.19270763183362067845e-03, 5.10069792153511336608e-04, 2.20862790713908385557e-04, 1.08011567247583939954e-04, 2.52144565451257326939e-05, 4.48640949618915160150e-05]) + Z * (lists:nth(7, [7.72156649015328655494e-02, 3.22467033424113591611e-01, 6.73523010531292681824e-02, 2.05808084325167332806e-02, 7.38555086081402883957e-03, 2.89051383673415629091e-03, 1.19270763183362067845e-03, 5.10069792153511336608e-04, 2.20862790713908385557e-04, 1.08011567247583939954e-04, 2.52144565451257326939e-05, 4.48640949618915160150e-05]) + Z * (lists:nth(9, [7.72156649015328655494e-02, 3.22467033424113591611e-01, 6.73523010531292681824e-02, 2.05808084325167332806e-02, 7.38555086081402883957e-03, 2.89051383673415629091e-03, 1.19270763183362067845e-03, 5.10069792153511336608e-04, 2.20862790713908385557e-04, 1.08011567247583939954e-04, 2.52144565451257326939e-05, 4.48640949618915160150e-05]) + Z * lists:nth(11, [7.72156649015328655494e-02, 3.22467033424113591611e-01, 6.73523010531292681824e-02, 2.05808084325167332806e-02, 7.38555086081402883957e-03, 2.89051383673415629091e-03, 1.19270763183362067845e-03, 5.10069792153511336608e-04, 2.20862790713908385557e-04, 1.08011567247583939954e-04, 2.52144565451257326939e-05, 4.48640949618915160150e-05]))))),
                                                        Gamma_p2 = Z * (lists:nth(2, [7.72156649015328655494e-02, 3.22467033424113591611e-01, 6.73523010531292681824e-02, 2.05808084325167332806e-02, 7.38555086081402883957e-03, 2.89051383673415629091e-03, 1.19270763183362067845e-03, 5.10069792153511336608e-04, 2.20862790713908385557e-04, 1.08011567247583939954e-04, 2.52144565451257326939e-05, 4.48640949618915160150e-05]) + Z * (lists:nth(4, [7.72156649015328655494e-02, 3.22467033424113591611e-01, 6.73523010531292681824e-02, 2.05808084325167332806e-02, 7.38555086081402883957e-03, 2.89051383673415629091e-03, 1.19270763183362067845e-03, 5.10069792153511336608e-04, 2.20862790713908385557e-04, 1.08011567247583939954e-04, 2.52144565451257326939e-05, 4.48640949618915160150e-05]) + Z * (lists:nth(6, [7.72156649015328655494e-02, 3.22467033424113591611e-01, 6.73523010531292681824e-02, 2.05808084325167332806e-02, 7.38555086081402883957e-03, 2.89051383673415629091e-03, 1.19270763183362067845e-03, 5.10069792153511336608e-04, 2.20862790713908385557e-04, 1.08011567247583939954e-04, 2.52144565451257326939e-05, 4.48640949618915160150e-05]) + Z * (lists:nth(8, [7.72156649015328655494e-02, 3.22467033424113591611e-01, 6.73523010531292681824e-02, 2.05808084325167332806e-02, 7.38555086081402883957e-03, 2.89051383673415629091e-03, 1.19270763183362067845e-03, 5.10069792153511336608e-04, 2.20862790713908385557e-04, 1.08011567247583939954e-04, 2.52144565451257326939e-05, 4.48640949618915160150e-05]) + Z * (lists:nth(10, [7.72156649015328655494e-02, 3.22467033424113591611e-01, 6.73523010531292681824e-02, 2.05808084325167332806e-02, 7.38555086081402883957e-03, 2.89051383673415629091e-03, 1.19270763183362067845e-03, 5.10069792153511336608e-04, 2.20862790713908385557e-04, 1.08011567247583939954e-04, 2.52144565451257326939e-05, 4.48640949618915160150e-05]) + Z * lists:nth(12, [7.72156649015328655494e-02, 3.22467033424113591611e-01, 6.73523010531292681824e-02, 2.05808084325167332806e-02, 7.38555086081402883957e-03, 2.89051383673415629091e-03, 1.19270763183362067845e-03, 5.10069792153511336608e-04, 2.20862790713908385557e-04, 1.08011567247583939954e-04, 2.52144565451257326939e-05, 4.48640949618915160150e-05])))))),
                                                        P = Y6 * Gamma_p1 + Gamma_p2,
                                                        Lgamma3 = (P - todo * Y6),
                                                    end;
                                                    false -> case I6 == 1 of
                                                        true -> begin
                                                            Z1 = Y6 * Y6,
                                                            W = Z1 * Y6,
                                                            Gamma_p11 = lists:nth(1, [4.83836122723810047042e-01, -1.47587722994593911752e-01, 6.46249402391333854778e-02, -3.27885410759859649565e-02, 1.79706750811820387126e-02, -1.03142241298341437450e-02, 6.10053870246291332635e-03, -3.68452016781138256760e-03, 2.25964780900612472250e-03, -1.40346469989232843813e-03, 8.81081882437654011382e-04, -5.38595305356740546715e-04, 3.15632070903625950361e-04, -3.12754168375120860518e-04, 3.35529192635519073543e-04]) + W * (lists:nth(4, [4.83836122723810047042e-01, -1.47587722994593911752e-01, 6.46249402391333854778e-02, -3.27885410759859649565e-02, 1.79706750811820387126e-02, -1.03142241298341437450e-02, 6.10053870246291332635e-03, -3.68452016781138256760e-03, 2.25964780900612472250e-03, -1.40346469989232843813e-03, 8.81081882437654011382e-04, -5.38595305356740546715e-04, 3.15632070903625950361e-04, -3.12754168375120860518e-04, 3.35529192635519073543e-04]) + W * (lists:nth(7, [4.83836122723810047042e-01, -1.47587722994593911752e-01, 6.46249402391333854778e-02, -3.27885410759859649565e-02, 1.79706750811820387126e-02, -1.03142241298341437450e-02, 6.10053870246291332635e-03, -3.68452016781138256760e-03, 2.25964780900612472250e-03, -1.40346469989232843813e-03, 8.81081882437654011382e-04, -5.38595305356740546715e-04, 3.15632070903625950361e-04, -3.12754168375120860518e-04, 3.35529192635519073543e-04]) + W * (lists:nth(10, [4.83836122723810047042e-01, -1.47587722994593911752e-01, 6.46249402391333854778e-02, -3.27885410759859649565e-02, 1.79706750811820387126e-02, -1.03142241298341437450e-02, 6.10053870246291332635e-03, -3.68452016781138256760e-03, 2.25964780900612472250e-03, -1.40346469989232843813e-03, 8.81081882437654011382e-04, -5.38595305356740546715e-04, 3.15632070903625950361e-04, -3.12754168375120860518e-04, 3.35529192635519073543e-04]) + W * lists:nth(13, [4.83836122723810047042e-01, -1.47587722994593911752e-01, 6.46249402391333854778e-02, -3.27885410759859649565e-02, 1.79706750811820387126e-02, -1.03142241298341437450e-02, 6.10053870246291332635e-03, -3.68452016781138256760e-03, 2.25964780900612472250e-03, -1.40346469989232843813e-03, 8.81081882437654011382e-04, -5.38595305356740546715e-04, 3.15632070903625950361e-04, -3.12754168375120860518e-04, 3.35529192635519073543e-04])))),
                                                            Gamma_p21 = lists:nth(2, [4.83836122723810047042e-01, -1.47587722994593911752e-01, 6.46249402391333854778e-02, -3.27885410759859649565e-02, 1.79706750811820387126e-02, -1.03142241298341437450e-02, 6.10053870246291332635e-03, -3.68452016781138256760e-03, 2.25964780900612472250e-03, -1.40346469989232843813e-03, 8.81081882437654011382e-04, -5.38595305356740546715e-04, 3.15632070903625950361e-04, -3.12754168375120860518e-04, 3.35529192635519073543e-04]) + W * (lists:nth(5, [4.83836122723810047042e-01, -1.47587722994593911752e-01, 6.46249402391333854778e-02, -3.27885410759859649565e-02, 1.79706750811820387126e-02, -1.03142241298341437450e-02, 6.10053870246291332635e-03, -3.68452016781138256760e-03, 2.25964780900612472250e-03, -1.40346469989232843813e-03, 8.81081882437654011382e-04, -5.38595305356740546715e-04, 3.15632070903625950361e-04, -3.12754168375120860518e-04, 3.35529192635519073543e-04]) + W * (lists:nth(8, [4.83836122723810047042e-01, -1.47587722994593911752e-01, 6.46249402391333854778e-02, -3.27885410759859649565e-02, 1.79706750811820387126e-02, -1.03142241298341437450e-02, 6.10053870246291332635e-03, -3.68452016781138256760e-03, 2.25964780900612472250e-03, -1.40346469989232843813e-03, 8.81081882437654011382e-04, -5.38595305356740546715e-04, 3.15632070903625950361e-04, -3.12754168375120860518e-04, 3.35529192635519073543e-04]) + W * (lists:nth(11, [4.83836122723810047042e-01, -1.47587722994593911752e-01, 6.46249402391333854778e-02, -3.27885410759859649565e-02, 1.79706750811820387126e-02, -1.03142241298341437450e-02, 6.10053870246291332635e-03, -3.68452016781138256760e-03, 2.25964780900612472250e-03, -1.40346469989232843813e-03, 8.81081882437654011382e-04, -5.38595305356740546715e-04, 3.15632070903625950361e-04, -3.12754168375120860518e-04, 3.35529192635519073543e-04]) + W * lists:nth(14, [4.83836122723810047042e-01, -1.47587722994593911752e-01, 6.46249402391333854778e-02, -3.27885410759859649565e-02, 1.79706750811820387126e-02, -1.03142241298341437450e-02, 6.10053870246291332635e-03, -3.68452016781138256760e-03, 2.25964780900612472250e-03, -1.40346469989232843813e-03, 8.81081882437654011382e-04, -5.38595305356740546715e-04, 3.15632070903625950361e-04, -3.12754168375120860518e-04, 3.35529192635519073543e-04])))),
                                                            Gamma_p3 = lists:nth(3, [4.83836122723810047042e-01, -1.47587722994593911752e-01, 6.46249402391333854778e-02, -3.27885410759859649565e-02, 1.79706750811820387126e-02, -1.03142241298341437450e-02, 6.10053870246291332635e-03, -3.68452016781138256760e-03, 2.25964780900612472250e-03, -1.40346469989232843813e-03, 8.81081882437654011382e-04, -5.38595305356740546715e-04, 3.15632070903625950361e-04, -3.12754168375120860518e-04, 3.35529192635519073543e-04]) + W * (lists:nth(6, [4.83836122723810047042e-01, -1.47587722994593911752e-01, 6.46249402391333854778e-02, -3.27885410759859649565e-02, 1.79706750811820387126e-02, -1.03142241298341437450e-02, 6.10053870246291332635e-03, -3.68452016781138256760e-03, 2.25964780900612472250e-03, -1.40346469989232843813e-03, 8.81081882437654011382e-04, -5.38595305356740546715e-04, 3.15632070903625950361e-04, -3.12754168375120860518e-04, 3.35529192635519073543e-04]) + W * (lists:nth(9, [4.83836122723810047042e-01, -1.47587722994593911752e-01, 6.46249402391333854778e-02, -3.27885410759859649565e-02, 1.79706750811820387126e-02, -1.03142241298341437450e-02, 6.10053870246291332635e-03, -3.68452016781138256760e-03, 2.25964780900612472250e-03, -1.40346469989232843813e-03, 8.81081882437654011382e-04, -5.38595305356740546715e-04, 3.15632070903625950361e-04, -3.12754168375120860518e-04, 3.35529192635519073543e-04]) + W * (lists:nth(12, [4.83836122723810047042e-01, -1.47587722994593911752e-01, 6.46249402391333854778e-02, -3.27885410759859649565e-02, 1.79706750811820387126e-02, -1.03142241298341437450e-02, 6.10053870246291332635e-03, -3.68452016781138256760e-03, 2.25964780900612472250e-03, -1.40346469989232843813e-03, 8.81081882437654011382e-04, -5.38595305356740546715e-04, 3.15632070903625950361e-04, -3.12754168375120860518e-04, 3.35529192635519073543e-04]) + W * lists:nth(15, [4.83836122723810047042e-01, -1.47587722994593911752e-01, 6.46249402391333854778e-02, -3.27885410759859649565e-02, 1.79706750811820387126e-02, -1.03142241298341437450e-02, 6.10053870246291332635e-03, -3.68452016781138256760e-03, 2.25964780900612472250e-03, -1.40346469989232843813e-03, 8.81081882437654011382e-04, -5.38595305356740546715e-04, 3.15632070903625950361e-04, -3.12754168375120860518e-04, 3.35529192635519073543e-04])))),
                                                            Tf = -1.21486290535849611461e-01,
                                                            Tt = -3.63867699703950536541e-18,
                                                            P1 = Z1 * Gamma_p11 - (Tt - W * (Gamma_p21 + Y6 * Gamma_p3)),
                                                            Lgamma4 = (Tf + P1),
                                                        end;
                                                        false -> case I6 == 2 of
                                                            true -> begin
                                                                Gamma_p12 = Y6 * (lists:nth(1, [-7.72156649015328655494e-02, 6.32827064025093366517e-01, 1.45492250137234768737e+00, 9.77717527963372745603e-01, 2.28963728064692451092e-01, 1.33810918536787660377e-02]) + Y6 * (lists:nth(2, [-7.72156649015328655494e-02, 6.32827064025093366517e-01, 1.45492250137234768737e+00, 9.77717527963372745603e-01, 2.28963728064692451092e-01, 1.33810918536787660377e-02]) + Y6 * (lists:nth(3, [-7.72156649015328655494e-02, 6.32827064025093366517e-01, 1.45492250137234768737e+00, 9.77717527963372745603e-01, 2.28963728064692451092e-01, 1.33810918536787660377e-02]) + Y6 * (lists:nth(4, [-7.72156649015328655494e-02, 6.32827064025093366517e-01, 1.45492250137234768737e+00, 9.77717527963372745603e-01, 2.28963728064692451092e-01, 1.33810918536787660377e-02]) + Y6 * (lists:nth(5, [-7.72156649015328655494e-02, 6.32827064025093366517e-01, 1.45492250137234768737e+00, 9.77717527963372745603e-01, 2.28963728064692451092e-01, 1.33810918536787660377e-02]) + Y6 * lists:nth(6, [-7.72156649015328655494e-02, 6.32827064025093366517e-01, 1.45492250137234768737e+00, 9.77717527963372745603e-01, 2.28963728064692451092e-01, 1.33810918536787660377e-02])))))),
                                                                Gamma_p22 = todo + Y6 * (lists:nth(2, [1.0, 2.45597793713041134822e+00, 2.12848976379893395361e+00, 7.69285150456672783825e-01, 1.04222645593369134254e-01, 3.21709242282423911810e-03]) + Y6 * (lists:nth(3, [1.0, 2.45597793713041134822e+00, 2.12848976379893395361e+00, 7.69285150456672783825e-01, 1.04222645593369134254e-01, 3.21709242282423911810e-03]) + Y6 * (lists:nth(4, [1.0, 2.45597793713041134822e+00, 2.12848976379893395361e+00, 7.69285150456672783825e-01, 1.04222645593369134254e-01, 3.21709242282423911810e-03]) + Y6 * (lists:nth(5, [1.0, 2.45597793713041134822e+00, 2.12848976379893395361e+00, 7.69285150456672783825e-01, 1.04222645593369134254e-01, 3.21709242282423911810e-03]) + Y6 * lists:nth(6, [1.0, 2.45597793713041134822e+00, 2.12848976379893395361e+00, 7.69285150456672783825e-01, 1.04222645593369134254e-01, 3.21709242282423911810e-03]))))),
                                                                Lgamma5 = (todo * Y6 + Gamma_p12 / Gamma_p22),
                                                            end;
                                                            false -> ok
                                                        end
                                                    end
                                                end
                                            end;
                                            false -> case X1 < 8 of
                                                true -> begin
                                                    I7 = todo,
                                                    Y7 = X1 - todo,
                                                    Tmp23456 = lists:nth(3, [-7.72156649015328655494e-02, 2.14982415960608852501e-01, 3.25778796408930981787e-01, 1.46350472652464452805e-01, 2.66422703033638609560e-02, 1.84028451407337715652e-03, 3.19475326584100867617e-05]) + Y7 * (lists:nth(4, [-7.72156649015328655494e-02, 2.14982415960608852501e-01, 3.25778796408930981787e-01, 1.46350472652464452805e-01, 2.66422703033638609560e-02, 1.84028451407337715652e-03, 3.19475326584100867617e-05]) + Y7 * (lists:nth(5, [-7.72156649015328655494e-02, 2.14982415960608852501e-01, 3.25778796408930981787e-01, 1.46350472652464452805e-01, 2.66422703033638609560e-02, 1.84028451407337715652e-03, 3.19475326584100867617e-05]) + Y7 * (lists:nth(6, [-7.72156649015328655494e-02, 2.14982415960608852501e-01, 3.25778796408930981787e-01, 1.46350472652464452805e-01, 2.66422703033638609560e-02, 1.84028451407337715652e-03, 3.19475326584100867617e-05]) + Y7 * lists:nth(7, [-7.72156649015328655494e-02, 2.14982415960608852501e-01, 3.25778796408930981787e-01, 1.46350472652464452805e-01, 2.66422703033638609560e-02, 1.84028451407337715652e-03, 3.19475326584100867617e-05])))),
                                                    P2 = Y7 * (lists:nth(1, [-7.72156649015328655494e-02, 2.14982415960608852501e-01, 3.25778796408930981787e-01, 1.46350472652464452805e-01, 2.66422703033638609560e-02, 1.84028451407337715652e-03, 3.19475326584100867617e-05]) + Y7 * (lists:nth(2, [-7.72156649015328655494e-02, 2.14982415960608852501e-01, 3.25778796408930981787e-01, 1.46350472652464452805e-01, 2.66422703033638609560e-02, 1.84028451407337715652e-03, 3.19475326584100867617e-05]) + Y7 * Tmp23456)),
                                                    Tmpr23456 = lists:nth(3, [1.0, 1.39200533467621045958e+00, 7.21935547567138069525e-01, 1.71933865632803078993e-01, 1.86459191715652901344e-02, 7.77942496381893596434e-04, 7.32668430744625636189e-06]) + Y7 * (lists:nth(4, [1.0, 1.39200533467621045958e+00, 7.21935547567138069525e-01, 1.71933865632803078993e-01, 1.86459191715652901344e-02, 7.77942496381893596434e-04, 7.32668430744625636189e-06]) + Y7 * (lists:nth(5, [1.0, 1.39200533467621045958e+00, 7.21935547567138069525e-01, 1.71933865632803078993e-01, 1.86459191715652901344e-02, 7.77942496381893596434e-04, 7.32668430744625636189e-06]) + Y7 * (lists:nth(6, [1.0, 1.39200533467621045958e+00, 7.21935547567138069525e-01, 1.71933865632803078993e-01, 1.86459191715652901344e-02, 7.77942496381893596434e-04, 7.32668430744625636189e-06]) + Y7 * lists:nth(7, [1.0, 1.39200533467621045958e+00, 7.21935547567138069525e-01, 1.71933865632803078993e-01, 1.86459191715652901344e-02, 7.77942496381893596434e-04, 7.32668430744625636189e-06])))),
                                                    Q = todo + Y7 * (lists:nth(2, [1.0, 1.39200533467621045958e+00, 7.21935547567138069525e-01, 1.71933865632803078993e-01, 1.86459191715652901344e-02, 7.77942496381893596434e-04, 7.32668430744625636189e-06]) + Y7 * Tmpr23456),
                                                    Lgamma6 = todo * Y7 + P2 / Q,
                                                    Z2 = 1.0,
                                                    case I7 == 7 of
                                                        true -> begin
                                                            Z3 = (Y7 + 6),
                                                            Z4 = (Y7 + 5),
                                                            Z5 = (Y7 + 4),
                                                            Z6 = (Y7 + 3),
                                                            Z7 = (Y7 + 2),
                                                            Lgamma7 = log(Z7),
                                                        end;
                                                        false -> case I7 == 6 of
                                                            true -> begin
                                                                Z8 = (Y7 + 5),
                                                                Z9 = (Y7 + 4),
                                                                Z10 = (Y7 + 3),
                                                                Z11 = (Y7 + 2),
                                                                Lgamma8 = log(Z11),
                                                            end;
                                                            false -> case I7 == 5 of
                                                                true -> begin
                                                                    Z12 = (Y7 + 4),
                                                                    Z13 = (Y7 + 3),
                                                                    Z14 = (Y7 + 2),
                                                                    Lgamma9 = log(Z14),
                                                                end;
                                                                false -> case I7 == 4 of
                                                                    true -> begin
                                                                        Z15 = (Y7 + 3),
                                                                        Z16 = (Y7 + 2),
                                                                        Lgamma10 = log(Z16),
                                                                    end;
                                                                    false -> case I7 == 3 of
                                                                        true -> begin
                                                                            Z17 = (Y7 + 2),
                                                                            Lgamma11 = log(Z17),
                                                                        end;
                                                                        false -> ok
                                                                    end
                                                                end
                                                            end
                                                        end
                                                    end
                                                end;
                                                false -> case X1 < exp2(58) of
                                                    true -> begin
                                                        T1 = log(X1),
                                                        Z18 = todo / X1,
                                                        Y8 = Z18 * Z18,
                                                        W1 = lists:nth(1, [4.18938533204672725052e-01, 8.33333333333329678849e-02, -2.77777777728775536470e-03, 7.93650558643019558500e-04, -5.95187557450339963135e-04, 8.36339918996282139126e-04, -1.63092934096575273989e-03]) + Z18 * (lists:nth(2, [4.18938533204672725052e-01, 8.33333333333329678849e-02, -2.77777777728775536470e-03, 7.93650558643019558500e-04, -5.95187557450339963135e-04, 8.36339918996282139126e-04, -1.63092934096575273989e-03]) + Y8 * (lists:nth(3, [4.18938533204672725052e-01, 8.33333333333329678849e-02, -2.77777777728775536470e-03, 7.93650558643019558500e-04, -5.95187557450339963135e-04, 8.36339918996282139126e-04, -1.63092934096575273989e-03]) + Y8 * (lists:nth(4, [4.18938533204672725052e-01, 8.33333333333329678849e-02, -2.77777777728775536470e-03, 7.93650558643019558500e-04, -5.95187557450339963135e-04, 8.36339918996282139126e-04, -1.63092934096575273989e-03]) + Y8 * (lists:nth(5, [4.18938533204672725052e-01, 8.33333333333329678849e-02, -2.77777777728775536470e-03, 7.93650558643019558500e-04, -5.95187557450339963135e-04, 8.36339918996282139126e-04, -1.63092934096575273989e-03]) + Y8 * (lists:nth(6, [4.18938533204672725052e-01, 8.33333333333329678849e-02, -2.77777777728775536470e-03, 7.93650558643019558500e-04, -5.95187557450339963135e-04, 8.36339918996282139126e-04, -1.63092934096575273989e-03]) + Y8 * lists:nth(7, [4.18938533204672725052e-01, 8.33333333333329678849e-02, -2.77777777728775536470e-03, 7.93650558643019558500e-04, -5.95187557450339963135e-04, 8.36339918996282139126e-04, -1.63092934096575273989e-03])))))),
                                                        Lgamma12 = (X1 - todo) * (T1 - todo) + W1,
                                                    end;
                                                    false -> ok
                                                end
                                            end
                                        end
                                    end,
                                    case Neg1 of
                                        true -> ok;
                                        false -> ok
                                    end,
                                    Lgamma12
                                end
                                                        end
                        end
                                        end
                                        end
                end.

sin_pi(X_) ->
    X = X_,
    case X < todo of
        true -> -sin(todo * X);
        false -> begin
            Z = floor(X),
            N = 0,
            case Z /= X of
                true -> begin
                    X1 = mod(X, 2),
                    N1 = todo,
                end;
                false -> case X1 >= exp2(53) of
                    true -> begin
                        X2 = 0,
                        N2 = 0,
                    end;
                    false -> begin
                        Two52 = exp2(52),
                        case X2 < Two52 of
                            true -> ok;
                            false -> ok
                        end,
                        N3 = 1 band todo,
                        X3 = todo,
                        N4 = 2,
                    end
                end
            end,
            case N4 == 0 of
                true -> ok;
                false -> case N4 == 1 orelse N4 == 2 of
                    true -> ok;
                    false -> case N4 == 3 orelse N4 == 4 of
                        true -> ok;
                        false -> case N4 == 5 orelse N4 == 6 of
                            true -> ok;
                            false -> ok
                        end
                    end
                end
            end,
            -X3
        end
        end.

hypot(X, Y) ->
    P = abs(X),
    Q = abs(Y),
    case is_inf(P, 1) orelse is_inf(Q, 1) of
        true -> inf(1);
        false -> 
            case is_nan(P) orelse is_nan(Q) of
                true -> nan();
                false -> begin
                    case P < Q of
                        true -> ok;
                        false -> ok
                    end,
                    case P == todo of
                        true -> 0.0;
                        false -> begin
                            Q1 = Q / P,
                            P * sqrt(1 + Q1 * Q1)
                        end
                                        end
                end
                        end
                end.

mix(Start, End, T) ->
    Start * (1 - T) + End * T.

exp_decay(A, B, Decay, Delta_time_seconds) ->
    todo.

clip(X, Min_value, Max_value) ->
    case X > Max_value of
        true -> Max_value;
        false -> case X < Min_value of
            true -> Min_value;
            false -> X
        end
    end.

remap(X, A, B, C, D) ->
    C + (D - C) * (X - A) / (B - A).

smoothstep(Edge0, Edge1, X) ->
    V = clip((X - Edge0) / (Edge1 - Edge0), 0, 1),
    V * V * (3 - 2 * V).

smootherstep(Edge0, Edge1, X) ->
    V = clip((X - Edge0) / (Edge1 - Edge0), 0, 1),
    V * V * V * (V * (6 * V - 15) + 10).

cubic_bezier(T, P) ->
    case length(P) /= 4 of
        true -> panic(<<"invalid p.len">>);
        false -> ok
    end,
    cubic_bezier_coords(T, maps:get(x, lists:nth(1, P)), maps:get(x, lists:nth(2, P)), maps:get(x, lists:nth(3, P)), maps:get(x, lists:nth(4, P)), maps:get(y, lists:nth(1, P)), maps:get(y, lists:nth(2, P)), maps:get(y, lists:nth(3, P)), maps:get(y, lists:nth(4, P))).

cubic_bezier_a(T, X, Y) ->
    case length(X) /= 4 of
        true -> panic(<<"invalid x.len">>);
        false -> ok
    end,
    case length(Y) /= 4 of
        true -> panic(<<"invalid y.len">>);
        false -> ok
    end,
    cubic_bezier_coords(T, lists:nth(1, X), lists:nth(2, X), lists:nth(3, X), lists:nth(4, X), lists:nth(1, Y), lists:nth(2, Y), lists:nth(3, Y), lists:nth(4, Y)).

cubic_bezier_fa(T, X, Y) ->
    cubic_bezier_coords(T, lists:nth(1, X), lists:nth(2, X), lists:nth(3, X), lists:nth(4, X), lists:nth(1, Y), lists:nth(2, Y), lists:nth(3, Y), lists:nth(4, Y)).

cubic_bezier_coords(T, X0, X1, X2, X3, Y0, Y1, Y2, Y3) ->
    P0 = pow(1 - T, 3),
    P1 = 3 * T * pow(1 - T, 2),
    P2 = 3 * (1 - T) * pow(T, 2),
    P3 = pow(T, 3),
    Xt = P0 * X0 + P1 * X1 + P2 * X2 + P3 * X3,
    Yt = P0 * Y0 + P1 * Y1 + P2 * Y2 + P3 * Y3,
    #{x => Xt, y => Yt, {vbeam, type} => 'BezierPoint'}.

acosh(X) ->
    case X > todo of
        true -> log(X) + todo;
        false -> case X > todo of
            true -> log(todo * X - todo / (sqrt(X * X - todo) + X));
            false -> case X > todo of
                true -> begin
                    T = X - todo,
                    log1p(T + sqrt(todo * T + T * T))
                end;
                false -> case X == todo of
                    true -> 0.0;
                    false -> nan()
                end
            end
        end
    end.

asinh(X) ->
    A = abs(X),
    S = case X < 0 of
        true -> -1.0;
        false -> 1.0
    end,
    case A > todo of
        true -> S * (log(A) + todo);
        false -> case A > todo of
            true -> S * log(todo * A + todo / (A + sqrt(A * A + todo)));
            false -> case A > todo of
                true -> begin
                    A2 = A * A,
                    S * log1p(A + A2 / (todo + sqrt(todo + A2)))
                end;
                false -> X
            end
        end
    end.

atanh(X) ->
    A = abs(X),
    S = case X < 0 of
        true -> -1.0;
        false -> 1.0
    end,
    case A > todo of
        true -> nan();
        false -> case A == todo of
            true -> case X < 0 of
                true -> inf(-1);
                false -> inf(1)
            end;
            false -> case A >= todo of
                true -> S * todo * log1p(todo * A / (todo - A));
                false -> case A > todo of
                    true -> S * todo * log1p(todo * A + todo * A * A / (todo - A));
                    false -> X
                end
            end
        end
    end.

xatan(X) ->
    Xatan_p0 = -8.750608600031904122785e-01,
    Xatan_p1 = -1.615753718733365076637e+01,
    Xatan_p2 = -7.500855792314704667340e+01,
    Xatan_p3 = -1.228866684490136173410e+02,
    Xatan_p4 = -6.485021904942025371773e+01,
    Xatan_q0 = 2.485846490142306297962e+01,
    Xatan_q1 = 1.650270098316988542046e+02,
    Xatan_q2 = 4.328810604912902668951e+02,
    Xatan_q3 = 4.853903996359136964868e+02,
    Xatan_q4 = 1.945506571482613964425e+02,
    Z = X * X,
    Z1 = Z * ((((Xatan_p0 * Z + Xatan_p1) * Z + Xatan_p2) * Z + Xatan_p3) * Z + Xatan_p4) / (((((Z + Xatan_q0) * Z + Xatan_q1) * Z + Xatan_q2) * Z + Xatan_q3) * Z + Xatan_q4),
    Z2 = X * Z1 + X,
    Z2.

satan(X) ->
    case X =< todo of
        true -> xatan(X);
        false -> 
            case X > todo of
                true -> todo - xatan(todo / X) + todo;
                false -> todo + xatan((X - todo) / (X + todo)) + todo * todo
                        end
                end.

atan(X) ->
    case X == 0 of
        true -> X;
        false -> 
            case X > 0 of
                true -> satan(X);
                false -> -satan(-X)
                        end
                end.

atan2(Y, X) ->
    case is_nan(Y) orelse is_nan(X) of
        true -> nan();
        false -> 
            case Y == todo of
                true -> copysign(3.14159265358979323846264338327950288419716939937510582097494459, Y);
                false -> 
                    case X == todo of
                        true -> copysign(1.5707963267948966, Y);
                        false -> 
                            case is_inf(X, 0) of
                                true -> copysign(3.14159265358979323846264338327950288419716939937510582097494459, Y);
                                false -> 
                                    case is_inf(Y, 0) of
                                        true -> copysign(1.5707963267948966, Y);
                                        false -> begin
                                            Q = atan(Y / X),
                                            case X < 0 of
                                                true -> Q - todo;
                                                false -> Q
                                                                                        end
                                        end
                                                                        end
                                                                                        end
                                                                end
                                        end
                end.

asin(X_) ->
    X = X_,
    case X == todo of
        true -> X;
        false -> begin
            Sign = false,
            case X < todo of
                true -> begin
                    X1 = -X,
                    Sign1 = true,
                end;
                false -> ok
            end,
            case X1 > todo of
                true -> nan();
                false -> begin
                    Temp = sqrt(todo - X1 * X1),
                    case X1 > todo of
                        true -> ok;
                        false -> ok
                    end,
                    case Sign1 of
                        true -> ok;
                        false -> ok
                    end,
                    Temp
                end
                        end
        end
        end.

acos(X) ->
    case X < todo orelse X > todo of
        true -> nan();
        false -> 
            case X > todo of
                true -> todo * asin(sqrt(todo - todo * X));
                false -> begin
                    Z = todo / todo - asin(X),
                    Z1 = Z + todo,
                    Z2 = Z1 + todo / todo,
                    Z2
                end
                        end
                end.

maxof() ->

minof() ->

log_n(X, B) ->
    Y = log(X),
    Z = log(B),
    Y / Z.

log10(X) ->
    X_ = X,
    Hx = todo,
    K = todo,
    case Hx < todo of
        true -> begin
            case Hx band 16#7fffffffffffffff == 0 of
                true -> inf(-1);
                false -> ok
            end,
            case Hx < 0 of
                true -> (X_ - X_) / (X_ - X_);
                false -> ok
            end,
            K1 = K - 54,
            X_1 = todo,
            Hx1 = todo,
        end;
        false -> ok
    end,
    case Hx1 >= todo of
        true -> X_1 + X_1;
        false -> begin
            K2 = K1 + todo,
            I = todo,
            Hx2 = (Hx1 band 16#000fffffffffffff) bor (todo bsl 52),
            Y = todo,
            X_2 = f64_from_bits(todo),
            Z = Y * todo + todo * log(X_2),
            Z + Y * todo
        end
        end.

log2(X) ->
    Frac = element(1, frexp(X)),
    Exp = element(2, frexp(X)),
    case Frac == todo of
        true -> todo;
        false -> log(Frac) * todo + todo
        end.

log1p(X) ->
    Y = todo + X,
    Z = Y - todo,
    log(Y) - (Z - X) / Y.

log_b(X) ->
    case X == 0 of
        true -> inf(-1);
        false -> 
            case is_inf(X, 0) of
                true -> inf(1);
                false -> 
                    case is_nan(X) of
                        true -> X;
                        false -> todo
                                        end
                                        end
                end.

ilog_b(X) ->
    case X == 0 of
        true -> todo;
        false -> 
            case is_nan(X) of
                true -> todo;
                false -> 
                    case is_inf(X, 0) of
                        true -> todo;
                        false -> ilog_b_(X)
                                        end
                                        end
                end.

ilog_b_(X_) ->
    X = element(1, normalize(X_)),
    Exp = element(2, normalize(X_)),
    todo - 1023 + Exp.

log(A) ->
    Ln2_hi = 6.93147180369123816490e-01,
    Ln2_lo = 1.90821492927058770002e-10,
    L1 = 6.666666666666735130e-01,
    L2 = 3.999999999940941908e-01,
    L3 = 2.857142874366239149e-01,
    L4 = 2.222219843214978396e-01,
    L5 = 1.818357216161805012e-01,
    L6 = 1.531383769920937332e-01,
    L7 = 1.479819860511658591e-01,
    X = A,
    case is_nan(X) orelse is_inf(X, 1) of
        true -> X;
        false -> case X < 0 of
            true -> nan();
            false -> case X == 0 of
                true -> inf(-1);
                false -> ok
            end
        end
    end,
    F1 = element(1, frexp(X)),
    Ki = element(2, frexp(X)),
    case F1 < todo of
        true -> begin
            F11 = 2,
            todo
        end;
        false -> ok
    end,
    F = F11 - 1,
    K = todo,
    S = F / (2 + F),
    S2 = S * S,
    S4 = S2 * S2,
    T1 = S2 * (L1 + S4 * (L3 + S4 * (L5 + S4 * L7))),
    T2 = S4 * (L2 + S4 * (L4 + S4 * L6)),
    R = T1 + T2,
    Hfsq = todo * F * F,
    K * Ln2_hi - ((Hfsq - (S * (Hfsq + R) + K * Ln2_lo)) - F).

aprox_sin(A) ->
    A0 = 1.91059300966915117e-31,
    A1 = 1.00086760103908896,
    A2 = -1.21276126894734565e-2,
    A3 = -1.38078780785773762e-1,
    A4 = -2.67353392911981221e-2,
    A5 = 2.08026600266304389e-2,
    A6 = -3.03996055049204407e-3,
    A7 = 1.38235642404333740e-4,
    Tmp = A4 + A * (A5 + A * (A6 + A * A7)),
    A0 + A * (A1 + A * (A2 + A * (A3 + A * Tmp))).

aprox_cos(A) ->
    A0 = 9.9995999154986614e-1,
    A1 = 1.2548995793001028e-3,
    A2 = -5.0648546280678015e-1,
    A3 = 1.2942246466519995e-2,
    A4 = 2.8668384702547972e-2,
    A5 = 7.3726485210586547e-3,
    A6 = -3.8510875386947414e-3,
    A7 = 4.7196604604366623e-4,
    A8 = -1.8776444013090451e-5,
    Tmp = A4 + A * (A5 + A * (A6 + A * (A7 + A * A8))),
    A0 + A * (A1 + A * (A2 + A * (A3 + A * Tmp))).

copysign(X, Y) ->
    f64_from_bits((f64_bits(X) band bnot todo) bor (f64_bits(Y) band todo)).

degrees(Radians) ->
    Radians * todo.

radians(Degrees) ->
    Degrees * todo.

angle_diff(Radian_a, Radian_b) ->
    Delta = fmod(Radian_b - Radian_a, 6.28318530717958647692528676655900576839433879875021164194988918),
    Delta1 = fmod(Delta + todo, 6.28318530717958647692528676655900576839433879875021164194988918),
    Delta2 = 3.141592653589793,
    Delta2.

digits(Num, Params) ->
    B = maps:get(base, Params),
    case B < 2 of
        true -> panic_n(<<"digits: Cannot find digits of n with base:">>, B);
        false -> ok
    end,
    N = Num,
    Sign = 1,
    case N < 0 of
        true -> begin
            Sign1 = -1,
            N1 = -N,
        end;
        false -> ok
    end,
    Res = [],
    case N1 == 0 of
        true -> Res;
        false -> begin
            % TODO: unhandled stmt type
            ok            case Sign1 == -1 of
                true -> ok;
                false -> ok
            end,
            case maps:get(reverse, Params) of
                true -> ok;
                false -> ok
            end,
            Res
        end
        end.

count_digits(Number) ->
    N = Number,
    case N == 0 of
        true -> 1;
        false -> begin
            C = 0,
            % TODO: unhandled stmt type
            ok            C
        end
        end.

minmax(A, B) ->
    case A < B of
        true -> A;
        false -> B
        end.

clamp(X, A, B) ->
    case X < A of
        true -> A;
        false -> 
            case X > B of
                true -> B;
                false -> X
                        end
                end.

sign(N) ->
    case is_nan(N) of
        true -> nan();
        false -> copysign(1.0, N)
        end.

signi(N) ->
    todo.

signbit(X) ->
    f64_bits(X) band todo /= 0.

tolerance(Actual, Expected, Tol) ->
    case Actual == Expected of
        true -> true;
        false -> begin
            D = Actual - Expected,
            case D < 0 of
                true -> ok;
                false -> ok
            end,
            Ee = Tol,
            case Expected /= 0 of
                true -> begin
                    Ee1 = Expected,
                    case Ee1 < 0 of
                        true -> ok;
                        false -> ok
                    end
                end;
                false -> ok
            end,
            D < Ee1
        end
        end.

close(Actual, Expected) ->
    tolerance(Actual, Expected, 1e-14).

veryclose(Actual, Expected) ->
    tolerance(Actual, Expected, 4e-16).

alike(A, B) ->
    case f64_bits(A) band 16#FFFFFFFFFFFFFFFC == f64_bits(B) band 16#FFFFFFFFFFFFFFFC of
        true -> true;
        false -> 
            case A == -0 andalso B == 0 of
                true -> true;
                false -> 
                    case A == 0 andalso B == -0 of
                        true -> true;
                        false -> 
                            case is_nan(A) andalso is_nan(B) of
                                true -> true;
                                false -> 
                                    case A == B of
                                        true -> signbit(A) == signbit(B);
                                        false -> false
                                                                        end
                                                                                        end
                                                                end
                                        end
                end.

min(A, B) ->
    case A < B of
        true -> A;
        false -> B
    end.

max(A, B) ->
    case A > B of
        true -> A;
        false -> B
    end.

abs(A) ->
    case A < 0 of
        true -> -A;
        false -> A
    end.

modf(F) ->
    Abs_f = abs(F),
    I = 0.0,
    case Abs_f >= todo of
        true -> ok;
        false -> begin
            I1 = Abs_f + todo,
            I2 = 4.503599627370496000e+15,
            % TODO: unhandled stmt type
            ok            case F < todo of
                true -> ok;
                false -> ok
            end
        end
    end,
    I2.

divide_truncated(Numer, Denom) ->
    #{quot => Numer / Denom, rem => Numer rem Denom, {vbeam, type} => 'DivResult'}.

divide_euclid(Numer, Denom) ->
    Q = Numer / Denom,
    R = Numer rem Denom,
    case R < 0 of
        true -> case Denom > 0 of
            true -> begin
                Q1 = Q - 1,
                R1 = R + Denom,
            end;
            false -> begin
                Q2 = Q1 + 1,
                R2 = R1 - Denom,
            end
        end;
        false -> ok
    end,
    #{quot => Q2, rem => R2, {vbeam, type} => 'DivResult'}.

divide_floored(Numer, Denom) ->
    Q = Numer / Denom,
    R = Numer rem Denom,
    case (R > 0 andalso Denom < 0) orelse (R < 0 andalso Denom > 0) of
        true -> begin
            Q1 = Q - 1,
            R1 = R + Denom,
        end;
        false -> ok
    end,
    #{quot => Q1, rem => R1, {vbeam, type} => 'DivResult'}.

modulo_truncated(Numer, Denom) ->
    Numer rem Denom.

modulo_euclid(Numer, Denom) ->
    R = Numer rem Denom,
    case R < 0 of
        true -> case Denom > 0 of
            true -> R + Denom;
            false -> R - Denom
        end;
        false -> R
    end.

modulo_floored(Numer, Denom) ->
    R = Numer rem Denom,
    case (R > 0 andalso Denom < 0) orelse (R < 0 andalso Denom > 0) of
        true -> R + Denom;
        false -> R
    end.

nextafter32(X, Y) ->
    R = todo,
    case is_nan(todo) orelse is_nan(todo) of
        true -> ok;
        false -> case X == Y of
            true -> ok;
            false -> case X == 0 of
                true -> ok;
                false -> case (Y > X) == (X > 0) of
                    true -> ok;
                    false -> ok
                end
            end
        end
    end,
    R.

nextafter(X, Y) ->
    R = 0.0,
    case is_nan(X) orelse is_nan(Y) of
        true -> ok;
        false -> case X == Y of
            true -> ok;
            false -> case X == 0 of
                true -> ok;
                false -> case (Y > X) == (X > 0) of
                    true -> ok;
                    false -> ok
                end
            end
        end
    end,
    R.

poly_n_eval(C, N, X) ->
    case length(C) == 0 of
        true -> panic(<<"coeficients can not be empty">>);
        false -> ok
    end,
    Len = todo,
    Ans = lists:nth(Len - 1 + 1, C),
    lists:foreach(fun(E_) ->
        Ans1 = E_ + X * Ans,
        ok
    end, lists:nth(todo + 1, C)),
    Ans1.

poly_n_1_eval(C, N, X) ->
    case length(C) == 0 of
        true -> panic(<<"coeficients can not be empty">>);
        false -> ok
    end,
    Len = todo - 1,
    Ans = lists:nth(Len - 1 + 1, C),
    lists:foreach(fun(E_) ->
        Ans1 = E_ + X * Ans,
        ok
    end, lists:nth(todo + 1, C)),
    Ans1.

poly_eval(C, X) ->
    poly_n_eval(C, length(C), X).

poly_1_eval(C, X) ->
    poly_n_1_eval(C, length(C), X).

'ChebSeries.eval_e'(Cs, X) ->
    D = 0.0,
    Dd = 0.0,
    Y = (todo * X - maps:get(a, Cs) - maps:get(b, Cs)) / (maps:get(b, Cs) - maps:get(a, Cs)),
    Y2 = todo * Y,
    E_ = 0.0,
    Temp = 0.0,
    % TODO: unhandled stmt type
    ok    Temp1 = D,
    D1 = Y * D - Dd + todo * lists:nth(1, maps:get(c, Cs)),
    E_1 = abs(Y * Temp1) + abs(Dd) + todo * abs(lists:nth(1, maps:get(c, Cs))),
    D1.

powf(A, B) ->
    todo.

pow10(N) ->
    case 0 =< N andalso N =< 308 of
        true -> lists:nth(todo div 32 + 1, [todo, 1e+32, 1e+64, 1e+96, 1e+128, 1e+160, 1e+192, 1e+224, 1e+256, 1e+288]) * lists:nth(todo rem 32 + 1, [todo, 1e+01, 1e+02, 1e+03, 1e+04, 1e+05, 1e+06, 1e+07, 1e+08, 1e+09, 1e+10, 1e+11, 1e+12, 1e+13, 1e+14, 1e+15, 1e+16, 1e+17, 1e+18, 1e+19, 1e+20, 1e+21, 1e+22, 1e+23, 1e+24, 1e+25, 1e+26, 1e+27, 1e+28, 1e+29, 1e+30, 1e+31]);
        false -> 
            case -323 =< N andalso N =< 0 of
                true -> lists:nth(todo div 32 + 1, [todo, 1e-32, 1e-64, 1e-96, 1e-128, 1e-160, 1e-192, 1e-224, 1e-256, 1e-288, 1e-320]) / lists:nth(todo rem 32 + 1, [todo, 1e+01, 1e+02, 1e+03, 1e+04, 1e+05, 1e+06, 1e+07, 1e+08, 1e+09, 1e+10, 1e+11, 1e+12, 1e+13, 1e+14, 1e+15, 1e+16, 1e+17, 1e+18, 1e+19, 1e+20, 1e+21, 1e+22, 1e+23, 1e+24, 1e+25, 1e+26, 1e+27, 1e+28, 1e+29, 1e+30, 1e+31]);
                false -> 
                    case N > 0 of
                        true -> inf(1);
                        false -> 0.0
                                        end
                                        end
                end.

powi(A, B) ->
    B_ = B,
    P = A,
    V = todo,
    case B_ < 0 of
        true -> case A * A /= 1 of
            true -> 0;
            false -> case (B_ band 1) > 0 of
                true -> A;
                false -> 1
            end
        end;
        false -> begin
            % TODO: unhandled stmt type
            ok            V
        end
        end.

is_odd_int(X) ->
    Xi = element(1, modf(X)),
    Xf = element(2, modf(X)),
    Xf == 0 andalso (todo band 1) == 1.

pow(X, Y) ->
    case Y == 0 orelse X == 1 of
        true -> 1;
        false -> case Y == 1 of
            true -> X;
            false -> case is_nan(X) orelse is_nan(Y) of
                true -> nan();
                false -> case Y == 2 of
                    true -> X * X;
                    false -> case Y == 3 of
                        true -> X * X * X;
                        false -> case X == 0 of
                            true -> case Y < 0 of
                                true -> begin
                                    case is_odd_int(Y) of
                                        true -> copysign(inf(1), X);
                                        false -> ok
                                    end,
                                    inf(1)
                                end;
                                false -> case Y > 0 of
                                    true -> begin
                                        case is_odd_int(Y) of
                                            true -> X;
                                            false -> ok
                                        end,
                                        0
                                    end;
                                    false -> ok
                                end
                            end;
                            false -> case is_inf(Y, 0) of
                                true -> case X == -1 of
                                    true -> 1;
                                    false -> case (abs(X) < 1) == is_inf(Y, 1) of
                                        true -> 0;
                                        false -> inf(1)
                                    end
                                end;
                                false -> case is_inf(X, 0) of
                                    true -> begin
                                        case is_inf(X, -1) of
                                            true -> pow(1 / X, -Y);
                                            false -> ok
                                        end,
                                        case Y < 0 of
                                            true -> 0;
                                            false -> case Y > 0 of
                                                true -> inf(1);
                                                false -> ok
                                            end
                                        end
                                    end;
                                    false -> case Y == todo of
                                        true -> sqrt(X);
                                        false -> case Y == todo of
                                            true -> 1 / sqrt(X);
                                            false -> ok
                                        end
                                    end
                                end
                            end
                        end
                    end
                end
            end
        end
    end,
    Yi = element(1, modf(abs(Y))),
    Yf = element(2, modf(abs(Y))),
    case Yf /= 0 andalso X < 0 of
        true -> nan();
        false -> begin
            case Yi >= (todo bsl 63) of
                true -> case X == -1 of
                    true -> 1;
                    false -> case (abs(X) < 1) == (Y > 0) of
                        true -> 0;
                        false -> inf(1)
                    end
                end;
                false -> ok
            end,
            case Yf == todo of
                true -> 1 / Result;
                false -> begin
                    A1 = 1.0,
                    Ae = 0,
                    case Yf /= 0 of
                        true -> begin
                            case Yf > todo of
                                true -> begin
                                    todo,
                                    todo
                                end;
                                false -> ok
                            end,
                            A11 = exp(Yf * log(X)),
                        end;
                        false -> ok
                    end,
                    X1 = element(1, frexp(X)),
                    Xe = element(2, frexp(X)),
                    % TODO: unhandled stmt type
                    ok                    case Y < 0 of
                        true -> begin
                            A12 = 1 / A11,
                            Ae1 = -Ae,
                        end;
                        false -> ok
                    end,
                    ldexp(A12, Ae1)
                end
                        end
        end
        end.

q_rsqrt(X) ->
    X_half = todo * X,
    I = todo,
    I1 = 16#5fe6eb50c7b537a9 - (I bsr 1),
    J = f64_from_bits(todo),
    J1 = (todo - X_half * J * J),
    J2 = (todo - X_half * J1 * J1),
    J2.

scalbn(X, N_) ->
    N = N_,
    X1p1023 = f64_from_bits(todo),
    X1p53 = f64_from_bits(todo),
    X1p_1022 = f64_from_bits(todo),
    Y = X,
    case N > 1023 of
        true -> begin
            Y1 = X1p1023,
            N1 = 1023,
            case N1 > 1023 of
                true -> begin
                    Y2 = X1p1023,
                    N2 = 1023,
                    case N2 > 1023 of
                        true -> ok;
                        false -> ok
                    end
                end;
                false -> ok
            end
        end;
        false -> case N2 < -1022 of
            true -> begin
                Y3 = X1p_1022 * X1p53,
                N3 = 969,
                case N3 < -1022 of
                    true -> begin
                        Y4 = X1p_1022 * X1p53,
                        N4 = 969,
                        case N4 < -1022 of
                            true -> ok;
                            false -> ok
                        end
                    end;
                    false -> ok
                end
            end;
            false -> ok
        end
    end,
    Y4 * f64_from_bits(todo bsl 52).

sin(X) ->
    P1 = 7.85398125648498535156e-1,
    P2 = 3.77489470793079817668e-8,
    P3 = 2.69515142907905952645e-15,
    Sgn_x = case X < 0 of
        true -> -1;
        false -> 1
    end,
    Abs_x = abs(X),
    case Abs_x < todo of
        true -> begin
            X2 = X * X,
            X * (todo - X2 / todo)
        end;
        false -> begin
            Sgn_result = Sgn_x,
            Y = floor(Abs_x / todo),
            Octant = todo,
            case (Octant band 1) == 1 of
                true -> begin
                    todo,
                    Octant1 = 7,
                    Y1 = 1.0,
                end;
                false -> ok
            end,
            case Octant1 > 3 of
                true -> begin
                    Octant2 = 4,
                    Sgn_result1 = -Sgn_result,
                end;
                false -> ok
            end,
            Z = ((Abs_x - Y1 * P1) - Y1 * P2) - Y1 * P3,
            Result = 0.0,
            case Octant2 == 0 of
                true -> begin
                    T = todo * abs(Z) / todo - todo,
                    Sin_cs_val = element(1, 'ChebSeries.eval_e'(#{c => [-0.3295190160663511504173, 0.0025374284671667991990, 0.0006261928782647355874, -4.6495547521854042157541e-06, -5.6917531549379706526677e-07, 3.7283335140973803627866e-09, 3.0267376484747473727186e-10, -1.7400875016436622322022e-12, -1.0554678305790849834462e-13, 5.3701981409132410797062e-16, 2.5984137983099020336115e-17, -1.1821555255364833468288e-19], order => 11, a => -1, b => 1, {vbeam, type} => 'ChebSeries'}, T)),
                    Result1 = Z * (todo + Z * Z * Sin_cs_val),
                end;
                false -> begin
                    T1 = todo * abs(Z) / todo - todo,
                    Cos_cs_val = element(1, 'ChebSeries.eval_e'(#{c => [0.165391825637921473505668118136, -0.00084852883845000173671196530195, -0.000210086507222940730213625768083, 1.16582269619760204299639757584e-6, 1.43319375856259870334412701165e-7, -7.4770883429007141617951330184e-10, -6.0969994944584252706997438007e-11, 2.90748249201909353949854872638e-13, 1.77126739876261435667156490461e-14, -7.6896421502815579078577263149e-17, -3.7363121133079412079201377318e-18], order => 10, a => -1, b => 1, {vbeam, type} => 'ChebSeries'}, T1)),
                    Result2 = todo - todo * Z * Z * (todo - Z * Z * Cos_cs_val),
                end
            end,
            Result3 = Sgn_result1,
            Result3
        end
    end.

cos(X) ->
    P1 = 7.85398125648498535156e-1,
    P2 = 3.77489470793079817668e-8,
    P3 = 2.69515142907905952645e-15,
    Abs_x = abs(X),
    case Abs_x < todo of
        true -> begin
            X2 = X * X,
            todo - todo * X2
        end;
        false -> begin
            Sgn_result = 1,
            Y = floor(Abs_x / todo),
            Octant = todo,
            case (Octant band 1) == 1 of
                true -> begin
                    todo,
                    Octant1 = 7,
                    Y1 = 1.0,
                end;
                false -> ok
            end,
            case Octant1 > 3 of
                true -> begin
                    Octant2 = 4,
                    Sgn_result1 = -Sgn_result,
                end;
                false -> ok
            end,
            case Octant2 > 1 of
                true -> ok;
                false -> ok
            end,
            Z = ((Abs_x - Y1 * P1) - Y1 * P2) - Y1 * P3,
            Result = 0.0,
            case Octant2 == 0 of
                true -> begin
                    T = todo * abs(Z) / todo - todo,
                    Cos_cs_val = element(1, 'ChebSeries.eval_e'(#{c => [0.165391825637921473505668118136, -0.00084852883845000173671196530195, -0.000210086507222940730213625768083, 1.16582269619760204299639757584e-6, 1.43319375856259870334412701165e-7, -7.4770883429007141617951330184e-10, -6.0969994944584252706997438007e-11, 2.90748249201909353949854872638e-13, 1.77126739876261435667156490461e-14, -7.6896421502815579078577263149e-17, -3.7363121133079412079201377318e-18], order => 10, a => -1, b => 1, {vbeam, type} => 'ChebSeries'}, T)),
                    Result1 = todo - todo * Z * Z * (todo - Z * Z * Cos_cs_val),
                end;
                false -> begin
                    T1 = todo * abs(Z) / todo - todo,
                    Sin_cs_val = element(1, 'ChebSeries.eval_e'(#{c => [-0.3295190160663511504173, 0.0025374284671667991990, 0.0006261928782647355874, -4.6495547521854042157541e-06, -5.6917531549379706526677e-07, 3.7283335140973803627866e-09, 3.0267376484747473727186e-10, -1.7400875016436622322022e-12, -1.0554678305790849834462e-13, 5.3701981409132410797062e-16, 2.5984137983099020336115e-17, -1.1821555255364833468288e-19], order => 11, a => -1, b => 1, {vbeam, type} => 'ChebSeries'}, T1)),
                    Result2 = Z * (todo + Z * Z * Sin_cs_val),
                end
            end,
            Result3 = Sgn_result1,
            Result3
        end
    end.

cosf(A) ->
    todo.

sinf(A) ->
    todo.

sincos(X) ->
    case is_nan(X) of
        true -> X;
        false -> begin
            P1 = 7.85398125648498535156e-1,
            P2 = 3.77489470793079817668e-8,
            P3 = 2.69515142907905952645e-15,
            Sgn_x = case X < 0 of
                true -> -1;
                false -> 1
            end,
            Abs_x = abs(X),
            case is_inf(X, Sgn_x) of
                true -> nan();
                false -> case Abs_x < todo of
                    true -> begin
                        X2 = X * X,
                        X * (todo - X2 / todo)
                    end;
                    false -> begin
                        Sgn_result_sin = Sgn_x,
                        Sgn_result_cos = 1,
                        Y = floor(Abs_x / todo),
                        Octant = todo,
                        case (Octant band 1) == 1 of
                            true -> begin
                                todo,
                                Octant1 = 7,
                                Y1 = 1.0,
                            end;
                            false -> ok
                        end,
                        case Octant1 > 3 of
                            true -> begin
                                Octant2 = 4,
                                Sgn_result_sin1 = -Sgn_result_sin,
                                Sgn_result_cos1 = -Sgn_result_cos,
                            end;
                            false -> ok
                        end,
                        Sgn_result_cos2 = case Octant2 > 1 of
                            true -> -Sgn_result_cos1;
                            false -> Sgn_result_cos1
                        end,
                        Z = ((Abs_x - Y1 * P1) - Y1 * P2) - Y1 * P3,
                        T = todo * abs(Z) / todo - todo,
                        Sin_cs_val = element(1, 'ChebSeries.eval_e'(#{c => [-0.3295190160663511504173, 0.0025374284671667991990, 0.0006261928782647355874, -4.6495547521854042157541e-06, -5.6917531549379706526677e-07, 3.7283335140973803627866e-09, 3.0267376484747473727186e-10, -1.7400875016436622322022e-12, -1.0554678305790849834462e-13, 5.3701981409132410797062e-16, 2.5984137983099020336115e-17, -1.1821555255364833468288e-19], order => 11, a => -1, b => 1, {vbeam, type} => 'ChebSeries'}, T)),
                        Cos_cs_val = element(1, 'ChebSeries.eval_e'(#{c => [0.165391825637921473505668118136, -0.00084852883845000173671196530195, -0.000210086507222940730213625768083, 1.16582269619760204299639757584e-6, 1.43319375856259870334412701165e-7, -7.4770883429007141617951330184e-10, -6.0969994944584252706997438007e-11, 2.90748249201909353949854872638e-13, 1.77126739876261435667156490461e-14, -7.6896421502815579078577263149e-17, -3.7363121133079412079201377318e-18], order => 10, a => -1, b => 1, {vbeam, type} => 'ChebSeries'}, T)),
                        Result_sin = 0.0,
                        Result_cos = 0.0,
                        case Octant2 == 0 of
                            true -> begin
                                Result_sin1 = Z * (todo + Z * Z * Sin_cs_val),
                                Result_cos1 = todo - todo * Z * Z * (todo - Z * Z * Cos_cs_val),
                            end;
                            false -> begin
                                Result_sin2 = todo - todo * Z * Z * (todo - Z * Z * Cos_cs_val),
                                Result_cos2 = Z * (todo + Z * Z * Sin_cs_val),
                            end
                        end,
                        Result_sin3 = Sgn_result_sin1,
                        Result_cos3 = Sgn_result_cos2,
                        Result_sin3
                    end
                end
                        end
        end
        end.

sinh(X_) ->
    X = X_,
    P0 = -0.6307673640497716991184787251e+6,
    P1 = -0.8991272022039509355398013511e+5,
    P2 = -0.2894211355989563807284660366e+4,
    P3 = -0.2630563213397497062819489e+2,
    Q0 = -0.6307673640497716991212077277e+6,
    Q1 = 0.1521517378790019070696485176e+5,
    Q2 = -0.173678953558233699533450911e+3,
    Sign = false,
    case X < 0 of
        true -> begin
            X1 = -X,
            Sign1 = true,
        end;
        false -> ok
    end,
    Temp = 0.0,
    case X1 > 21 of
        true -> ok;
        false -> case X1 > todo of
            true -> begin
                Ex = exp(X1),
                Temp1 = (Ex - todo / Ex) * todo,
            end;
            false -> begin
                Sq = X1 * X1,
                Temp2 = (((P3 * Sq + P2) * Sq + P1) * Sq + P0) * X1,
                Temp3 = Temp2 / (((Sq + Q2) * Sq + Q1) * Sq + Q0),
            end
        end
    end,
    case Sign1 of
        true -> ok;
        false -> ok
    end,
    Temp3.

cosh(X) ->
    Abs_x = abs(X),
    case Abs_x > 21 of
        true -> exp(Abs_x) * todo;
        false -> begin
            Ex = exp(Abs_x),
            (Ex + todo / Ex) * todo
        end
        end.

sqrt(A) ->
    X = A,
    case X == todo orelse is_nan(X) orelse is_inf(X, 1) of
        true -> X;
        false -> 
            case X < todo of
                true -> nan();
                false -> begin
                    Z = element(1, frexp(X)),
                    Ex = element(2, frexp(X)),
                    W = X,
                    X1 = todo + todo * Z,
                    case (Ex band 1) /= 0 of
                        true -> ok;
                        false -> ok
                    end,
                    X2 = ldexp(X1, Ex bsr 1),
                    X3 = todo * (X2 + W / X2),
                    X4 = todo * (X3 + W / X3),
                    X5 = todo * (X4 + W / X4),
                    X5
                end
                        end
                end.

sqrtf(A) ->
    todo.

sqrti(A) ->
    X = A,
    Q = todo,
    R = todo,
    % TODO: unhandled stmt type
    ok    % TODO: unhandled stmt type
    ok    R.

square(X) ->
    X * X.

cube(X) ->
    X * X * X.

tan(A) ->
    X = A,
    case X == todo orelse is_nan(X) of
        true -> X;
        false -> 
            case is_inf(X, 0) of
                true -> nan();
                false -> begin
                    Sign = 1,
                    case X < 0 of
                        true -> begin
                            X1 = -X,
                            Sign1 = -1,
                        end;
                        false -> ok
                    end,
                    case X1 > todo of
                        true -> 0.0;
                        false -> begin
                            Y = floor(X1 * todo / todo),
                            Z = ldexp(Y, -3),
                            Z1 = floor(Z),
                            Z2 = Y - ldexp(Z1, 3),
                            Octant = todo,
                            case (Octant band 1) == 1 of
                                true -> begin
                                    todo,
                                    Y1 = 1.0,
                                end;
                                false -> ok
                            end,
                            Z3 = ((X1 - Y1 * todo) - Y1 * todo) - Y1 * todo,
                            Zz = Z3 * Z3,
                            case Zz > todo of
                                true -> ok;
                                false -> ok
                            end,
                            case (Octant band 2) == 2 of
                                true -> ok;
                                false -> ok
                            end,
                            case Sign1 < 0 of
                                true -> ok;
                                false -> ok
                            end,
                            Y1
                        end
                                        end
                end
                        end
                end.

tanf(A) ->
    todo.

cot(A) ->
    X = A,
    case X == todo of
        true -> inf(1);
        false -> begin
            Sign = 1,
            case X < 0 of
                true -> begin
                    X1 = -X,
                    Sign1 = -1,
                end;
                false -> ok
            end,
            case X1 > todo of
                true -> 0.0;
                false -> begin
                    Y = floor(X1 * todo / todo),
                    Z = ldexp(Y, -3),
                    Z1 = floor(Z),
                    Z2 = Y - ldexp(Z1, 3),
                    Octant = todo,
                    case (Octant band 1) == 1 of
                        true -> begin
                            todo,
                            Y1 = 1.0,
                        end;
                        false -> ok
                    end,
                    Z3 = ((X1 - Y1 * todo) - Y1 * todo) - Y1 * todo,
                    Zz = Z3 * Z3,
                    case Zz > todo of
                        true -> ok;
                        false -> ok
                    end,
                    case (Octant band 2) == 2 of
                        true -> ok;
                        false -> ok
                    end,
                    case Sign1 < 0 of
                        true -> ok;
                        false -> ok
                    end,
                    Y1
                end
                        end
        end
        end.

tanh(X) ->
    Maxlog = 8.8029691931113054295988e+01,
    Z = abs(X),
    case Z > todo * Maxlog of
        true -> begin
            case X < 0 of
                true -> todo;
                false -> ok
            end,
            1.0
        end;
        false -> case Z >= todo of
            true -> begin
                S = exp(todo * Z),
                Z1 = todo - todo / (S + todo),
                case X < 0 of
                    true -> ok;
                    false -> ok
                end
            end;
            false -> begin
                case X == 0 of
                    true -> X;
                    false -> ok
                end,
                S1 = X * X,
                Z2 = X + X * S1 * ((lists:nth(1, [-9.64399179425052238628e-1, -9.92877231001918586564e+1, -1.61468768441708447952e+3]) * S1 + lists:nth(2, [-9.64399179425052238628e-1, -9.92877231001918586564e+1, -1.61468768441708447952e+3])) * S1 + lists:nth(3, [-9.64399179425052238628e-1, -9.92877231001918586564e+1, -1.61468768441708447952e+3])) / (((S1 + lists:nth(1, [1.12811678491632931402e+2, 2.23548839060100448583e+3, 4.84406305325125486048e+3])) * S1 + lists:nth(2, [1.12811678491632931402e+2, 2.23548839060100448583e+3, 4.84406305325125486048e+3])) * S1 + lists:nth(3, [1.12811678491632931402e+2, 2.23548839060100448583e+3, 4.84406305325125486048e+3])),
            end
        end
    end,
    Z2.

f32_bits(F) ->
    % TODO: unhandled stmt type
    ok    todo.

f32_from_bits(B) ->
    % TODO: unhandled stmt type
    ok    todo.

f64_bits(F) ->
    % TODO: unhandled stmt type
    ok    todo.

f64_from_bits(B) ->
    % TODO: unhandled stmt type
    ok    todo.

with_set_low_word(F, Lo) ->
    Tmp = f64_bits(F),
    Tmp1 = 16#ffffffff00000000,
    Tmp2 = todo,
    f64_from_bits(Tmp2).

with_set_high_word(F, Hi) ->
    Tmp = f64_bits(F),
    Tmp1 = 16#00000000ffffffff,
    Tmp2 = todo bsl 32,
    f64_from_bits(Tmp2).

get_high_word(F) ->
    todo.
