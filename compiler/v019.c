 // Generated by V
    
#include <stdio.h>  // TODO remove all these includes, define all function signatures and types manually 
#include <stdlib.h>
#include <signal.h>
#include <stdarg.h> // for va_list 
#include <inttypes.h>  // int64_t etc 


#ifdef __linux__ 
#include <pthread.h> 
#endif 


#ifdef __APPLE__ 

#endif 


#ifdef _WIN32 
#include <windows.h>
//#include <WinSock2.h> 
#endif 

//================================== TYPEDEFS ================================*/ 

typedef unsigned char byte;
typedef unsigned int uint;
typedef int64_t i64;
typedef int32_t i32;
typedef int16_t i16;
typedef int8_t i8;
typedef uint64_t u64;
typedef uint32_t u32;
typedef uint16_t u16;
typedef uint8_t u8;
typedef uint32_t rune;
typedef float f32;
typedef double f64; 
typedef unsigned char* byteptr;
typedef int* intptr;
typedef void* voidptr;
typedef struct array array;
typedef struct map map;
typedef array array_string; 
typedef array array_int; 
typedef array array_byte; 
typedef array array_uint; 
typedef array array_float; 
typedef map map_int; 
typedef map map_string; 
#ifndef bool
	typedef int bool;
	#define true 1
	#define false 0
#endif

//============================== HELPER C MACROS =============================*/ 

#define _PUSH(arr, val, tmp, tmp_typ) {tmp_typ tmp = (val); array__push(arr, &tmp);}
#define _IN(typ, val, arr) array_##typ##_contains(arr, val) 
#define ALLOC_INIT(type, ...) (type *)memdup((type[]){ __VA_ARGS__ }, sizeof(type)) 
#define UTF8_CHAR_LEN( byte ) (( 0xE5000000 >> (( byte >> 3 ) & 0x1e )) & 3 ) + 1 

//================================== GLOBALS =================================*/   
//int V_ZERO = 0; 
byteptr g_str_buf; 
int load_so(byteptr);
void reload_so();
void init_consts();
 int g_test_ok = 1; 
 /*================================== FNS =================================*/
#include <sys/stat.h>
#include <signal.h>
#include <unistd.h>
#include <dirent.h>
#include <errno.h>
#include <time.h>
typedef struct array array;
typedef array array_int;
typedef array array_string;
typedef struct string string;
typedef struct ustring ustring;
typedef array array_byte;
typedef struct map map;
typedef array array_Entry;
typedef struct Entry Entry;
typedef struct Option Option;
typedef struct StringBuilder StringBuilder;
typedef struct os__FILE os__FILE;
typedef struct os__File os__File;
typedef struct os__FileInfo os__FileInfo;
typedef Option Option_string;
typedef array array_ustring;
typedef struct time__Time time__Time;
typedef struct CGen CGen;
typedef struct Fn Fn;
typedef array array_Var;
typedef int BuildMode ;

typedef int Os ;

typedef int Pass ;

typedef struct V V;
typedef struct Var Var;
typedef struct Parser Parser;
typedef struct Scanner Scanner;
typedef struct ScanRes ScanRes;
typedef struct Table Table;
typedef array array_Type;
typedef array array_Fn;
typedef int AccessMod ;

typedef int TypeCategory ;

typedef struct Type Type;
typedef int Token ;

typedef array array_Token;
typedef Option Option_string;
typedef int BuildMode ;

typedef int Os ;

typedef int Pass ;

typedef int AccessMod ;

typedef int TypeCategory ;

typedef int Token ;

struct /*kind*/ array {
void* data;
int len;
int cap;
int element_size;
}; 
struct /*kind*/ string {
byte* str;
int len;
}; 
struct /*kind*/ ustring {
string s;
array_int runes;
int len;
}; 
struct /*kind*/ map {
int element_size;
array_Entry entries;
bool is_sorted;
}; 
struct /*kind*/ Entry {
string key;
void* val;
}; 
struct /*kind*/ Option {
void* data;
string error;
bool ok;
}; 
struct /*kind*/ StringBuilder {
array_byte buf;
int len;
}; 
struct /*kind*/ os__FILE {
}; 
struct /*kind*/ os__File {
os__FILE* cfile;
}; 
struct /*kind*/ os__FileInfo {
string name;
int size;
}; 
struct /*kind*/ time__Time {
int year;
int month;
int day;
int hour;
int minute;
int second;
int uni;
}; 
struct /*kind*/ CGen {
os__File out;
string out_path;
array_string typedefs;
array_string type_aliases;
array_string includes;
array_string types;
array_string thread_args;
array_string thread_fns;
array_string consts;
array_string fns;
array_string so_fns;
array_string consts_init;
array_string lines;
bool is_user;
Pass run;
bool nogen;
string tmp_line;
string cur_line;
string prev_line;
bool is_tmp;
string fn_main;
string stash;
}; 
struct /*kind*/ Fn {
string pkg;
array_Var local_vars;
int var_idx;
array_Var args;
bool is_interface;
int scope_level;
string typ;
string name;
bool is_c;
string receiver_typ;
bool is_public;
bool is_method;
bool returns_error;
bool is_decl;
string defer;
}; 
struct /*kind*/ V {
BuildMode build_mode;
Os os;
bool nofmt;
string out_name_c;
array_string files;
string dir;
Table* table;
CGen* cgen;
bool is_test;
bool is_script;
bool is_so;
bool is_live;
bool is_prof;
bool translated;
bool obfuscate;
string lang_dir;
bool is_verbose;
bool is_run;
bool is_play;
bool show_c_cmd;
bool sanitize;
string out_name;
bool is_prod;
bool is_repl;
string vroot;
}; 
struct /*kind*/ Var {
string typ;
string name;
bool is_arg;
bool is_const;
bool is_import_const;
array_Var args;
string attr;
bool is_mut;
bool ptr;
bool ref;
string parent_fn;
string pkg;
int line_nr;
AccessMod access_mod;
bool is_global;
bool is_used;
int scope_level;
}; 
struct /*kind*/ Parser {
string file_path;
string file_name;
Scanner* scanner;
int token_idx;
Token tok;
Token prev_tok;
Token prev_tok2;
string lit;
CGen* cgen;
Table* table;
Pass run;
Os os;
string pkg;
bool inside_const;
Var expr_var;
string assigned_type;
int tmp_cnt;
bool is_test;
bool is_script;
bool is_live;
bool is_so;
bool is_prof;
bool translated;
bool is_prod;
bool is_verbose;
bool obfuscate;
bool is_play;
bool is_repl;
bool builtin_pkg;
BuildMode build_mode;
array_string vh_lines;
bool inside_if_expr;
bool is_struct_init;
int if_expr_cnt;
int for_expr_cnt;
bool ptr_cast;
bool calling_c;
Fn* cur_fn;
bool returns;
string vroot;
bool is_c_struct_init;
bool can_chash;
}; 
struct /*kind*/ Scanner {
string file_path;
string text;
int pos;
int line_nr;
bool inside_string;
bool dollar_start;
bool dollar_end;
bool debug;
string line_comment;
bool started;
bool is_fmt;
StringBuilder fmt_out;
int fmt_indent;
bool fmt_line_empty;
}; 
struct /*kind*/ ScanRes {
Token tok;
string lit;
}; 
struct /*kind*/ Table {
array_Type types;
array_Var consts;
array_Fn fns;
map_int obf_ids;
array_string packages;
array_string imports;
array_string flags;
_Atomic 
int fn_cnt;
bool obfuscate;
}; 
struct /*kind*/ Type {
string pkg;
string name;
array_Var fields;
array_Fn methods;
string parent;
TypeCategory cat;
array_string gen_types;
Fn func;
bool is_c;
bool is_interface;
bool is_enum;
bool is_placeholder;
}; 

string _STR(const char*, ...);


string _STR_TMP(const char*, ...);

array new_array(int mylen, int cap, int elm_size);
array new_array_from_c_array(int len, int cap, int elm_size, void* c_array);
array new_array_from_c_array_no_alloc(int len, int cap, int elm_size, void* c_array);
array array_repeat(void* val, int nr_repeats, int elm_size);
void array_append_array(array* a, array b);
void array_sort_with_compare(array* a, void* compare);
void array_insert(array* a, int i, void* val);
void array_prepend(array* a, void* val);
void array_delete(array* a, int idx);
void* array__get(array a, int i);
void* array_first(array a);
void* array_last(array a);
array array_left(array s, int n);
array array_right(array s, int n);
array array_slice(array s, int start, int _end);
void array_set(array* a, int idx, void* val);
void array__push(array* arr, void* val);
void array__push_many(array* arr, void* val, int size);
string array_int_str(array_int a);
void v_array_int_free(array_int a);
string array_string_str(array_string a);
void v_free(void* a);
string tos(byte* s, int len);
string tos_clone(byte* s);
string tos2(byte* s);
string string_clone(string a);
byte* string_cstr(string s);
string string_replace(string s, string rep, string with);
int string_int(string s);
f32 string_f32(string s);
bool string_eq(string s, string a);
bool string_ne(string s, string a);
bool string_lt(string s, string a);
bool string_le(string s, string a);
bool string_gt(string s, string a);
bool string_ge(string s, string a);
string string_add(string s, string a);
array_string string_split(string s, string delim);
array_string string_split_single(string s, byte delim);
array_string string_split_into_lines(string s);
string string_left(string s, int n);
string string_right(string s, int n);
string string_substr(string s, int start, int end);
int string_index(string s, string p);
int string_last_index(string s, string p);
int string_index_after(string s, string p, int start);
bool string_contains(string s, string p);
bool string_starts_with(string s, string p);
bool string_ends_with(string s, string p);
string string_to_lower(string s);
string string_to_upper(string s);
string string_find_between(string s, string start, string end);
bool array_string_contains(array_string ar, string val);
bool array_int_contains(array_int ar, int val);
bool is_space(byte c);
bool byte_is_space(byte c);
string string_trim_space(string s);
string string_trim(string s, byte c);
string string_trim_left(string s, string cutset);
string string_trim_right(string s, string cutset);
int compare_strings(string* a, string* b);
int compare_strings_by_len(string* a, string* b);
int compare_lower_strings(string* a, string* b);
void array_string_sort(array_string* s);
void array_string_sort_ignore_case(array_string* s);
void array_string_sort_by_len(array_string* s);
ustring string_ustring(string s);
ustring string_ustring_tmp(string s);
string ustring_substr(ustring u, int start, int end);
string ustring_left(ustring u, int pos);
string ustring_right(ustring u, int pos);
byte string_at(string s, int idx);
string ustring_at(ustring u, int idx);
void v_ustring_free(ustring u);
int abs(int a);
bool byte_is_digit(byte c);
bool byte_is_letter(byte c);
void v_string_free(string s);
void v_array_string_free(array_string arr);
string string_all_before(string s, string dot);
string string_all_before_last(string s, string dot);
string string_all_after(string s, string dot);
string array_string_join(array_string a, string del);
string array_string_join_lines(array_string s);
string string_reverse(string s);
string string_limit(string s, int max);
bool byte_is_white(byte c);
string repeat_char(byte c, int n);
int string_hash(string s);
bool string_is_empty(string s);
void v_exit(int code);
bool isnil(void* v);
void on_panic(int (*f)( int  /*FFF*/ ));
void print_backtrace();
void v_panic(string s);
void println(string s);
void eprintln(string s);
void v_print(string s);
byte* v_malloc(int n);
byte* v_calloc(int n);
int _strlen(byte* s);
Option opt_ok(void* data);
void* memdup(void* src, int sz);
Option v_error(string s);
string double_str(double d);
string f64_str(f64 d);
string f32_str(f32 d);
string ptr_str(void* ptr);
string int_str(int nn);
string u8_str(u8 nn);
string i64_str(i64 nn);
string bool_str(bool b);
string int_hex(int n);
string i64_hex(i64 n);
bool array_byte_contains(array_byte a, byte val);
string byte_str(byte c);
int utf8_char_len(byte b);
string utf32_to_str(u32 code);
string utf32_to_str_no_malloc(u32 code, void* buf);
int string_utf32_code(string _rune);
map new_map(int cap, int elm_size);
Entry map_new_entry(map* m, string key, void* val);
void map__set(map* m, string key, void* val);
int volt_abs(int n);
void map_bs(map m, string query, int start, int end, void* out);
int compare_map(Entry* a, Entry* b);
void map_sort(map* m);
array_string map_keys(map m);
bool map_get(map m, string key, void* out);
bool map_exists(map m, string key);
void v_map_print(map m);
void v_map_free(map m);
string map_string_str(map_string m);
StringBuilder new_string_builder(int initial_size);
void StringBuilder_write(StringBuilder* b, string s);
void StringBuilder_writeln(StringBuilder* b, string s);
string StringBuilder_str(StringBuilder b);
void StringBuilder_cut(StringBuilder b, int n);
void v_StringBuilder_free(StringBuilder* b);
void os__todo_remove();
array_string os__init_os_args(int argc, byteptr* argv);
array_string os__parse_windows_cmd_line(byte* cmd);
Option_string os__read_file(string path);
int os__file_size(string path);
void os__mv(string old, string new);
array_string os__read_lines(string path);
array_ustring os__read_ulines(string path);
os__File os__open(string path);
os__File os__open_file(string file);
os__File os__create(string path);
os__File os__open_append(string path);
os__File os__create_file(string file);
os__File os__create_file_a(string file);
os__File os__open_file_a(string file);
os__File os__create_file2(string file, string mode);
void os__File_append(os__File f, string s);
void os__File_write_bytes(os__File f, void* data, int size);
void os__File_write_bytes_at(os__File f, void* data, int size, int pos);
void os__File_appendln(os__File f, string s);
void os__File_close(os__File f);
void os__close_file(os__FILE* fp);
int os__system(string cmd);
os__FILE* os__popen(string path);
string os__exec(string cmd);
string os__getenv(string key);
int os__setenv(string name, string value, bool overwrite);
int os__unsetenv(string name);
bool os__file_exists(string path);
bool os__dir_exists(string path);
void os__mkdir(string path);
void os__rm(string path);
void os__print_c_errno();
string os__ext(string path);
string os__path_sans_ext(string path);
string os__basedir(string path);
string os__filename(string path);
string os__get_line();
string os__get_raw_line();
string os__user_os();
string os__home_dir();
void os__write_file(string path, string text);
void os__clear();
void os__on_segfault(void* f);
string os__getexepath();
void os__log(string s);
bool os__is_dir(string path);
void os__chdir(string path);
string os__getwd();
array_string os__ls(string path);
void os__print_backtrace();
time__Time time__now();
time__Time time__random();
time__Time time__unix(int u);
time__Time time__convert_ctime(struct /*TM*/ tm t);
string time__Time_format_ss(time__Time t);
string time__Time_format(time__Time t);
string time__Time_smonth(time__Time t);
string time__Time_hhmm(time__Time t);
string time__Time_hhmm12(time__Time t);
string time__Time_hhmmss(time__Time t);
string time__Time_ymmdd(time__Time t);
string time__Time_md(time__Time t);
string time__Time_clean(time__Time t);
string time__Time_clean12(time__Time t);
time__Time time__parse(string s);
time__Time time__new_time(time__Time t);
int time__Time_calc_unix(time__Time* t);
time__Time time__Time_add_seconds(time__Time t, int seconds);
int time__since(time__Time t);
string time__Time_relative(time__Time t);
int time__day_of_week(int y, int m, int d);
int time__Time_day_of_week(time__Time t);
string time__Time_weekday_str(time__Time t);
f64 time__ticks();
void time__sleep(int seconds);
void time__usleep(int n);
void time__sleep_ms(int n);
void rand__seed();
int rand__next(int max);
CGen* new_cgen(string out_name_c);
void CGen_genln(CGen* g, string s);
void CGen_gen(CGen* g, string s);
void CGen_save(CGen* g);
void CGen_start_tmp(CGen* g);
string CGen_end_tmp(CGen* g);
int CGen_add_placeholder(CGen* g);
void CGen_set_placeholder(CGen* g, int pos, string val);
int CGen_add_placeholder2(CGen* g);
void CGen_set_placeholder2(CGen* g, int pos, string val);
void CGen_insert_before(CGen* g, string val);
void CGen_register_thread_fn(CGen* g, string wrapper_name, string wrapper_text, string struct_text);
string V_prof_counters(V* c);
string Parser_print_prof_counters(Parser* p);
void Parser_gen_type(Parser* p, string s);
void Parser_gen_typedef(Parser* p, string s);
void Parser_gen_type_alias(Parser* p, string s);
void CGen_add_to_main(CGen* g, string s);
Var Fn_find_var(Fn* f, string name);
void Fn_open_scope(Fn* f);
void Fn_close_scope(Fn* f);
void Fn_mark_var_used(Fn* f, Var v);
bool Fn_known_var(Fn* f, string name);
void Fn_register_var(Fn* f, Var v);
void Fn_clear_vars(Fn* f);
bool Parser_is_sig(Parser* p);
Fn* new_fn(string pkg, bool is_public);
void Parser_fn_decl(Parser* p);
void Parser_check_unused_variables(Parser* p);
void Parser_async_fn_call(Parser* p, Fn f, int method_ph, string receiver_var, string receiver_type);
void Parser_fn_call(Parser* p, Fn f, int method_ph, string receiver_var, string receiver_type);
void Parser_fn_args(Parser* p, Fn* f);
Fn* Parser_fn_call_args(Parser* p, Fn* f);
bool contains_capital(string s);
string Fn_typ_str(Fn f);
string Fn_str_args(Fn* f, Table* table);
void Parser_gen_json_for_type(Parser* p, Type typ);
bool is_js_prim(string typ);
string Parser_decode_array(Parser* p, string typ);
string js_enc_name(string typ);
string js_dec_name(string typ);
string Parser_encode_array(Parser* p, string typ);
string vtmp_path();
void V_compile(V* c);
void V_cc(V* c);
array_string V_v_files_from_dir(V* c, string dir);
void V_add_user_v_files(V* c);
string get_arg(string joined_args, string arg, string def);
void V_log(V* c, string s);
V* new_v(array_string args);
array_string run_repl();
Parser V_new_parser(V* c, string path, Pass run);
void Parser_next(Parser* p);
void Parser_log(Parser* p, string s);
void Parser_parse(Parser* p);
void Parser_import_statement(Parser* p);
void Parser_const_decl(Parser* p);
void Parser_type_decl(Parser* p);
void Parser_struct_decl(Parser* p);
void Parser_enum_decl(Parser* p, string _enum_name);
string Parser_check_name(Parser* p);
string Parser_check_string(Parser* p);
string Parser_strtok(Parser* p);
void Parser_check_space(Parser* p, Token expected);
void Parser_check(Parser* p, Token expected);
void Parser_error(Parser* p, string s);
bool Parser_first_run(Parser* p);
string Parser_get_type(Parser* p);
void Parser_print_tok(Parser* p);
string Parser_statements(Parser* p);
string Parser_statements_no_curly_end(Parser* p);
void Parser_genln(Parser* p, string s);
void Parser_gen(Parser* p, string s);
void Parser_vh_genln(Parser* p, string s);
void Parser_fmt_inc(Parser* p);
void Parser_fmt_dec(Parser* p);
string Parser_statement(Parser* p, bool add_semi);
void Parser_assign_statement(Parser* p, Var v, int ph, bool is_map);
void Parser_var_decl(Parser* p);
string Parser_bool_expression(Parser* p);
string Parser_bterm(Parser* p);
string Parser_name_expr(Parser* p);
string Parser_var_expr(Parser* p, Var v);
bool Parser_fileis(Parser* p, string s);
string Parser_dot(Parser* p, string str_typ, int method_ph);
string Parser_index_expr(Parser* p, string typ, int fn_ph);
string Parser_expression(Parser* p);
string Parser_term(Parser* p);
string Parser_unary(Parser* p);
string Parser_factor(Parser* p);
string Parser_assoc(Parser* p);
void Parser_char_expr(Parser* p);
string format_str(string str);
string Parser_typ_to_fmt(Parser* p, string typ);
void Parser_string_expr(Parser* p);
string Parser_map_init(Parser* p);
string Parser_array_init(Parser* p);
void Parser_register_array(Parser* p, string typ);
string Parser_struct_init(Parser* p, bool is_c_struct_init);
string Parser_cast(Parser* p, string typ);
string Parser_get_tmp(Parser* p);
int Parser_get_tmp_counter(Parser* p);
string os_name_to_ifdef(string name);
void Parser_comp_time(Parser* p);
void Parser_chash(Parser* p);
string Parser_if_st(Parser* p, bool is_expr);
void Parser_for_st(Parser* p);
void Parser_switch_statement(Parser* p);
void Parser_assert_statement(Parser* p);
void Parser_return_st(Parser* p);
string prepend_pkg(string pkg, string name);
string Parser_prepend_pkg(Parser* p, string name);
void Parser_go_statement(Parser* p);
void Parser_register_var(Parser* p, Var v);
string Parser_js_decode(Parser* p);
bool is_compile_time_const(string s);
bool Parser_building_v(Parser* p);
void Scanner_fgen(Scanner* scanner, string s);
void Scanner_fgenln(Scanner* scanner, string s);
void Parser_fgen(Parser* p, string s);
void Parser_fspace(Parser* p);
void Parser_fgenln(Parser* p, string s);
Scanner* new_scanner(string file_path);
ScanRes scan_res(Token tok, string lit);
bool is_white(byte c);
bool is_nl(byte c);
string Scanner_ident_name(Scanner* s);
string Scanner_ident_number(Scanner* s);
void Scanner_skip_whitespace(Scanner* s);
string Scanner_get_var_name(Scanner* s, int pos);
void Scanner_cao_change(Scanner* s, string operator);
ScanRes Scanner_scan(Scanner* s);
void Scanner_error(Scanner* s, string msg);
string Scanner_ident_string(Scanner* s);
string Scanner_ident_char(Scanner* s);
Token Parser_peek(Parser* p);
Token Scanner_peek(Scanner* s);
void Scanner_debug_tokens(Scanner* s);
bool is_name_char(byte c);
int Scanner_get_opening_bracket(Scanner* s);
void Scanner_create_type_string(Scanner* s, Type T, string name);
void Parser_create_type_string(Parser* p, Type T, string name);
string Type_str(Type t);
string Fn_str(Fn f);
bool is_number_type(string typ);
bool is_float_type(string typ);
Table* new_table(bool obfuscate);
string Table_var_cgen_name(Table* t, string name);
void Table_register_package(Table* t, string pkg);
bool Table_known_pkg(Table* table, string pkg);
void Table_register_const(Table* t, string name, string typ, string pkg, bool is_imported);
void Parser_register_global(Parser* p, string name, string typ);
void Table_register_fn(Table* t, Fn f);
bool Table_known_type(Table* table, string typ);
Fn Table_find_fn(Table* t, string name);
bool Table_known_fn(Table* t, string name);
bool Table_known_const(Table* t, string name);
void Table_register_type(Table* t, string typ);
void Parser_register_type_with_parent(Parser* p, string strtyp, string parent);
void Table_register_type_with_parent(Table* t, string typ, string parent);
void Table_register_type2(Table* t, Type typ);
void Type_add_field(Type* t, string name, string typ, bool is_mut, string attr, AccessMod access_mod);
bool Type_has_field(Type* t, string name);
Var Type_find_field(Type* t, string name);
bool Table_type_has_field(Table* table, Type* typ, string name);
Var Table_find_field(Table* table, Type* typ, string name);
void Type_add_method(Type* t, Fn f);
bool Type_has_method(Type* t, string name);
bool Table_type_has_method(Table* table, Type* typ, string name);
Fn Table_find_method(Table* table, Type* typ, string name);
Fn Type_find_method(Type* t, string name);
void Type_add_gen_type(Type* t, string type_name);
Type* Parser_find_type(Parser* p, string name);
Type* Table_find_type(Table* t, string name);
bool Parser__check_types(Parser* p, string got, string expected, bool throw);
bool Parser_check_types(Parser* p, string got, string expected);
bool Parser_check_types_no_throw(Parser* p, string got, string expected);
bool Parser_satisfies_interface(Parser* p, string interface_name, string _typ, bool throw);
string type_default(string typ);
bool Table_is_interface(Table* t, string name);
bool Table_main_exists(Table* t);
Var Table_find_const(Table* t, string name);
string Table_cgen_name(Table* table, Fn* f);
string Table_cgen_name_type_pair(Table* table, string name, string typ);
map_int build_keys();
array_string build_token_str();
Token key_to_token(string key);
bool is_key(string key);
string Token_str(Token t);
bool Token_is_decl(Token t);
bool Token_is_assign(Token t);
bool array_Token_contains(array_Token t, Token val);
array_int g_ustring_runes; // global
i64 total_m =  0; // global
array_string os__args;
#define os__MAX_PATH  4096
string time__Months;
string time__Days;
#define main__MaxLocalVars  50
string main__Version;
#define DEFAULT_MODE 0 

#define EMBED_VLIB 1 

#define BUILD 2 

array_string main__SupportedPlatforms;
string main__TmpPath;
#define MAC 0 

#define LINUX 1 

#define WINDOWS 2 

#define RUN_IMPORTS 0 

#define RUN_DECLS 1 

#define RUN_MAIN 2 

string main__HelpText;
Fn* main__EmptyFn;
Fn* main__MainFn;
#define main__SINGLE_QUOTE  '\''
#define main__QUOTE  '"'
#define PRIVATE 0 

#define PRIVET_MUT 1 

#define PUBLIC 2 

#define PUBLIC_MUT 3 

#define PUBLIC_MUT_MUT 4 

#define TYPE_STRUCT 0 

#define T_CAT_FN 1 

array_string main__CReserved;
array_string main__NUMBER_TYPES;
array_string main__FLOAT_TYPES;
#define EOF 0 

#define NAME 1 

#define INT 2 

#define STRING 3 

#define CHAR 4 

#define PLUS 5 

#define MINUS 6 

#define MUL 7 

#define DIV 8 

#define MOD 9 

#define XOR 10 

#define PIPE 11 

#define INC 12 

#define DEC 13 

#define AND 14 

#define OR 15 

#define NOT 16 

#define BIT_NOT 17 

#define QUESTION 18 

#define COMMA 19 

#define SEMICOLON 20 

#define COLON 21 

#define AMP 22 

#define HASH 23 

#define DOLLAR 24 

#define LEFT_SHIFT 25 

#define RIGHT_SHIFT 26 

#define ASSIGN 27 

#define DECL_ASSIGN 28 

#define PLUS_ASSIGN 29 

#define MINUS_ASSIGN 30 

#define DIV_ASSIGN 31 

#define MULT_ASSIGN 32 

#define XOR_ASSIGN 33 

#define MOD_ASSIGN 34 

#define OR_ASSIGN 35 

#define AND_ASSIGN 36 

#define RIGHT_SHIFT_ASSIGN 37 

#define LEFT_SHIFT_ASSIGN 38 

#define LCBR 39 

#define RCBR 40 

#define LPAR 41 

#define RPAR 42 

#define LSBR 43 

#define RSBR 44 

#define EQ 45 

#define NE 46 

#define GT 47 

#define LT 48 

#define GE 49 

#define LE 50 

#define LINE_COM 51 

#define MLINE_COM 52 

#define NL 53 

#define DOT 54 

#define DOTDOT 55 

#define keyword_beg 56 

#define PACKAGE 57 

#define STRUCT 58 

#define IF 59 

#define ELSE 60 

#define RETURN 61 

#define GO 62 

#define CONST 63 

#define IMPORT_CONST 64 

#define MUT 65 

#define TIP 66 

#define ENUM 67 

#define FOR 68 

#define SWITCH 69 

#define MATCH 70 

#define CASE 71 

#define FUNC 72 

#define TRUE 73 

#define FALSE 74 

#define CONTINUE 75 

#define BREAK 76 

#define EMBED 77 

#define IMPORT 78 

#define TYPEOF 79 

#define DEFAULT 80 

#define ENDIF 81 

#define ASSERT 82 

#define SIZEOF 83 

#define IN 84 

#define ATOMIC 85 

#define INTERFACE 86 

#define OR_ELSE 87 

#define GLOBAL 88 

#define UNION 89 

#define PUB 90 

#define GOTO 91 

#define STATIC 92 

#define keyword_end 93 

array_string main__TOKENSTR;
map_int main__KEYWORDS;
array_Token main__AssignTokens;


 array new_array(int mylen, int cap, int elm_size) {
 
array arr= (array) { .len =  mylen , .cap =  cap , .element_size =  elm_size , .data =  v_malloc ( cap * elm_size ) } ;

 
 return  arr ;
 
 
 }
 array new_array_from_c_array(int len, int cap, int elm_size, void* c_array) {
 
array arr= (array) { .len =  len , .cap =  cap , .element_size =  elm_size , .data =  v_malloc ( cap * elm_size ) } ;
 
 memcpy ( arr .data ,  c_array ,  len * elm_size ) ;

 
 return  arr ;
 
 
 }
 array new_array_from_c_array_no_alloc(int len, int cap, int elm_size, void* c_array) {
 
array arr= (array) { .len =  len , .cap =  cap , .element_size =  elm_size , .data =  c_array } ;

 
 return  arr ;
 
 
 }
 array array_repeat(void* val, int nr_repeats, int elm_size) {
 
array arr= (array) { .len =  nr_repeats , .cap =  nr_repeats , .element_size =  elm_size , .data =  v_malloc ( nr_repeats * elm_size ) } ;
 
 for (
int i= 0  ;  i < nr_repeats  ;  i ++ ) { 
 
 memcpy ( arr .data + i * elm_size ,  val ,  elm_size ) ;
 
 }
 ;

 
 return  arr ;
 
 
 }
 void array_append_array(array* a, array b) {
 
 for (
int i= 0  ;  i < b .len  ;  i ++ ) { 
 
void* val= ( *(void**) array__get( b , i) ) ;
 
 array__push( a , val ) ;
 
 }
 ;
 
 
 }
 void array_sort_with_compare(array* a, void* compare) {
 
 qsort ( a ->data ,  a ->len ,  a ->element_size ,  compare ) ;
 
 
 }
 void array_insert(array* a, int i, void* val) {
 
 if ( i >= a ->len ) {
 /*if*/
 
 v_panic ( tos2("array.insert: index larger than length") ) ;

 
 return  ;
 
 }
 ;
 
 array__push( a , val ) ;
 
int size= a ->element_size ;
 
 memmove ( a ->data + (/*lpar*/ i + 1 ) * size ,  a ->data + i * size ,  (/*lpar*/ a ->len - i ) * size ) ;
 
 array_set( a , i , val ) ;
 
 
 }
 void array_prepend(array* a, void* val) {
 
 array_insert( a , 0 , val ) ;
 
 
 }
 void array_delete(array* a, int idx) {
 
int size= a ->element_size ;
 
 memmove ( a ->data + idx * size ,  a ->data + (/*lpar*/ idx + 1 ) * size ,  (/*lpar*/ a ->len - idx ) * size ) ;
 
 a ->len -- ;
 
 a ->cap -- ;
 
 
 }
 void* array__get(array a, int i) {
 
 if ( i < 0  ||  i >= a .len ) {
 /*if*/
 
 v_panic ( _STR("array index out of range: %d/%d", i, a .len) ) ;
 
 }
 ;

 
 return  a .data + i * a .element_size ;
 
 
 }
 void* array_first(array a) {
 
 if ( a .len == 0 ) {
 /*if*/
 
 v_panic ( tos2("array.first: empty array") ) ;
 
 }
 ;

 
 return  a .data + 0 ;
 
 
 }
 void* array_last(array a) {
 
 if ( a .len == 0 ) {
 /*if*/
 
 v_panic ( tos2("array.last: empty array") ) ;
 
 }
 ;

 
 return  a .data + (/*lpar*/ a .len - 1 ) * a .element_size ;
 
 
 }
 array array_left(array s, int n) {
 
 if ( n >= s .len ) {
 /*if*/

 
 return  s ;
 
 }
 ;

 
 return  array_slice( s , 0 , n ) ;
 
 
 }
 array array_right(array s, int n) {
 
 if ( n >= s .len ) {
 /*if*/

 
 return  s ;
 
 }
 ;

 
 return  array_slice( s , n , s .len ) ;
 
 
 }
 array array_slice(array s, int start, int _end) {
 
int end= _end ;
 
 if ( start > end ) {
 /*if*/
 
 v_panic ( _STR("invalid slice index: %d > %d", start, end) ) ;
 
 }
 ;
 
 if ( end >= s .len ) {
 /*if*/
 
 end  =  s .len ;
 
 }
 ;
 
int l= end - start ;
 
array res= (array) { .element_size =  s .element_size , .data =  s .data + start * s .element_size , .len =  l , .cap =  l } ;

 
 return  res ;
 
 
 }
 void array_set(array* a, int idx, void* val) {
 
 if ( idx < 0  ||  idx >= a ->len ) {
 /*if*/
 
 v_panic ( _STR("array index out of range: %d / %d", idx, a ->len) ) ;
 
 }
 ;
 
 memcpy ( a ->data + a ->element_size * idx ,  val ,  a ->element_size ) ;
 
 
 }
 void array__push(array* arr, void* val) {
 
 if ( arr ->len >= arr ->cap - 1 ) {
 /*if*/
 
int cap= (/*lpar*/ arr ->len + 1 ) * 2 ;
 
 if ( arr ->cap == 0 ) {
 /*if*/
 
 arr ->data  =  v_malloc ( cap * arr ->element_size ) ;
 
 }
  else { 
 /*else if*/
 
 arr ->data  =  realloc ( arr ->data ,  cap * arr ->element_size ) ;
 
 }
 ;
 
 arr ->cap  =  cap ;
 
 }
 ;
 
 memcpy ( arr ->data + arr ->element_size * arr ->len ,  val ,  arr ->element_size ) ;
 
 arr ->len ++ ;
 
 
 }
 void array__push_many(array* arr, void* val, int size) {
 
 if ( arr ->len >= arr ->cap - size ) {
 /*if*/
 
int cap= (/*lpar*/ arr ->len + size ) * 2 ;
 
 if ( arr ->cap == 0 ) {
 /*if*/
 
 arr ->data  =  v_malloc ( cap * arr ->element_size ) ;
 
 }
  else { 
 /*else if*/
 
 arr ->data  =  realloc ( arr ->data ,  cap * arr ->element_size ) ;
 
 }
 ;
 
 arr ->cap  =  cap ;
 
 }
 ;
 
 memcpy ( arr ->data + arr ->element_size * arr ->len ,  val ,  arr ->element_size * size ) ;
 
 arr ->len  =  arr ->len + size ;
 
 
 }
 string array_int_str(array_int a) {
 
string res= tos2("[") ;
 
 for (
int i= 0  ;  i < a .len  ;  i ++ ) { 
 
int val= ( *(int*) array__get( a , i) ) ;
 
 res  = string_add( res , _STR("%d", val) ) ;
 
 if ( i < a .len - 1 ) {
 /*if*/
 
 res  = string_add( res , tos2(", ") ) ;
 
 }
 ;
 
 }
 ;
 
 res  = string_add( res , tos2("]") ) ;

 
 return  res ;
 
 
 }
 void v_array_int_free(array_int a) {
 
 free ( a .data ) ;
 
 
 }
 string array_string_str(array_string a) {
 
string res= tos2("[") ;
 
 for (
int i= 0  ;  i < a .len  ;  i ++ ) { 
 
string val= ( *(string*) array__get( a , i) ) ;
 
 res  = string_add( res , _STR("\"%.*s\"", val.len, val.str) ) ;
 
 if ( i < a .len - 1 ) {
 /*if*/
 
 res  = string_add( res , tos2(", ") ) ;
 
 }
 ;
 
 }
 ;
 
 res  = string_add( res , tos2("]") ) ;

 
 return  res ;
 
 
 }
 void v_free(void* a) {
 
 free ( a ) ;
 
 
 }
 void todo() {
 
 
 }
 string tos(byte* s, int len) {
 
 if ( isnil ( s ) ) {
 /*if*/
 
 v_panic ( tos2("tos(): nil string") ) ;
 
 }
 ;

 
 return  (string) { .str =  s , .len =  len } ;
 
 
 }
 string tos_clone(byte* s) {
 
 if ( isnil ( s ) ) {
 /*if*/
 
 v_panic ( tos2("tos: nil string") ) ;

 
 return  (string) { .str = 0 , .len = 0 } ;
 
 }
 ;
 
int len= strlen ( s ) ;
 
string res= tos ( s , len ) ;

 
 return  string_clone( res ) ;
 
 
 }
 string tos2(byte* s) {
 
 if ( isnil ( s ) ) {
 /*if*/
 
 v_panic ( tos2("tos2: nil string") ) ;

 
 return  (string) { .str = 0 , .len = 0 } ;
 
 }
 ;
 
int len= strlen ( s ) ;
 
string res= tos ( s , len ) ;

 
 return  res ;
 
 
 }
 string string_clone(string a) {
 
string b= (string) { .len =  a .len , .str =  v_malloc ( a .len + 1 ) } ;
 
 for (
int i= 0  ;  i < a .len  ;  i ++ ) { 
 
 b .str[ i ]/*rbyte 1*/  =  a .str[ i ]/*rbyte 0*/ ;
 
 }
 ;
 
 b .str[ a .len ]/*rbyte 1*/  =  '\0' ;

 
 return  b ;
 
 
 }
 byte* string_cstr(string s) {
 
string clone= string_clone( s ) ;

 
 return  clone .str ;
 
 
 }
 string string_replace(string s, string rep, string with) {
 
 if ( s .len == 0  ||  rep .len == 0 ) {
 /*if*/

 
 return  s ;
 
 }
 ;
 
 if ( ! string_contains( s , rep ) ) {
 /*if*/

 
 return  s ;
 
 }
 ;
 
array_int idxs=new_array_from_c_array(0, 0, sizeof(int), (int[]) {   }) ;
 
 {
 
 }
 
 for (
int i= 0  ;  i < s .len  ;  i ++ ) { 
 
int rep_i= 0 ;
 
int j= i ;
 
 while ( rep_i < rep .len  &&  j < s .len  &&  s .str[ j ]/*rbyte 0*/ == rep .str[ rep_i ]/*rbyte 0*/ ) {
 
 rep_i ++ ;
 
 j ++ ;
 
 }
 ;
 
 if ( rep_i == rep .len ) {
 /*if*/
 
_PUSH(& idxs , ( i ), tmp12, int) ;
 
 }
 ;
 
 }
 ;
 
 if ( idxs .len == 0 ) {
 /*if*/

 
 return  s ;
 
 }
 ;
 
int new_len= s .len + idxs .len * (/*lpar*/ with .len - rep .len ) ;
 
byte* b= v_malloc ( new_len + 1 ) ;
 
int idx_pos= 0 ;
 
int cur_idx= ( *(int*) array__get( idxs , idx_pos) ) ;
 
int b_i= 0 ;
 
 for (
int i= 0  ;  i < s .len  ;  i ++ ) { 
 
 if ( i == cur_idx ) {
 /*if*/
 
 for (
int j= 0  ;  j < with .len  ;  j ++ ) { 
 
 b [/*ptr*/ b_i ]/*rbyte 1*/  =  with .str[ j ]/*rbyte 0*/ ;
 
 b_i ++ ;
 
 }
 ;
 
 i  =  i + rep .len - 1 ;
 
 idx_pos ++ ;
 
 if ( idx_pos < idxs .len ) {
 /*if*/
 
 cur_idx  =  ( *(int*) array__get( idxs , idx_pos) ) ;
 
 }
 ;
 
 }
  else { 
 /*else if*/
 
 b [/*ptr*/ b_i ]/*rbyte 1*/  =  s .str[ i ]/*rbyte 0*/ ;
 
 b_i ++ ;
 
 }
 ;
 
 }
 ;
 
 b [/*ptr*/ new_len ]/*rbyte 1*/  =  '\0' ;

 
 return  tos ( b , new_len ) ;
 
 
 }
 int string_int(string s) {

 
 return  atoi ( s .str ) ;
 
 
 }
 f32 string_f32(string s) {

 
 return  atof ( s .str ) ;
 
 
 }
 bool string_eq(string s, string a) {
 
 if ( isnil ( s .str ) ) {
 /*if*/
 
 v_panic ( tos2("string.eq(): nil string") ) ;
 
 }
 ;
 
 if ( s .len != a .len ) {
 /*if*/

 
 return  0 ;
 
 }
 ;
 
 for (
int i= 0  ;  i < s .len  ;  i ++ ) { 
 
 if ( s .str[ i ]/*rbyte 0*/ != a .str[ i ]/*rbyte 0*/ ) {
 /*if*/

 
 return  0 ;
 
 }
 ;
 
 }
 ;

 
 return  1 ;
 
 
 }
 bool string_ne(string s, string a) {

 
 return  ! string_eq( s , a ) ;
 
 
 }
 bool string_lt(string s, string a) {
 
 for (
int i= 0  ;  i < s .len  ;  i ++ ) { 
 
 if ( i >= a .len  ||  s .str[ i ]/*rbyte 0*/ > a .str[ i ]/*rbyte 0*/ ) {
 /*if*/

 
 return  0 ;
 
 }
  else  if ( s .str[ i ]/*rbyte 0*/ < a .str[ i ]/*rbyte 0*/ ) {
 /*if*/

 
 return  1 ;
 
 }
 ;
 
 }
 ;
 
 if ( s .len < a .len ) {
 /*if*/

 
 return  1 ;
 
 }
 ;

 
 return  0 ;
 
 
 }
 bool string_le(string s, string a) {

 
 return  string_lt( s , a )  ||  string_eq( s , a ) ;
 
 
 }
 bool string_gt(string s, string a) {

 
 return  ! string_le( s , a ) ;
 
 
 }
 bool string_ge(string s, string a) {

 
 return  ! string_lt( s , a ) ;
 
 
 }
 string string_add(string s, string a) {
 
int new_len= a .len + s .len ;
 
string res= (string) { .len =  new_len , .str =  v_malloc ( new_len + 1 ) } ;
 
 for (
int j= 0  ;  j < s .len  ;  j ++ ) { 
 
 res .str[ j ]/*rbyte 1*/  =  s .str[ j ]/*rbyte 0*/ ;
 
 }
 ;
 
 for (
int j= 0  ;  j < a .len  ;  j ++ ) { 
 
 res .str[ s .len + j ]/*rbyte 1*/  =  a .str[ j ]/*rbyte 0*/ ;
 
 }
 ;
 
 res .str[ new_len ]/*rbyte 1*/  =  '\0' ;

 
 return  res ;
 
 
 }
 array_string string_split(string s, string delim) {
 
array_string res=new_array_from_c_array(0, 0, sizeof(string), (string[]) {   }) ;
 
 if ( delim .len == 0 ) {
 /*if*/
 
_PUSH(& res , ( s ), tmp31, string) ;

 
 return  res ;
 
 }
 ;
 
 if ( delim .len == 1 ) {
 /*if*/

 
 return  string_split_single( s , delim .str[ 0 ]/*rbyte 0*/ ) ;
 
 }
 ;
 
int i= 0 ;
 
int start= 0 ;
 
 while ( i < s .len ) {
 
bool a= s .str[ i ]/*rbyte 0*/ == delim .str[ 0 ]/*rbyte 0*/ ;
 
int j= 1 ;
 
 while ( j < delim .len  &&  a ) {
 
 a  =  a  &&  s .str[ i + j ]/*rbyte 0*/ == delim .str[ j ]/*rbyte 0*/ ;
 
 j ++ ;
 
 }
 ;
 
bool last= i == s .len - 1 ;
 
 if ( a  ||  last ) {
 /*if*/
 
 if ( last ) {
 /*if*/
 
 i ++ ;
 
 }
 ;
 
string val= string_substr( s , start , i ) ;
 
 if ( val .len > 0 ) {
 /*if*/
 
 if ( string_starts_with( val , delim ) ) {
 /*if*/
 
 val  =  string_right( val , delim .len ) ;
 
 }
 ;
 
_PUSH(& res , ( string_trim_space( val ) ), tmp38, string) ;
 
 }
 ;
 
 start  =  i ;
 
 }
 ;
 
 i ++ ;
 
 }
 ;

 
 return  res ;
 
 
 }
 array_string string_split_single(string s, byte delim) {
 
array_string res=new_array_from_c_array(0, 0, sizeof(string), (string[]) {   }) ;
 
 if ( ((int)( delim ) ) == 0 ) {
 /*if*/
 
_PUSH(& res , ( s ), tmp40, string) ;

 
 return  res ;
 
 }
 ;
 
int i= 0 ;
 
int start= 0 ;
 
 while ( i < s .len ) {
 
bool a= s .str[ i ]/*rbyte 0*/ == delim ;
 
bool b= i == s .len - 1 ;
 
 if ( a  ||  b ) {
 /*if*/
 
 if ( i == s .len - 1 ) {
 /*if*/
 
 i ++ ;
 
 }
 ;
 
string val= string_substr( s , start , i ) ;
 
 if ( val .len > 0 ) {
 /*if*/
 
_PUSH(& res , ( string_trim_space( val ) ), tmp46, string) ;
 
 }
 ;
 
 start  =  i + 1 ;
 
 }
 ;
 
 i ++ ;
 
 }
 ;

 
 return  res ;
 
 
 }
 array_string string_split_into_lines(string s) {
 
array_string res=new_array_from_c_array(0, 0, sizeof(string), (string[]) {   }) ;
 
 if ( s .len == 0 ) {
 /*if*/

 
 return  res ;
 
 }
 ;
 
int start= 0 ;
 
 for (
int i= 0  ;  i < s .len  ;  i ++ ) { 
 
bool last= i == s .len - 1 ;
 
 if ( ((int)( s .str[ i ]/*rbyte 0*/ ) ) == 10  ||  last ) {
 /*if*/
 
 if ( last ) {
 /*if*/
 
 i ++ ;
 
 }
 ;
 
string line= string_substr( s , start , i ) ;
 
_PUSH(& res , ( line ), tmp52, string) ;
 
 start  =  i + 1 ;
 
 }
 ;
 
 }
 ;

 
 return  res ;
 
 
 }
 string string_left(string s, int n) {
 
 if ( n >= s .len ) {
 /*if*/

 
 return  s ;
 
 }
 ;

 
 return  string_substr( s , 0 , n ) ;
 
 
 }
 string string_right(string s, int n) {
 
 if ( n >= s .len ) {
 /*if*/

 
 return  tos2("") ;
 
 }
 ;

 
 return  string_substr( s , n , s .len ) ;
 
 
 }
 string string_substr(string s, int start, int end) {
 
 if ( start >= s .len ) {
 /*if*/

 
 return  tos2("") ;
 
 }
 ;
 
int len= end - start ;
 
string res= (string) { .str =  s .str + start , .len =  len } ;

 
 return  res ;
 
 
 }
 int string_index(string s, string p) {
 
 if ( p .len > s .len ) {
 /*if*/

 
 return  - 1 ;
 
 }
 ;
 
array_int prefix=new_array_from_c_array(1, 1, sizeof(int), (int[]) {  0  }) ;
 
int j= 0 ;
 
 for (
int i= 1  ;  i < p .len  ;  i ++ ) { 
 
 while ( p .str[ j ]/*rbyte 0*/ != p .str[ i ]/*rbyte 0*/  &&  j > 0 ) {
 
 j  =  ( *(int*) array__get( prefix , j - 1) ) ;
 
 }
 ;
 
 if ( p .str[ j ]/*rbyte 0*/ == p .str[ i ]/*rbyte 0*/ ) {
 /*if*/
 
 j ++ ;
 
 }
 ;
 
_PUSH(& prefix , ( j ), tmp60, int) ;
 
 }
 ;
 
 j  =  0 ;
 
 for (
int i= 0  ;  i < s .len  ;  i ++ ) { 
 
 while ( p .str[ j ]/*rbyte 0*/ != s .str[ i ]/*rbyte 0*/  &&  j > 0 ) {
 
 j  =  ( *(int*) array__get( prefix , j - 1) ) ;
 
 }
 ;
 
 if ( p .str[ j ]/*rbyte 0*/ == s .str[ i ]/*rbyte 0*/ ) {
 /*if*/
 
 j ++ ;
 
 }
 ;
 
 if ( j == p .len ) {
 /*if*/
 
 v_array_int_free( prefix ) ;

 
 return  i - p .len + 1 ;
 
 }
 ;
 
 }
 ;
 
 v_array_int_free( prefix ) ;

 
 return  - 1 ;
 
 
 }
 int string_last_index(string s, string p) {
 
 if ( p .len > s .len ) {
 /*if*/

 
 return  - 1 ;
 
 }
 ;
 
int i= s .len - p .len ;
 
 while ( i >= 0 ) {
 
int j= 0 ;
 
 while ( j < p .len  &&  s .str[ i + j ]/*rbyte 0*/ == p .str[ j ]/*rbyte 0*/ ) {
 
 j ++ ;
 
 }
 ;
 
 if ( j == p .len ) {
 /*if*/

 
 return  i ;
 
 }
 ;
 
 i -- ;
 
 }
 ;

 
 return  - 1 ;
 
 
 }
 int string_index_after(string s, string p, int start) {
 
 if ( p .len > s .len ) {
 /*if*/

 
 return  - 1 ;
 
 }
 ;
 
int strt= start ;
 
 if ( start < 0 ) {
 /*if*/
 
 strt  =  0 ;
 
 }
 ;
 
 if ( start >= s .len ) {
 /*if*/

 
 return  - 1 ;
 
 }
 ;
 
int i= strt ;
 
 while ( i < s .len ) {
 
int j= 0 ;
 
int ii= i ;
 
 while ( j < p .len  &&  s .str[ ii ]/*rbyte 0*/ == p .str[ j ]/*rbyte 0*/ ) {
 
 j ++ ;
 
 ii ++ ;
 
 }
 ;
 
 if ( j == p .len ) {
 /*if*/

 
 return  i ;
 
 }
 ;
 
 i ++ ;
 
 }
 ;

 
 return  - 1 ;
 
 
 }
 bool string_contains(string s, string p) {
 
bool res= string_index( s , p ) > 0 - 1 ;

 
 return  res ;
 
 
 }
 bool string_starts_with(string s, string p) {
 
bool res= string_index( s , p ) == 0 ;

 
 return  res ;
 
 
 }
 bool string_ends_with(string s, string p) {
 
 if ( p .len > s .len ) {
 /*if*/

 
 return  0 ;
 
 }
 ;
 
bool res= string_last_index( s , p ) == s .len - p .len ;

 
 return  res ;
 
 
 }
 string string_to_lower(string s) {
 
byte* b= v_malloc ( s .len ) ;
 
 for (
int i= 0  ;  i < s .len  ;  i ++ ) { 
 
 b [/*ptr*/ i ]/*rbyte 1*/  =  tolower ( s .str [/*ptr*/ i ]/*rbyte 0*/ ) ;
 
 }
 ;

 
 return  tos ( b , s .len ) ;
 
 
 }
 string string_to_upper(string s) {
 
byte* b= v_malloc ( s .len ) ;
 
 for (
int i= 0  ;  i < s .len  ;  i ++ ) { 
 
 b [/*ptr*/ i ]/*rbyte 1*/  =  toupper ( s .str [/*ptr*/ i ]/*rbyte 0*/ ) ;
 
 }
 ;

 
 return  tos ( b , s .len ) ;
 
 
 }
 string string_find_between(string s, string start, string end) {
 
int start_pos= string_index( s , start ) ;
 
 if ( start_pos == - 1 ) {
 /*if*/

 
 return  tos2("") ;
 
 }
 ;
 
string val= string_right( s , start_pos + start .len ) ;
 
int end_pos= string_index( val , end ) ;
 
 if ( end_pos == - 1 ) {
 /*if*/

 
 return  val ;
 
 }
 ;

 
 return  string_left( val , end_pos ) ;
 
 
 }
 bool array_string_contains(array_string ar, string val) {
 
 array_string tmp80 =  ar;
 ;
for (int tmp81 = 0; tmp81 < tmp80 .len; tmp81 ++) {
 string s = ((string *) tmp80.data)[tmp81];
 
 if (string_eq( s , val ) ) {
 /*if*/

 
 return  1 ;
 
 }
 ;
 
 }
 ;

 
 return  0 ;
 
 
 }
 bool array_int_contains(array_int ar, int val) {
 
 array_int tmp82 =  ar ;
 ;
for (int i = 0; i < tmp82 .len; i ++) {
 int s = ((int *) tmp82 . data)[i];
 
 if ( s == val ) {
 /*if*/

 
 return  1 ;
 
 }
 ;
 
 }
 ;

 
 return  0 ;
 
 
 }
 bool is_space(byte c) {

 
 return  isspace ( c ) ;
 
 
 }
 bool byte_is_space(byte c) {

 
 return  is_space ( c ) ;
 
 
 }
 string string_trim_space(string s) {
 
 if (string_eq( s , tos2("") ) ) {
 /*if*/

 
 return  tos2("") ;
 
 }
 ;
 
int i= 0 ;
 
 while ( i < s .len  &&  is_space ( s .str[ i ]/*rbyte 0*/ ) ) {
 
 i ++ ;
 
 }
 ;
 
string res= string_right( s , i ) ;
 
int end= res .len - 1 ;
 
 while ( end >= 0  &&  is_space ( res .str[ end ]/*rbyte 1*/ ) ) {
 
 end -- ;
 
 }
 ;
 
 res  =  string_left( res , end + 1 ) ;

 
 return  res ;
 
 
 }
 string string_trim(string s, byte c) {
 
 if (string_eq( s , tos2("") ) ) {
 /*if*/

 
 return  tos2("") ;
 
 }
 ;
 
int i= 0 ;
 
 while ( i < s .len  &&  c == s .str[ i ]/*rbyte 0*/ ) {
 
 i ++ ;
 
 }
 ;
 
string res= string_right( s , i ) ;
 
int end= res .len - 1 ;
 
 while ( end >= 0  &&  c == res .str[ end ]/*rbyte 1*/ ) {
 
 end -- ;
 
 }
 ;
 
 res  =  string_left( res , end + 1 ) ;

 
 return  res ;
 
 
 }
 string string_trim_left(string s, string cutset) {
 
int start= string_index( s , cutset ) ;
 
 if ( start != 0 ) {
 /*if*/

 
 return  s ;
 
 }
 ;
 
 while ( start < s .len - 1  &&  s .str[ start ]/*rbyte 0*/ == cutset .str[ 0 ]/*rbyte 0*/ ) {
 
 start ++ ;
 
 }
 ;

 
 return  string_right( s , start ) ;
 
 
 }
 string string_trim_right(string s, string cutset) {
 
int pos= string_last_index( s , cutset ) ;
 
 if ( pos == - 1 ) {
 /*if*/

 
 return  s ;
 
 }
 ;

 
 return  string_left( s , pos ) ;
 
 
 }
 int compare_strings(string* a, string* b) {
 
 if ( string_lt(* a ,* b ) ) {
 /*if*/

 
 return  - 1 ;
 
 }
 ;
 
 if ( string_gt(* a ,* b ) ) {
 /*if*/

 
 return  1 ;
 
 }
 ;

 
 return  0 ;
 
 
 }
 int compare_strings_by_len(string* a, string* b) {
 
 if ( a ->len < b ->len ) {
 /*if*/

 
 return  - 1 ;
 
 }
 ;
 
 if ( a ->len > b ->len ) {
 /*if*/

 
 return  1 ;
 
 }
 ;

 
 return  0 ;
 
 
 }
 int compare_lower_strings(string* a, string* b) {
 
string aa= string_to_lower(* a ) ;
 
string bb= string_to_lower(* b ) ;

 
 return  compare_strings (& /*11 EXP:"string*" GOT:"string" */ aa ,& /*11 EXP:"string*" GOT:"string" */ bb ) ;
 
 
 }
 void array_string_sort(array_string* s) {
 
 array_sort_with_compare( s , compare_strings ) ;
 
 
 }
 void array_string_sort_ignore_case(array_string* s) {
 
 array_sort_with_compare( s , compare_lower_strings ) ;
 
 
 }
 void array_string_sort_by_len(array_string* s) {
 
 array_sort_with_compare( s , compare_strings_by_len ) ;
 
 
 }
 ustring string_ustring(string s) {
 
ustring res= (ustring) { .s =  s , .runes =  new_array ( 0 , s .len , sizeof( int) ) , .len = 0 } ;
 
 for (
int i= 0  ;  i < s .len  ;  i ++ ) { 
 
int char_len= utf8_char_len ( s .str [/*ptr*/ i ]/*rbyte 0*/ ) ;
 
_PUSH(& res .runes , ( i ), tmp96, int) ;
 
 i  =  i + char_len - 1 ;
 
 res .len ++ ;
 
 }
 ;

 
 return  res ;
 
 
 }
 ustring string_ustring_tmp(string s) {
 
ustring res= (ustring) { .s =  s , .runes =  0 , .len = 0 } ;
 
 res .runes  =  g_ustring_runes ;
 
 res .runes .len  =  s .len ;
 
int j= 0 ;
 
 for (
int i= 0  ;  i < s .len  ;  i ++ ) { 
 
int char_len= utf8_char_len ( s .str [/*ptr*/ i ]/*rbyte 0*/ ) ;
int tmp101 =  i;
 
array_set(&/*q*/ res .runes , j , & tmp101) ;
 
 j ++ ;
 
 i  =  i + char_len - 1 ;
 
 res .len ++ ;
 
 }
 ;

 
 return  res ;
 
 
 }
 string ustring_substr(ustring u, int start, int end) {
 
 start  =  ( *(int*) array__get( u .runes , start) ) ;
 
 if ( end >= u .runes .len ) {
 /*if*/
 
 end  =  u .s .len ;
 
 }
  else { 
 /*else if*/
 
 end  =  ( *(int*) array__get( u .runes , end) ) ;
 
 }
 ;

 
 return  string_substr( u .s , start , end ) ;
 
 
 }
 string ustring_left(ustring u, int pos) {

 
 return  ustring_substr( u , 0 , pos ) ;
 
 
 }
 string ustring_right(ustring u, int pos) {

 
 return  ustring_substr( u , pos , u .len ) ;
 
 
 }
 byte string_at(string s, int idx) {
 
 if ( idx < 0  ||  idx >= s .len ) {
 /*if*/
 
 v_panic ( _STR("string index out of range: %d / %d", idx, s .len) ) ;
 
 }
 ;

 
 return  s .str [/*ptr*/ idx ]/*rbyte 0*/ ;
 
 
 }
 string ustring_at(ustring u, int idx) {

 
 return  ustring_substr( u , idx , idx + 1 ) ;
 
 
 }
 void v_ustring_free(ustring u) {
 
 v_array_int_free( u .runes ) ;
 
 
 }
 int abs(int a) {
 
 if ( a >= 0 ) {
 /*if*/

 
 return  a ;
 
 }
 ;

 
 return  - a ;
 
 
 }
 bool byte_is_digit(byte c) {

 
 return  c >= '0'  &&  c <= '9' ;
 
 
 }
 bool byte_is_letter(byte c) {

 
 return  (/*lpar*/ c >= 'a'  &&  c <= 'z' )  ||  (/*lpar*/ c >= 'A'  &&  c <= 'Z' ) ;
 
 
 }
 void v_string_free(string s) {
 
 free ( s .str ) ;
 
 
 }
 void v_array_string_free(array_string arr) {
 
 array_string tmp106 =  arr;
 ;
for (int tmp107 = 0; tmp107 < tmp106 .len; tmp107 ++) {
 string s = ((string *) tmp106.data)[tmp107];
 
 v_string_free( s ) ;
 
 }
 ;
 
 free ( arr .data ) ;
 
 
 }
 string string_all_before(string s, string dot) {
 
int pos= string_index( s , dot ) ;
 
 if ( pos == - 1 ) {
 /*if*/

 
 return  s ;
 
 }
 ;

 
 return  string_left( s , pos ) ;
 
 
 }
 string string_all_before_last(string s, string dot) {
 
int pos= string_last_index( s , dot ) ;
 
 if ( pos == - 1 ) {
 /*if*/

 
 return  s ;
 
 }
 ;

 
 return  string_left( s , pos ) ;
 
 
 }
 string string_all_after(string s, string dot) {
 
int pos= string_last_index( s , dot ) ;
 
 if ( pos == - 1 ) {
 /*if*/

 
 return  s ;
 
 }
 ;

 
 return  string_right( s , pos + dot .len ) ;
 
 
 }
 string array_string_join(array_string a, string del) {
 
 if ( a .len == 0 ) {
 /*if*/

 
 return  tos2("") ;
 
 }
 ;
 
int len= 0 ;
 
 array_string tmp112 =  a ;
 ;
for (int i = 0; i < tmp112 .len; i ++) {
 string val = ((string *) tmp112 . data)[i];
 
 len  =  len + val .len + del .len ;
 
 }
 ;
 
 len  =  len - del .len ;
 
string res= tos2("") ;
 
 res .len  =  len ;
 
 res .str  =  v_malloc ( res .len + 1 ) ;
 
int idx= 0 ;
 
 array_string tmp115 =  a ;
 ;
for (int i = 0; i < tmp115 .len; i ++) {
 string val = ((string *) tmp115 . data)[i];
 
 for (
int j= 0  ;  j < val .len  ;  j ++ ) { 
 
byte c= val .str[ j ]/*rbyte 0*/ ;
 
 res .str [/*ptr*/ idx ]/*rbyte 1*/  =  val .str [/*ptr*/ j ]/*rbyte 0*/ ;
 
 idx ++ ;
 
 }
 ;
 
 if ( i != a .len - 1 ) {
 /*if*/
 
 for (
int k= 0  ;  k < del .len  ;  k ++ ) { 
 
 res .str [/*ptr*/ idx ]/*rbyte 1*/  =  del .str [/*ptr*/ k ]/*rbyte 0*/ ;
 
 idx ++ ;
 
 }
 ;
 
 }
 ;
 
 }
 ;
 
 res .str [/*ptr*/ res .len ]/*rbyte 1*/  =  '\0' ;

 
 return  res ;
 
 
 }
 string array_string_join_lines(array_string s) {

 
 return  array_string_join( s , tos2("\n") ) ;
 
 
 }
 string string_reverse(string s) {
 
string res= (string) { .len =  s .len , .str =  v_malloc ( s .len + 1 ) } ;
 
 for (
int i= s .len - 1  ;  i >= 0  ;  i -- ) { 
 
 res .str[ s .len - i - 1 ]/*rbyte 1*/  =  s .str[ i ]/*rbyte 0*/ ;
 
 }
 ;

 
 return  res ;
 
 
 }
 string string_limit(string s, int max) {
 
ustring u= string_ustring( s ) ;
 
 if ( u .len <= max ) {
 /*if*/

 
 return  s ;
 
 }
 ;

 
 return  ustring_substr( u , 0 , max ) ;
 
 
 }
 bool byte_is_white(byte c) {
 
int i= ((int)( c ) ) ;

 
 return  i == 10  ||  i == 32  ||  i == 9  ||  i == 13  ||  c == '\r' ;
 
 
 }
 string repeat_char(byte c, int n) {
 
 if ( n <= 0 ) {
 /*if*/

 
 return  tos2("") ;
 
 }
 ;
 
byte* arr= v_malloc ( n + 1 ) ;
 
 for (
int i= 0  ;  i < n  ;  i ++ ) { 
 
 arr [/*ptr*/ i ]/*rbyte 1*/  =  c ;
 
 }
 ;
 
 arr [/*ptr*/ n ]/*rbyte 1*/  =  '\0' ;

 
 return  tos ( arr , n ) ;
 
 
 }
 int string_hash(string s) {
 
int hash= ((int)( 0 ) ) ;
 
 for (
int i= 0  ;  i < s .len  ;  i ++ ) { 
 
 hash  =  hash * ((int)( 31 ) ) + ((int)( s .str [/*ptr*/ i ]/*rbyte 0*/ ) ) ;
 
 }
 ;

 
 return  hash ;
 
 
 }
 bool string_is_empty(string s) {

 
 return  s .len == 0 ;
 
 
 }
 void v_exit(int code) {
 
 exit ( code ) ;
 
 
 }
 bool isnil(void* v) {

 
 return  v == 0 ;
 
 
 }
 void on_panic(int (*f)( int  /*FFF*/ )) {
 
 
 }
 void print_backtrace() {

 
 return  ;
 
 #ifdef __APPLE__
 
voidptr buffer  [100 ]= {} /* arkek init*/ ;
 
void* nr_ptrs= backtrace ( buffer ,  100 ) ;
 
 backtrace_symbols_fd ( buffer ,  nr_ptrs ,  1 ) ;
 
 #endif
 ;
 
 
 }
 void v_panic(string s) {
 
 println ( _STR("V panic: %.*s", s.len, s.str) ) ;
 
 print_backtrace ( ) ;
 
 exit ( 1 ) ;
 
 
 }
 void println(string s) {
 
 if ( isnil ( s .str ) ) {
 /*if*/
 
 v_panic ( tos2("println(NIL)") ) ;
 
 }
 ;
 
 printf ( "%.*s\n" ,  s .len ,  s .str ) ;
 
 
 }
 void eprintln(string s) {
 
 if ( isnil ( s .str ) ) {
 /*if*/
 
 v_panic ( tos2("eprintln(NIL)") ) ;
 
 }
 ;
 
 #ifdef __APPLE__
 
 fprintf ( stderr ,  "%.*s\n" ,  s .len ,  s .str ) ;
 
 ;
 
 #else
 
 println ( s ) ;
 
 #endif
 ;
 
 
 }
 void v_print(string s) {
 
 printf ( "%.*s" ,  s .len ,  s .str ) ;
 
 
 }
 byte* v_malloc(int n) {
 
 if ( n < 0 ) {
 /*if*/
 
 v_panic ( tos2("malloc(<0)") ) ;
 
 }
 ;
 
byte* ptr= malloc ( n ) ;
 
 if ( isnil ( ptr ) ) {
 /*if*/
 
 v_panic ( _STR("malloc(%d) failed", n) ) ;
 
 }
 ;

 
 return  ptr ;
 
 
 }
 byte* v_calloc(int n) {
 
 if ( n < 0 ) {
 /*if*/
 
 v_panic ( tos2("calloc(<0)") ) ;
 
 }
 ;

 
 return  calloc ( n ,  1 ) ;
 
 
 }
 int _strlen(byte* s) {

 
 return  strlen ( s ) ;
 
 
 }
 Option opt_ok(void* data) {

 
 return  (Option) { .data =  data , .ok =  1 , .error = tos("", 0) , } ;
 
 
 }
 void* memdup(void* src, int sz) {
 
byte* mem= v_malloc ( sz ) ;

 
 return  memcpy ( mem ,  src ,  sz ) ;
 
 
 }
 Option v_error(string s) {

 
 return  (Option) { .error =  s , .data = 0 , .ok = 0 } ;
 
 
 }
 string double_str(double d) {
 
byte* buf= v_malloc ( sizeof( double) * 5 + 1 ) ;
 
 sprintf ( buf ,  "%f" ,  d ) ;

 
 return  tos ( buf , _strlen ( buf ) ) ;
 
 
 }
 string f64_str(f64 d) {
 
byte* buf= v_malloc ( sizeof( double) * 5 + 1 ) ;
 
 sprintf ( buf ,  "%f" ,  d ) ;

 
 return  tos ( buf , _strlen ( buf ) ) ;
 
 
 }
 string f32_str(f32 d) {
 
byte* buf= v_malloc ( sizeof( double) * 5 + 1 ) ;
 
 sprintf ( buf ,  "%f" ,  d ) ;

 
 return  tos ( buf , _strlen ( buf ) ) ;
 
 
 }
 string ptr_str(void* ptr) {
 
byte* buf= v_malloc ( sizeof( double) * 5 + 1 ) ;
 
 sprintf ( buf ,  "%p" ,  ptr ) ;

 
 return  tos ( buf , _strlen ( buf ) ) ;
 
 
 }
 string int_str(int nn) {
 
int n= nn ;
 
 if ( n == 0 ) {
 /*if*/

 
 return  tos2("0") ;
 
 }
 ;
 
int max= 16 ;
 
byte* buf= v_malloc ( max ) ;
 
int len= 0 ;
 
bool is_neg= 0 ;
 
 if ( n < 0 ) {
 /*if*/
 
 n  =  - n ;
 
 is_neg  =  1 ;
 
 }
 ;
 
 while ( n > 0 ) {
 
int d= n % 10 ;
 
 buf [/*ptr*/ max - len - 1 ]/*rbyte 1*/  =  d + ((int)( '0' ) ) ;
 
 len ++ ;
 
 n  =  n / 10 ;
 
 }
 ;
 
 if ( is_neg ) {
 /*if*/
 
 buf [/*ptr*/ max - len - 1 ]/*rbyte 1*/  =  '-' ;
 
 len ++ ;
 
 }
 ;

 
 return  tos ( buf + max - len , len ) ;
 
 
 }
 string u8_str(u8 nn) {
 
u8 n= nn ;
 
 if ( n == ((u8)( 0 ) ) ) {
 /*if*/

 
 return  tos2("0") ;
 
 }
 ;
 
int max= 5 ;
 
byte* buf= v_malloc ( max ) ;
 
int len= 0 ;
 
bool is_neg= 0 ;
 
 if ( n < ((u8)( 0 ) ) ) {
 /*if*/
 
 n  =  - n ;
 
 is_neg  =  1 ;
 
 }
 ;
 
 while ( n > ((u8)( 0 ) ) ) {
 
u8 d= n % ((u8)( 10 ) ) ;
 
 buf [/*ptr*/ max - len - 1 ]/*rbyte 1*/  =  d + ((u8)( '0' ) ) ;
 
 len ++ ;
 
 n  =  n / ((u8)( 10 ) ) ;
 
 }
 ;
 
 if ( is_neg ) {
 /*if*/
 
 buf [/*ptr*/ max - len - 1 ]/*rbyte 1*/  =  '-' ;
 
 len ++ ;
 
 }
 ;

 
 return  tos ( buf + max - len , len ) ;
 
 
 }
 string i64_str(i64 nn) {
 
i64 n= nn ;
 
 if ( n == ((i64)( 0 ) ) ) {
 /*if*/

 
 return  tos2("0") ;
 
 }
 ;
 
int max= 32 ;
 
byte* buf= v_malloc ( max ) ;
 
int len= 0 ;
 
bool is_neg= 0 ;
 
 if ( n < ((i64)( 0 ) ) ) {
 /*if*/
 
 n  =  - n ;
 
 is_neg  =  1 ;
 
 }
 ;
 
 while ( n > ((i64)( 0 ) ) ) {
 
int d= ((int)( n % ((i64)( 10 ) ) ) ) ;
 
 buf [/*ptr*/ max - len - 1 ]/*rbyte 1*/  =  d + ((int)( '0' ) ) ;
 
 len ++ ;
 
 n  =  n / ((i64)( 10 ) ) ;
 
 }
 ;
 
 if ( is_neg ) {
 /*if*/
 
 buf [/*ptr*/ max - len - 1 ]/*rbyte 1*/  =  '-' ;
 
 len ++ ;
 
 }
 ;

 
 return  tos ( buf + max - len , len ) ;
 
 
 }
 string bool_str(bool b) {
 
 if ( b ) {
 /*if*/

 
 return  tos2("true") ;
 
 }
 ;

 
 return  tos2("false") ;
 
 
 }
 string int_hex(int n) {
 
string s= int_str( n ) ;
 
byte* hex= v_malloc ( s .len + 3 ) ;
 
 sprintf ( hex ,  "0x%x" ,  n ) ;

 
 return  tos ( hex , s .len + 3 ) ;
 
 
 }
 string i64_hex(i64 n) {
 
string s= i64_str( n ) ;
 
byte* hex= v_malloc ( s .len + 3 ) ;
 
 sprintf ( hex ,  "0x%x" ,  n ) ;

 
 return  tos ( hex , s .len + 3 ) ;
 
 
 }
 bool array_byte_contains(array_byte a, byte val) {
 
 array_byte tmp27 =  a;
 ;
for (int tmp28 = 0; tmp28 < tmp27 .len; tmp28 ++) {
 byte aa = ((byte *) tmp27.data)[tmp28];
 
 if ( aa == val ) {
 /*if*/

 
 return  1 ;
 
 }
 ;
 
 }
 ;

 
 return  0 ;
 
 
 }
 string byte_str(byte c) {
 
string str= (string) { .len =  1 , .str =  v_malloc ( 2 ) } ;
 
 str .str [/*ptr*/ 0 ]/*rbyte 1*/  =  c ;
 
 str .str [/*ptr*/ 1 ]/*rbyte 1*/  =  '\0' ;

 
 return  str ;
 
 
 }
 int utf8_char_len(byte b) {

 
 return  (/*lpar*/ (/*lpar*/ 0xe5000000  >>  (/*lpar*/ (/*lpar*/ b  >>  3 ) & 0x1e ) ) & 3 ) + 1 ;
 
 
 }
 string utf32_to_str(u32 code) {
 
int icode= ((int)( code ) ) ;
 
byte* buffer= v_malloc ( 5 ) ;
 
 if ( icode <= 127 ) {
 /*if*/
 
 buffer [/*ptr*/ 0 ]/*rbyte 1*/  =  icode ;

 
 return  tos ( buffer , 1 ) ;
 
 }
 ;
 
 if ( (/*lpar*/ icode <= 2047 ) ) {
 /*if*/
 
 buffer [/*ptr*/ 0 ]/*rbyte 1*/  =  192 | (/*lpar*/ icode  >>  6 ) ;
 
 buffer [/*ptr*/ 1 ]/*rbyte 1*/  =  128 | (/*lpar*/ icode & 63 ) ;

 
 return  tos ( buffer , 2 ) ;
 
 }
 ;
 
 if ( (/*lpar*/ icode <= 65535 ) ) {
 /*if*/
 
 buffer [/*ptr*/ 0 ]/*rbyte 1*/  =  224 | (/*lpar*/ icode  >>  12 ) ;
 
 buffer [/*ptr*/ 1 ]/*rbyte 1*/  =  128 | (/*lpar*/ (/*lpar*/ icode  >>  6 ) & 63 ) ;
 
 buffer [/*ptr*/ 2 ]/*rbyte 1*/  =  128 | (/*lpar*/ icode & 63 ) ;

 
 return  tos ( buffer , 3 ) ;
 
 }
 ;
 
 if ( (/*lpar*/ icode <= 1114111 ) ) {
 /*if*/
 
 buffer [/*ptr*/ 0 ]/*rbyte 1*/  =  240 | (/*lpar*/ icode  >>  18 ) ;
 
 buffer [/*ptr*/ 1 ]/*rbyte 1*/  =  128 | (/*lpar*/ (/*lpar*/ icode  >>  12 ) & 63 ) ;
 
 buffer [/*ptr*/ 2 ]/*rbyte 1*/  =  128 | (/*lpar*/ (/*lpar*/ icode  >>  6 ) & 63 ) ;
 
 buffer [/*ptr*/ 3 ]/*rbyte 1*/  =  128 | (/*lpar*/ icode & 63 ) ;

 
 return  tos ( buffer , 4 ) ;
 
 }
 ;

 
 return  tos2("") ;
 
 
 }
 string utf32_to_str_no_malloc(u32 code, void* buf) {
 
int icode= ((int)( code ) ) ;
 
byteptr buffer= ((byteptr)( buf ) ) ;
 
 if ( icode <= 127 ) {
 /*if*/
 
 buffer [/*ptr*/ 0 ]/*rbyteptr 1*/  =  icode ;

 
 return  tos (& /*11 EXP:"byte*" GOT:"byteptr" */ buffer , 1 ) ;
 
 }
 ;
 
 if ( (/*lpar*/ icode <= 2047 ) ) {
 /*if*/
 
 buffer [/*ptr*/ 0 ]/*rbyteptr 1*/  =  192 | (/*lpar*/ icode  >>  6 ) ;
 
 buffer [/*ptr*/ 1 ]/*rbyteptr 1*/  =  128 | (/*lpar*/ icode & 63 ) ;

 
 return  tos (& /*11 EXP:"byte*" GOT:"byteptr" */ buffer , 2 ) ;
 
 }
 ;
 
 if ( (/*lpar*/ icode <= 65535 ) ) {
 /*if*/
 
 buffer [/*ptr*/ 0 ]/*rbyteptr 1*/  =  224 | (/*lpar*/ icode  >>  12 ) ;
 
 buffer [/*ptr*/ 1 ]/*rbyteptr 1*/  =  128 | (/*lpar*/ (/*lpar*/ icode  >>  6 ) & 63 ) ;
 
 buffer [/*ptr*/ 2 ]/*rbyteptr 1*/  =  128 | (/*lpar*/ icode & 63 ) ;

 
 return  tos (& /*11 EXP:"byte*" GOT:"byteptr" */ buffer , 3 ) ;
 
 }
 ;
 
 if ( (/*lpar*/ icode <= 1114111 ) ) {
 /*if*/
 
 buffer [/*ptr*/ 0 ]/*rbyteptr 1*/  =  240 | (/*lpar*/ icode  >>  18 ) ;
 
 buffer [/*ptr*/ 1 ]/*rbyteptr 1*/  =  128 | (/*lpar*/ (/*lpar*/ icode  >>  12 ) & 63 ) ;
 
 buffer [/*ptr*/ 2 ]/*rbyteptr 1*/  =  128 | (/*lpar*/ (/*lpar*/ icode  >>  6 ) & 63 ) ;
 
 buffer [/*ptr*/ 3 ]/*rbyteptr 1*/  =  128 | (/*lpar*/ icode & 63 ) ;

 
 return  tos (& /*11 EXP:"byte*" GOT:"byteptr" */ buffer , 4 ) ;
 
 }
 ;

 
 return  tos2("") ;
 
 
 }
 int string_utf32_code(string _rune) {
 
 if ( _rune .len == 0 ) {
 /*if*/

 
 return  0 ;
 
 }
 ;
 
 if ( _rune .len == 1 ) {
 /*if*/

 
 return  ((int)( _rune .str[ 0 ]/*rbyte 0*/ ) ) ;
 
 }
 ;
 
byte b= ((byte)( ((int)( _rune .str[ 0 ]/*rbyte 0*/ ) ) ) ) ;
 
 b  =  b  <<  _rune .len ;
 
int res= ((int)( b ) ) ;
 
int shift= 6 - _rune .len ;
 
 for (
int i= 1  ;  i < _rune .len  ;  i ++ ) { 
 
int c= ((int)( _rune .str[ i ]/*rbyte 0*/ ) ) ;
 
 res  =  res  <<  shift ;
 
 res  =  res | c & 63 ;
 
 shift  =  6 ;
 
 }
 ;

 
 return  res ;
 
 
 }
 map new_map(int cap, int elm_size) {
 
map res= (map) { .element_size =  elm_size , .entries = new_array(0, 1, sizeof(Entry)) , .is_sorted = 0 } ;

 
 return  res ;
 
 
 }
 Entry map_new_entry(map* m, string key, void* val) {
 
Entry new_e= (Entry) { .key =  key , .val =  v_malloc ( m ->element_size ) } ;
 
 memcpy ( new_e .val ,  val ,  m ->element_size ) ;

 
 return  new_e ;
 
 
 }
 void map__set(map* m, string key, void* val) {
 
Entry e= map_new_entry(& /* ? */* m , key , val ) ;
 
 for (
int i= 0  ;  i < m ->entries .len  ;  i ++ ) { 
 
Entry entry= ( *(Entry*) array__get( m ->entries , i) ) ;
 
 if (string_eq( entry .key , key ) ) {
 /*if*/
Entry tmp8 =  e;
 
array_set(&/*q*/ m ->entries , i , & tmp8) ;

 
 return  ;
 
 }
 ;
 
 }
 ;
 
_PUSH(& m ->entries , ( e ), tmp9, Entry) ;
 
 m ->is_sorted  =  0 ;
 
 
 }
 int volt_abs(int n) {
 
 if ( n < 0 ) {
 /*if*/

 
 return  - n ;
 
 }
 ;

 
 return  n ;
 
 
 }
 void map_bs(map m, string query, int start, int end, void* out) {
 
int mid= start + (/*lpar*/ (/*lpar*/ end - start ) / 2 ) ;
 
 if ( end - start == 0 ) {
 /*if*/
 
Entry last= ( *(Entry*) array__get( m .entries , end) ) ;
 
 memcpy ( out ,  last .val ,  m .element_size ) ;

 
 return  ;
 
 }
 ;
 
 if ( end - start == 1 ) {
 /*if*/
 
Entry first= ( *(Entry*) array__get( m .entries , start) ) ;
 
 memcpy ( out ,  first .val ,  m .element_size ) ;

 
 return  ;
 
 }
 ;
 
 if ( mid >= m .entries .len ) {
 /*if*/

 
 return  ;
 
 }
 ;
 
Entry mid_msg= ( *(Entry*) array__get( m .entries , mid) ) ;
 
 if (string_lt( query , mid_msg .key ) ) {
 /*if*/
 
 map_bs( m , query , start , mid , out ) ;

 
 return  ;
 
 }
 ;
 
 map_bs( m , query , mid , end , out ) ;
 
 
 }
 int compare_map(Entry* a, Entry* b) {
 
 if (string_lt( a ->key , b ->key ) ) {
 /*if*/

 
 return  - 1 ;
 
 }
 ;
 
 if (string_gt( a ->key , b ->key ) ) {
 /*if*/

 
 return  1 ;
 
 }
 ;

 
 return  0 ;
 
 
 }
 void map_sort(map* m) {
 
 array_sort_with_compare(& /* ? */ m ->entries , compare_map ) ;
 
 m ->is_sorted  =  1 ;
 
 
 }
 array_string map_keys(map m) {
 
array_string keys=new_array_from_c_array(0, 0, sizeof(string), (string[]) {   }) ;
 
 {
 
 }
 
 for (
int i= 0  ;  i < m .entries .len  ;  i ++ ) { 
 
Entry entry= ( *(Entry*) array__get( m .entries , i) ) ;
 
_PUSH(& keys , ( entry .key ), tmp25, string) ;
 
 }
 ;

 
 return  keys ;
 
 
 }
 bool map_get(map m, string key, void* out) {
 
 if ( m .is_sorted ) {
 /*if*/
 
 map_bs( m , key , 0 , m .entries .len , out ) ;

 
 return  1 ;
 
 }
 ;
 
 for (
int i= 0  ;  i < m .entries .len  ;  i ++ ) { 
 
Entry entry= ( *(Entry*) array__get( m .entries , i) ) ;
 
 if (string_eq( entry .key , key ) ) {
 /*if*/
 
 memcpy ( out ,  entry .val ,  m .element_size ) ;

 
 return  1 ;
 
 }
 ;
 
 }
 ;

 
 return  0 ;
 
 
 }
 bool map_exists(map m, string key) {
 
 for (
int i= 0  ;  i < m .entries .len  ;  i ++ ) { 
 
Entry entry= ( *(Entry*) array__get( m .entries , i) ) ;
 
 if (string_eq( entry .key , key ) ) {
 /*if*/

 
 return  1 ;
 
 }
 ;
 
 }
 ;

 
 return  0 ;
 
 
 }
 void v_map_print(map m) {
 
 println ( tos2("<<<<<<<<") ) ;
 
 for (
int i= 0  ;  i < m .entries .len  ;  i ++ ) { 
 
 }
 ;
 
 println ( tos2(">>>>>>>>>>") ) ;
 
 
 }
 void v_map_free(map m) {
 
 
 }
 string map_string_str(map_string m) {
 
 if ( m .entries .len == 0 ) {
 /*if*/

 
 return  tos2("{}") ;
 
 }
 ;
 
string s= tos2("{\n") ;
 
 array_Entry tmp36 =  m .entries;
 ;
for (int tmp37 = 0; tmp37 < tmp36 .len; tmp37 ++) {
 Entry entry = ((Entry *) tmp36.data)[tmp37];
string tmp38 = tos("", 0); bool tmp39 = map_get( m , entry .key, & tmp38);
if (!tmp39) tmp38 = tos("", 0);
 
string val= tmp38 ;
 
 s  = string_add( s , _STR("  \"%.*s\" => \"%.*s\"\n", entry .key.len, entry .key.str, val.len, val.str) ) ;
 
 }
 ;
 
 s  = string_add( s , tos2("}") ) ;

 
 return  s ;
 
 
 }
 StringBuilder new_string_builder(int initial_size) {

 
 return  (StringBuilder) { .buf =  new_array ( 0 , initial_size , sizeof( byte) ) , .len = 0 } ;
 
 
 }
 void StringBuilder_write(StringBuilder* b, string s) {
 
 array__push_many(& /* ? */ b ->buf , s .str , s .len ) ;
 
 b ->len  =  b ->len + s .len ;
 
 
 }
 void StringBuilder_writeln(StringBuilder* b, string s) {
 
 array__push_many(& /* ? */ b ->buf , s .str , s .len ) ;
 
_PUSH(& b ->buf , ( '\n' ), tmp1, byte) ;
 
 b ->len  =  b ->len + s .len + 1 ;
 
 
 }
 string StringBuilder_str(StringBuilder b) {

 
 return  tos ( b .buf .data , b .len ) ;
 
 
 }
 void StringBuilder_cut(StringBuilder b, int n) {
 
 b .len  =  b .len - n ;
 
 
 }
 void v_StringBuilder_free(StringBuilder* b) {
 
 free ( b ->buf .data ) ;
 
 
 }
 void os__todo_remove() {
 
 
 }
 array_string os__init_os_args(int argc, byteptr* argv) {
 
array_string args=new_array_from_c_array(0, 0, sizeof(string), (string[]) {   }) ;
 
 for (
int i= 0  ;  i < argc  ;  i ++ ) { 
 
_PUSH(& args , ( (tos2( argv [/*ptr*/ i ]/*rbyteptr 0*/ ) ) ), tmp3, string) ;
 
 }
 ;

 
 return  args ;
 
 
 }
 array_string os__parse_windows_cmd_line(byte* cmd) {
 
string s= (tos2( cmd ) ) ;

 
 return  string_split( s , tos2(" ") ) ;
 
 
 }
 Option_string os__read_file(string path) {
 
string res= tos2("") ;
 
byte* cpath= string_cstr( path ) ;


string mode= tos2("rb") ;

#ifndef _WIN32
mode = tos2("r");
#endif

void* fp= fopen ( cpath ,  string_cstr( mode ) ) ;
 
 if ( isnil ( fp ) ) {
 /*if*/

 
 return  v_error ( _STR("failed to open file \"%.*s\"", path.len, path.str) ) ;
 
 }
 ;
 
 fseek ( fp ,  0 ,  SEEK_END ) ;
 
int fsize= ftell ( fp ) ;
 
 rewind ( fp ) ;
 
byte* str= v_malloc ( fsize + 1 ) ;
 
 fread ( str ,  fsize ,  1 ,  fp ) ;
 
 fclose ( fp ) ;
 
 str [/*ptr*/ fsize ]/*rbyte 1*/  =  0 ;
 
 res  =  tos ( str , fsize ) ;
 
 //println (string_add(string_add( path , tos2(" -> ") ) , int_str( fsize ) ) ) ;

 
 return opt_ok(&  res ) ;
 
 
 }
 int os__file_size(string path) {
struct /*c struct init*/
 
stat s= (struct stat) { .st_size = 0 , .st_mode = 0 } ;
 
 stat ( path .str ,  & /*vvar*/  s ) ;

 
 return  s .st_size ;
 
 
 }
 void os__mv(string old, string new) {
 
 rename ( string_cstr( old ) ,  string_cstr( new ) ) ;
 
 
 }
 array_string os__read_lines(string path) {
 
array_string res=new_array_from_c_array(0, 0, sizeof(string), (string[]) {   }) ;
 
byte buf  [1000 ]= {} /* arkek init*/ ;
 
byte* cpath= string_cstr( path ) ;
 
void* fp= fopen ( cpath ,  "rb" ) ;
 
 if ( isnil ( fp ) ) {
 /*if*/

 
 return  res ;
 
 }
 ;
 
 while ( fgets ( buf ,  1000 ,  fp ) != 0 ) {
 
string val= tos2("") ;
 
 buf [ strlen ( buf ) - 1 ]/*rbyte 1*/  =  '\0' ;
 
 #ifdef _WIN32
 
 if ( buf [ strlen ( buf ) - 2 ]/*rbyte 1*/ == 13 ) {
 /*if*/
 
 buf [ strlen ( buf ) - 2 ]/*rbyte 1*/  =  '\0' ;
 
 }
 ;
 
 #endif
 ;
 
_PUSH(& res , ( tos_clone ( buf ) ), tmp17, string) ;
 
 }
 ;
 
 fclose ( fp ) ;

 
 return  res ;
 
 
 }
 array_ustring os__read_ulines(string path) {
 
array_string lines= os__read_lines ( path ) ;
 
array_ustring ulines=new_array_from_c_array(0, 0, sizeof(ustring), (ustring[]) {   }) ;
 
 array_string tmp20 =  lines;
 ;
for (int tmp21 = 0; tmp21 < tmp20 .len; tmp21 ++) {
 string myline = ((string *) tmp20.data)[tmp21];
 
_PUSH(& ulines , ( string_ustring( myline ) ), tmp22, ustring) ;
 
 }
 ;

 
 return  ulines ;
 
 
 }
 os__File os__open(string path) {

 
 return  os__open_file ( path ) ;
 
 
 }
 os__File os__open_file(string file) {

 
 return  os__create_file2 ( file , tos2("r") ) ;
 
 
 }
 os__File os__create(string path) {

 
 return  os__create_file ( path ) ;
 
 
 }
 os__File os__open_append(string path) {

 
 return  os__create_file ( path ) ;
 
 
 }
 os__File os__create_file(string file) {

 
 return  os__create_file2 ( file , tos2("w") ) ;
 
 
 }
 os__File os__create_file_a(string file) {

 
 return  os__create_file2 ( file , tos2("a") ) ;
 
 
 }
 os__File os__open_file_a(string file) {

 
 return  os__create_file2 ( file , tos2("a") ) ;
 
 
 }
 os__File os__create_file2(string file, string mode) {
 
os__File res= (os__File) { .cfile =  fopen ( string_cstr( file ) ,  string_cstr( mode ) ) } ;
 
 if ( isnil ( res .cfile ) ) {
 /*if*/
 
 println ( _STR("coudlnt create file \"%.*s\"", file.len, file.str) ) ;
 
 }
 ;

 
 return  res ;
 
 
 }
 void os__File_append(os__File f, string s) {
 
string ss= string_clone( s ) ;
 
 fputs ( string_cstr( ss ) ,  f .cfile ) ;
 
 
 }
 void os__File_write_bytes(os__File f, void* data, int size) {
 
 fwrite ( data ,  1 ,  size ,  f .cfile ) ;
 
 
 }
 void os__File_write_bytes_at(os__File f, void* data, int size, int pos) {
 
 fseek ( f .cfile ,  pos ,  SEEK_SET ) ;
 
 fwrite ( data ,  1 ,  size ,  f .cfile ) ;
 
 fseek ( f .cfile ,  0 ,  SEEK_END ) ;
 
 
 }
 void os__File_appendln(os__File f, string s) {
 
 fputs ( string_cstr( s ) ,  f .cfile ) ;
 
 fputs ( "\n" ,  f .cfile ) ;
 
 
 }
 void os__File_close(os__File f) {
 
 fclose ( f .cfile ) ;
 
 
 }
 void os__close_file(os__FILE* fp) {
 
 #ifdef _WIN32
 
 #endif
 ;
 
 if ( isnil ( fp ) ) {
 /*if*/

 
 return  ;
 
 }
 ;
 
 fclose ( fp ) ;
 
 
 }
 int os__system(string cmd) {
 
void* ret= system ( string_cstr( cmd ) ) ;
 
 if ( ret == - 1 ) {
 /*if*/
 
 os__print_c_errno ( ) ;
 
 }
 ;

 
 return  ret ;
 
 
 }
 os__FILE* os__popen(string path) {
 
byte* cpath= string_cstr( path ) ;
 
 #ifdef _WIN32

 
 return  _popen ( cpath ,  "r" ) ;
 
 ;
 
 #else

 
 return  popen ( cpath ,  "r" ) ;
 
 #endif
 ;
 
 
 }
 string os__exec(string cmd) {
 
 cmd  =  _STR("%.*s 2>&1", cmd.len, cmd.str) ;
 
os__FILE* f= os__popen ( cmd ) ;
 
 if ( isnil ( f ) ) {
 /*if*/
 
 println ( _STR("popen %.*s failed", cmd.len, cmd.str) ) ;

 
 return  tos2("") ;
 
 }
 ;
 
byte buf  [1000 ]= {} /* arkek init*/ ;
 
string res= tos2("") ;
 
 while ( fgets ( buf ,  1000 ,  f ) != 0 ) {
 
 res  = string_add( res , tos ( buf , strlen ( buf ) ) ) ;
 
 }
 ;

 
 return  string_trim_space( res ) ;
 
 
 }
 string os__getenv(string key) {
 
byte* s= getenv ( string_cstr( key ) ) ;
 
 if ( isnil ( s ) ) {
 /*if*/

 
 return  tos2("") ;
 
 }
 ;

 
 return  (tos2( s ) ) ;
 
 
 }
 int os__setenv(string name, string value, bool overwrite) {
 
 #ifdef _WIN32
 
 ;
 
 #else

 
 return  setenv ( string_cstr( name ) ,  string_cstr( value ) ,  overwrite ) ;
 
 #endif
 ;
 
 
 }
 int os__unsetenv(string name) {
 
 #ifdef _WIN32
 
 ;
 
 #else

 
 return  unsetenv ( string_cstr( name ) ) ;
 
 #endif
 ;
 
 
 }
 bool os__file_exists(string path) {
 
 #ifdef _WIN32

 
 return  _access ( path .str ,  0 ) != - 1 ;
 
 #endif
 ;

 
 return  access ( path .str ,  0 ) != - 1 ;
 
 
 }
 bool os__dir_exists(string path) {
 
void* dir= opendir ( string_cstr( path ) ) ;
 
bool res= ! isnil ( dir ) ;
 
 if ( res ) {
 /*if*/
 
 closedir ( dir ) ;
 
 }
 ;

 
 return  res ;
 
 
 }
 void os__mkdir(string path) {
 
 #ifdef _WIN32
 
 path  =  string_replace( path , tos2("/") , tos2("\\") ) ;
 
 CreateDirectory ( string_cstr( path ) ,  0 ) ;
 
 ;
 
 #else
 
 mkdir ( string_cstr( path ) ,  511 ) ;
 
 #endif
 ;
 
 
 }
 void os__rm(string path) {
 
 #ifdef _WIN32
 
 ;
 
 #else
 
 remove ( string_cstr( path ) ) ;
 
 #endif
 ;
 
 
 }
 void os__print_c_errno() {
 
 
 }
 string os__ext(string path) {
 
int pos= string_last_index( path , tos2(".") ) ;
 
 if ( pos == - 1 ) {
 /*if*/

 
 return  tos2("") ;
 
 }
 ;

 
 return  string_right( path , pos ) ;
 
 
 }
 string os__path_sans_ext(string path) {
 
int pos= string_last_index( path , tos2(".") ) ;
 
 if ( pos == - 1 ) {
 /*if*/

 
 return  path ;
 
 }
 ;

 
 return  string_left( path , pos ) ;
 
 
 }
 string os__basedir(string path) {
 
int pos= string_last_index( path , tos2("/") ) ;
 
 if ( pos == - 1 ) {
 /*if*/

 
 return  path ;
 
 }
 ;

 
 return  string_left( path , pos + 1 ) ;
 
 
 }
 string os__filename(string path) {

 
 return  string_all_after( path , tos2("/") ) ;
 
 
 }
 string os__get_line() {
 
 #ifdef _WIN32
 
 v_panic ( tos2("get_line() not implemented on Windows yet, sorry!") ) ;
 
 ;
 
 #else
 
u64 max= ((u64)( 256 ) ) ;
 
byte* buf= v_malloc ( ((int)( max ) ) ) ;
 
int nr_chars= getline ( & /*vvar*/  buf ,  & /*vvar*/  max ,  stdin ) ;
 
 if ( nr_chars == 0 ) {
 /*if*/

 
 return  tos2("") ;
 
 }
 ;
 
 if ( buf [/*ptr*/ nr_chars - 1 ]/*rbyte 0*/ == '\n' ) {
 /*if*/

 
 return  tos ( buf , nr_chars - 1 ) ;
 
 }
 ;

 
 return  tos ( buf , nr_chars ) ;
 
 #endif
 ;
 
 
 }
 string os__get_raw_line() {
 
 #ifdef _WIN32
 
 v_panic ( tos2("get_raw_line() not implemented on Windows yet, sorry!") ) ;
 
 ;
 
 #else
 
u64 max= ((u64)( 256 ) ) ;
 
byte* buf= v_malloc ( ((int)( max ) ) ) ;
 
int nr_chars= getline ( & /*vvar*/  buf ,  & /*vvar*/  max ,  stdin ) ;
 
 if ( nr_chars == 0 ) {
 /*if*/

 
 return  tos2("") ;
 
 }
 ;

 
 return  tos ( buf , nr_chars ) ;
 
 #endif
 ;
 
 
 }
 string os__user_os() {
 
 #ifdef __linux__

 
 return  tos2("linux") ;
 
 #endif
 ;
 
 #ifdef __APPLE__

 
 return  tos2("mac") ;
 
 #endif
 ;
 
 #ifdef _WIN32

 
 return  tos2("windows") ;
 
 #endif
 ;

 
 return  tos2("unknown") ;
 
 
 }
 string os__home_dir() {
 
string home= os__getenv ( tos2("HOME") ) ;
 
 #ifdef _WIN32
 
 home  =  os__getenv ( tos2("HOMEDRIVE") ) ;
 
 if ( string_is_empty( home ) ) {
 /*if*/
 
 home  =  os__getenv ( tos2("SYSTEMDRIVE") ) ;
 
 }
 ;
 
string homepath= os__getenv ( tos2("HOMEPATH") ) ;
 
 if ( string_is_empty( homepath ) ) {
 /*if*/
 
 homepath  = string_add( tos2("\\Users\\") , os__getenv ( tos2("USERNAME") ) ) ;
 
 }
 ;
 
 home  = string_add( home , homepath ) ;
 
 #endif
 ;
 
 home  = string_add( home , tos2("/") ) ;

 
 return  home ;
 
 
 }
 void os__write_file(string path, string text) {
 
os__File f= os__create ( path ) ;
 
 os__File_appendln( f , text ) ;
 
 os__File_close( f ) ;
 
 
 }
 void os__clear() {
 
 printf ( "\x1b[2J" ) ;
 
 printf ( "\x1b[H" ) ;
 
 
 }
 void os__on_segfault(void* f) {
 
 #ifdef _WIN32

 
 return  ;
 
 #endif
 ;
 
 #ifdef __APPLE__
struct /*c struct init*/
 
sigaction sa= (struct sigaction) { .sa_mask = 0 , .sa_sigaction = 0 , .sa_flags = 0 } ;
 
 memset ( & /*vvar*/  sa ,  0 ,  sizeof( sigaction) ) ;
 
 sigemptyset ( & /*vvar*/  sa .sa_mask ) ;
 
 sa .sa_sigaction  =  f ;
 
 sa .sa_flags  =  SA_SIGINFO ;
 
 sigaction ( SIGSEGV ,  & /*vvar*/  sa ,  0 ) ;
 
 #endif
 ;
 
 
 }
 string os__getexepath() {
 
byte result  [4096 ]= {} /* arkek init*/ ;
 
 #ifdef __linux__
 
int count= ((int)( readlink ( "/proc/self/exe" ,  result ,  os__MAX_PATH ) ) ) ;
 
 if ( (/*lpar*/ count < 0 ) ) {
 /*if*/
 
 v_panic ( tos2("error reading /proc/self/exe to get exe path") ) ;
 
 }
 ;

 
 return  tos ( result , count ) ;
 
 #endif
 ;
 
 #ifdef _WIN32
 
int ret= ((int)( GetModuleFileName ( 0 ,  result ,  os__MAX_PATH ) ) ) ;

 
 return  tos ( result , ret ) ;
 
 #endif
 ;
 
 #ifdef __APPLE__

 
 return  tos2("") ;
 
 #endif
 ;
 
 
 }
 void os__log(string s) {
 
 
 }
 bool os__is_dir(string path) {
struct /*c struct init*/
 
stat statbuf= (struct stat) { .st_size = 0 , .st_mode = 0 } ;
 
byte* cstr= string_cstr( path ) ;
 
 if ( stat ( cstr ,  & /*vvar*/  statbuf ) != 0 ) {
 /*if*/

 
 return  0 ;
 
 }
 ;

 
 return  statbuf .st_mode & S_IFMT == S_IFDIR ;
 
 
 }
 void os__chdir(string path) {
 
 chdir ( string_cstr( path ) ) ;
 
 
 }
 string os__getwd() {
 
byte* cwd= v_malloc ( 512 ) ;
 
 if ( getcwd ( cwd ,  512 ) == 0 ) {
 /*if*/

 
 return  tos2("") ;
 
 }
 ;

 
 return  (tos2( cwd ) ) ;
 
 
 }
 array_string os__ls(string path) {
 
array_string res=new_array_from_c_array(0, 0, sizeof(string), (string[]) {   }) ;
 
void* dir= opendir ( path .str ) ;
 
 if ( isnil ( dir ) ) {
 /*if*/
 
 println ( _STR("ls() couldnt open dir \"%.*s\"", path.len, path.str) ) ;
 
 os__print_c_errno ( ) ;

 
 return  res ;
 
 }
 ;
struct /*c struct init*/
 
dirent* ent= 0 ;
 
 while (1) { 
 ent  =  readdir ( dir ) ;
 
 if ( isnil ( ent ) ) {
 /*if*/
 
 break
 ;
 
 }
 ;
 
string name= tos_clone ( ent ->d_name ) ;
 
 if (string_ne( name , tos2(".") )  && string_ne( name , tos2("..") )  && string_ne( name , tos2("") ) ) {
 /*if*/
 
_PUSH(& res , ( name ), tmp8, string) ;
 
 }
 ;
 
 }
 ;
 
 closedir ( dir ) ;

 
 return  res ;
 
 
 }
 void os__print_backtrace() {
 
 
 }
 void time__remove_me_when_c_bug_is_fixed() {
 
 
 }
 time__Time time__now() {
 
void* t= time ( 0 ) ;
struct /*c struct init*/
 
tm* now= 0 ;
 
 now  =  localtime ( & /*vvar*/  t ) ;

 
 return  time__convert_ctime (* now ) ;
 
 
 }
 time__Time time__random() {

 
 return  (struct time__Time) { .year =  rand__next ( 2 ) + 201 , .month =  rand__next ( 12 ) + 1 , .day =  rand__next ( 30 ) + 1 , .hour =  rand__next ( 24 ) , .minute =  rand__next ( 60 ) , .second =  rand__next ( 60 ) , .uni = 0 } ;
 
 
 }
 time__Time time__unix(int u) {
struct /*c struct init*/
 
tm* t= 0 ;
 
 t  =  localtime ( & /*vvar*/  u ) ;

 
 return  time__convert_ctime (* t ) ;
 
 
 }
 time__Time time__convert_ctime(struct /*TM*/ tm t) {

 
 return  (struct time__Time) { .year =  t .tm_year + 1900 , .month =  t .tm_mon + 1 , .day =  t .tm_mday , .hour =  t .tm_hour , .minute =  t .tm_min , .second =  t .tm_sec , .uni = 0 } ;
 
 
 }
 string time__Time_format_ss(time__Time t) {

 
 return  _STR("%d-%02d-%02d %02d:%02d:%02d", t .year, t .month, t .day, t .hour, t .minute, t .second) ;
 
 
 }
 string time__Time_format(time__Time t) {

 
 return  _STR("%d-%02d-%02d %02d:%02d", t .year, t .month, t .day, t .hour, t .minute) ;
 
 
 }
 string time__Time_smonth(time__Time t) {
 
int i= t .month - 1 ;

 
 return  string_substr( time__Months , i * 3 , (/*lpar*/ i + 1 ) * 3 ) ;
 
 
 }
 string time__Time_hhmm(time__Time t) {

 
 return  _STR("%02d:%02d", t .hour, t .minute) ;
 
 
 }
 string time__Time_hhmm12(time__Time t) {
 
string am= tos2("am") ;
 
int hour= t .hour ;
 
 if ( t .hour > 11 ) {
 /*if*/
 
 am  =  tos2("pm") ;
 
 }
 ;
 
 if ( t .hour > 12 ) {
 /*if*/
 
 hour  =  hour - 12 ;
 
 }
 ;
 
 if ( t .hour == 0 ) {
 /*if*/
 
 hour  =  12 ;
 
 }
 ;

 
 return  _STR("%d:%02d %.*s", hour, t .minute, am.len, am.str) ;
 
 
 }
 string time__Time_hhmmss(time__Time t) {

 
 return  _STR("%02d:%02d:%02d", t .hour, t .minute, t .second) ;
 
 
 }
 string time__Time_ymmdd(time__Time t) {

 
 return  _STR("%d-%02d-%02d", t .year, t .month, t .day) ;
 
 
 }
 string time__Time_md(time__Time t) {
 
string s= _STR("%.*s %d", time__Time_smonth( t ).len, time__Time_smonth( t ).str, t .day) ;

 
 return  s ;
 
 
 }
 string time__Time_clean(time__Time t) {
 
time__Time nowe= time__now ( ) ;
 
 if ( t .month == nowe .month  &&  t .year == nowe .year  &&  t .day == nowe .day ) {
 /*if*/

 
 return  time__Time_hhmm( t ) ;
 
 }
 ;
 
 if ( t .year == nowe .year ) {
 /*if*/

 
 return  _STR("%.*s %d %.*s", time__Time_smonth( t ).len, time__Time_smonth( t ).str, t .day, time__Time_hhmm( t ).len, time__Time_hhmm( t ).str) ;
 
 }
 ;

 
 return  time__Time_format( t ) ;
 
 
 }
 string time__Time_clean12(time__Time t) {
 
time__Time nowe= time__now ( ) ;
 
 if ( t .month == nowe .month  &&  t .year == nowe .year  &&  t .day == nowe .day ) {
 /*if*/

 
 return  time__Time_hhmm12( t ) ;
 
 }
 ;
 
 if ( t .year == nowe .year ) {
 /*if*/

 
 return  _STR("%.*s %d %.*s", time__Time_smonth( t ).len, time__Time_smonth( t ).str, t .day, time__Time_hhmm12( t ).len, time__Time_hhmm12( t ).str) ;
 
 }
 ;

 
 return  time__Time_format( t ) ;
 
 
 }
 time__Time time__parse(string s) {
 
int pos= string_index( s , tos2(" ") ) ;
 
 if ( pos <= 0 ) {
 /*if*/
 
 println ( tos2("bad time format") ) ;

 
 return  time__now ( ) ;
 
 }
 ;
 
string symd= string_left( s , pos ) ;
 
array_string ymd= string_split( symd , tos2("-") ) ;
 
 if ( ymd .len != 3 ) {
 /*if*/
 
 println ( tos2("bad time format") ) ;

 
 return  time__now ( ) ;
 
 }
 ;
 
string shms= string_right( s , pos ) ;
 
array_string hms= string_split( shms , tos2(":") ) ;
 
string hour= ( *(string*) array__get( hms , 0) ) ;
 
string minute= ( *(string*) array__get( hms , 1) ) ;
 
string second= ( *(string*) array__get( hms , 2) ) ;

 
 return  time__new_time ( (time__Time) { .year =  string_int( ( *(string*) array__get( ymd , 0) ) ) , .month =  string_int( ( *(string*) array__get( ymd , 1) ) ) , .day =  string_int( ( *(string*) array__get( ymd , 2) ) ) , .hour =  string_int( hour ) , .minute =  string_int( minute ) , .second =  string_int( second ) , .uni = 0 } ) ;
 
 
 }
 time__Time time__new_time(time__Time t) {

 
 return  (time__Time){ .uni =  time__Time_calc_unix(& /* ? */ t ) , .year = t . year, .month = t . month, .day = t . day, .hour = t . hour, .minute = t . minute, .second = t . second, } ;
 
 
 }
 int time__Time_calc_unix(time__Time* t) {
 
 if ( t ->uni != 0 ) {
 /*if*/

 
 return  t ->uni ;
 
 }
 ;


struct /*TM*/ tm tt= (struct tm) { .tm_sec =  t ->second , .tm_min =  t ->minute , .tm_hour =  t ->hour , .tm_mday =  t ->day , .tm_mon =  t ->month - 1 , .tm_year =  t ->year - 1900 } ;

 
 return  mktime ( & /*vvar*/  tt ) ;
 
 
 }
 time__Time time__Time_add_seconds(time__Time t, int seconds) {

 
 return  time__unix ( t .uni + seconds ) ;
 
 
 }
 int time__since(time__Time t) {

 
 return  0 ;
 
 
 }
 string time__Time_relative(time__Time t) {
 
time__Time now= time__now ( ) ;
 
int secs= now .uni - t .uni ;
 
 if ( secs <= 30 ) {
 /*if*/

 
 return  tos2("now") ;
 
 }
 ;
 
 if ( secs < 60 ) {
 /*if*/

 
 return  tos2("1m") ;
 
 }
 ;
 
 if ( secs < 3600 ) {
 /*if*/

 
 return  _STR("%dm", secs / 60) ;
 
 }
 ;
 
 if ( secs < 3600 * 24 ) {
 /*if*/

 
 return  _STR("%dh", secs / 3600) ;
 
 }
 ;
 
 if ( secs < 3600 * 24 * 5 ) {
 /*if*/

 
 return  _STR("%dd", secs / 3600 / 24) ;
 
 }
 ;
 
 if ( secs > 3600 * 24 * 10000 ) {
 /*if*/

 
 return  tos2("") ;
 
 }
 ;

 
 return  time__Time_md( t ) ;
 
 
 }
 int time__day_of_week(int y, int m, int d) {

 
 return  0 ;
 
 
 }
 int time__Time_day_of_week(time__Time t) {

 
 return  time__day_of_week ( t .year , t .month , t .day ) ;
 
 
 }
 string time__Time_weekday_str(time__Time t) {
 
int i= time__Time_day_of_week( t ) - 1 ;

 
 return  string_substr( time__Days , i * 3 , (/*lpar*/ i + 1 ) * 3 ) ;
 
 
 }
 f64 time__ticks() {
 
 #ifdef _WIN32

 
 return  GetTickCount ( ) ;
 
 #endif
 ;
 
 v_panic ( tos2("not implemented") ) ;

 
 return  ((f64)( 0 ) ) ;
 
 
 }
 void time__sleep(int seconds) {
 
 #ifdef _WIN32
 
 _sleep ( seconds * 1000 ) ;
 
 ;
 
 #else
 
 sleep ( seconds ) ;
 
 #endif
 ;
 
 
 }
 void time__usleep(int n) {
 
 usleep ( n ) ;
 
 
 }
 void time__sleep_ms(int n) {
 
 #ifdef _WIN32
 
 Sleep ( n ) ;
 
 ;
 
 #else
 
 usleep ( n * 1000 ) ;
 
 #endif
 ;
 
 
 }
 void rand__seed() {
 
 srand ( time__now ( ) .uni ) ;
 
 
 }
 int rand__next(int max) {

 
 return  rand ( ) % max ;
 
 
 }
 CGen* new_cgen(string out_name_c) {
 
CGen* gen= ALLOC_INIT(CGen, { .out_path =  _STR("%.*s/%.*s", main__TmpPath.len, main__TmpPath.str, out_name_c.len, out_name_c.str) , .out =  os__create ( _STR("%.*s/%.*s", main__TmpPath.len, main__TmpPath.str, out_name_c.len, out_name_c.str) ) , .typedefs = new_array(0, 1, sizeof(string)) , .type_aliases = new_array(0, 1, sizeof(string)) , .includes = new_array(0, 1, sizeof(string)) , .types = new_array(0, 1, sizeof(string)) , .thread_args = new_array(0, 1, sizeof(string)) , .thread_fns = new_array(0, 1, sizeof(string)) , .consts = new_array(0, 1, sizeof(string)) , .fns = new_array(0, 1, sizeof(string)) , .so_fns = new_array(0, 1, sizeof(string)) , .consts_init = new_array(0, 1, sizeof(string)) , .lines = new_array(0, 1, sizeof(string)) , .is_user = 0 , .nogen = 0 , .tmp_line = tos("", 0) , .cur_line = tos("", 0) , .prev_line = tos("", 0) , .is_tmp = 0 , .fn_main = tos("", 0) , .stash = tos("", 0) } ) ;

 
 return  gen ;
 
 
 }
 void CGen_genln(CGen* g, string s) {
 
 if ( g ->nogen  ||  g ->run == RUN_DECLS ) {
 /*if*/

 
 return  ;
 
 }
 ;
 
 if ( g ->is_tmp ) {
 /*if*/
 
 g ->tmp_line  =  _STR("%.*s %.*s\n", g ->tmp_line.len, g ->tmp_line.str, s.len, s.str) ;

 
 return  ;
 
 }
 ;
 
 g ->cur_line  =  _STR("%.*s %.*s", g ->cur_line.len, g ->cur_line.str, s.len, s.str) ;
 
 if (string_ne( g ->cur_line , tos2("") ) ) {
 /*if*/
 
_PUSH(& g ->lines , ( g ->cur_line ), tmp2, string) ;
 
 g ->prev_line  =  g ->cur_line ;
 
 g ->cur_line  =  tos2("") ;
 
 }
 ;
 
 
 }
 void CGen_gen(CGen* g, string s) {
 
 if ( g ->nogen  ||  g ->run == RUN_DECLS ) {
 /*if*/

 
 return  ;
 
 }
 ;
 
 if ( g ->is_tmp ) {
 /*if*/
 
 g ->tmp_line  =  _STR("%.*s %.*s", g ->tmp_line.len, g ->tmp_line.str, s.len, s.str) ;
 
 }
  else { 
 /*else if*/
 
 g ->cur_line  =  _STR("%.*s %.*s", g ->cur_line.len, g ->cur_line.str, s.len, s.str) ;
 
 }
 ;
 
 
 }
 void CGen_save(CGen* g) {
 
string s= array_string_join( g ->lines , tos2("\n") ) ;
 
 os__File_appendln( g ->out , s ) ;
 
 os__File_close( g ->out ) ;
 
 
 }
 void CGen_start_tmp(CGen* g) {
 
 if ( g ->is_tmp ) {
 /*if*/
 
 println ( g ->tmp_line ) ;
 
 println ( _STR("start_tmp() already started. cur_line=\"%.*s\"", g ->cur_line.len, g ->cur_line.str) ) ;
 
 v_exit ( 1 ) ;
 
 }
 ;
 
 g ->tmp_line  =  tos2("") ;
 
 g ->is_tmp  =  1 ;
 
 
 }
 string CGen_end_tmp(CGen* g) {
 
 g ->is_tmp  =  0 ;
 
string res= g ->tmp_line ;
 
 g ->tmp_line  =  tos2("") ;

 
 return  res ;
 
 
 }
 int CGen_add_placeholder(CGen* g) {
 
 if ( g ->is_tmp ) {
 /*if*/

 
 return  g ->tmp_line .len ;
 
 }
 ;

 
 return  g ->cur_line .len ;
 
 
 }
 void CGen_set_placeholder(CGen* g, int pos, string val) {
 
 if ( g ->nogen ) {
 /*if*/

 
 return  ;
 
 }
 ;
 
 if ( g ->is_tmp ) {
 /*if*/
 
string left= string_left( g ->tmp_line , pos ) ;
 
string right= string_right( g ->tmp_line , pos ) ;
 
 g ->tmp_line  =  _STR("%.*s%.*s%.*s", left.len, left.str, val.len, val.str, right.len, right.str) ;

 
 return  ;
 
 }
 ;
 
string left= string_left( g ->cur_line , pos ) ;
 
string right= string_right( g ->cur_line , pos ) ;
 
 g ->cur_line  =  _STR("%.*s%.*s%.*s", left.len, left.str, val.len, val.str, right.len, right.str) ;
 
 
 }
 int CGen_add_placeholder2(CGen* g) {
 
 if ( g ->is_tmp ) {
 /*if*/
 
 println ( tos2("tmp in addp2") ) ;
 
 v_exit ( 1 ) ;
 
 }
 ;
 
_PUSH(& g ->lines , ( tos2("") ), tmp9, string) ;

 
 return  g ->lines .len - 1 ;
 
 
 }
 void CGen_set_placeholder2(CGen* g, int pos, string val) {
 
 if ( g ->nogen ) {
 /*if*/

 
 return  ;
 
 }
 ;
 
 if ( g ->is_tmp ) {
 /*if*/
 
 println ( tos2("tmp in setp2") ) ;
 
 v_exit ( 1 ) ;
 
 }
 ;
string tmp10 =  val;
 
array_set(&/*q*/ g ->lines , pos , & tmp10) ;
 
 
 }
 void CGen_insert_before(CGen* g, string val) {
 
 array_insert(& /* ? */ g ->lines , g ->lines .len - 1 ,& /*11 EXP:"void*" GOT:"string" */ val ) ;
 
 
 }
 void CGen_register_thread_fn(CGen* g, string wrapper_name, string wrapper_text, string struct_text) {
 
 array_string tmp11 =  g ->thread_args;
 ;
for (int tmp12 = 0; tmp12 < tmp11 .len; tmp12 ++) {
 string arg = ((string *) tmp11.data)[tmp12];
 
 if ( string_contains( arg , wrapper_name ) ) {
 /*if*/

 
 return  ;
 
 }
 ;
 
 }
 ;
 
_PUSH(& g ->thread_args , ( struct_text ), tmp13, string) ;
 
_PUSH(& g ->thread_args , ( wrapper_text ), tmp14, string) ;
 
 
 }
 string V_prof_counters(V* c) {
 
array_string res=new_array_from_c_array(0, 0, sizeof(string), (string[]) {   }) ;
 
 array_Fn tmp16 =  c ->table ->fns;
 ;
for (int tmp17 = 0; tmp17 < tmp16 .len; tmp17 ++) {
 Fn f = ((Fn *) tmp16.data)[tmp17];
 
_PUSH(& res , ( _STR("double %.*s_time;", Table_cgen_name( c ->table ,& /*11 EXP:"Fn*" GOT:"Fn" */ f ).len, Table_cgen_name( c ->table ,& /*11 EXP:"Fn*" GOT:"Fn" */ f ).str) ), tmp18, string) ;
 
 }
 ;
 
 array_Type tmp19 =  c ->table ->types;
 ;
for (int tmp20 = 0; tmp20 < tmp19 .len; tmp20 ++) {
 Type typ = ((Type *) tmp19.data)[tmp20];
 
 array_Fn tmp21 =  typ .methods;
 ;
for (int tmp22 = 0; tmp22 < tmp21 .len; tmp22 ++) {
 Fn f = ((Fn *) tmp21.data)[tmp22];
 
_PUSH(& res , ( _STR("double %.*s_time;", Table_cgen_name( c ->table ,& /*11 EXP:"Fn*" GOT:"Fn" */ f ).len, Table_cgen_name( c ->table ,& /*11 EXP:"Fn*" GOT:"Fn" */ f ).str) ), tmp23, string) ;
 
 }
 ;
 
 }
 ;

 
 return  array_string_join( res , tos2(";\n") ) ;
 
 
 }
 string Parser_print_prof_counters(Parser* p) {
 
array_string res=new_array_from_c_array(0, 0, sizeof(string), (string[]) {   }) ;
 
 array_Fn tmp25 =  p ->table ->fns;
 ;
for (int tmp26 = 0; tmp26 < tmp25 .len; tmp26 ++) {
 Fn f = ((Fn *) tmp25.data)[tmp26];
 
string counter= _STR("%.*s_time", Table_cgen_name( p ->table ,& /*11 EXP:"Fn*" GOT:"Fn" */ f ).len, Table_cgen_name( p ->table ,& /*11 EXP:"Fn*" GOT:"Fn" */ f ).str) ;
 
_PUSH(& res , ( _STR("if (%.*s) printf(\"%%f : %.*s \\n\", %.*s);", counter.len, counter.str, f .name.len, f .name.str, counter.len, counter.str) ), tmp28, string) ;
 
 }
 ;
 
 array_Type tmp29 =  p ->table ->types;
 ;
for (int tmp30 = 0; tmp30 < tmp29 .len; tmp30 ++) {
 Type typ = ((Type *) tmp29.data)[tmp30];
 
 array_Fn tmp31 =  typ .methods;
 ;
for (int tmp32 = 0; tmp32 < tmp31 .len; tmp32 ++) {
 Fn f = ((Fn *) tmp31.data)[tmp32];
 
string counter= _STR("%.*s_time", Table_cgen_name( p ->table ,& /*11 EXP:"Fn*" GOT:"Fn" */ f ).len, Table_cgen_name( p ->table ,& /*11 EXP:"Fn*" GOT:"Fn" */ f ).str) ;
 
_PUSH(& res , ( _STR("if (%.*s) printf(\"%%f : %.*s \\n\", %.*s);", counter.len, counter.str, Table_cgen_name( p ->table ,& /*11 EXP:"Fn*" GOT:"Fn" */ f ).len, Table_cgen_name( p ->table ,& /*11 EXP:"Fn*" GOT:"Fn" */ f ).str, counter.len, counter.str) ), tmp34, string) ;
 
 }
 ;
 
 }
 ;

 
 return  array_string_join( res , tos2(";\n") ) ;
 
 
 }
 void Parser_gen_type(Parser* p, string s) {
 
 if ( ! Parser_first_run(& /* ? */* p ) ) {
 /*if*/

 
 return  ;
 
 }
 ;
 
_PUSH(& p ->cgen ->types , ( s ), tmp35, string) ;
 
 
 }
 void Parser_gen_typedef(Parser* p, string s) {
 
 if ( ! Parser_first_run(& /* ? */* p ) ) {
 /*if*/

 
 return  ;
 
 }
 ;
 
_PUSH(& p ->cgen ->typedefs , ( s ), tmp36, string) ;
 
 
 }
 void Parser_gen_type_alias(Parser* p, string s) {
 
 if ( ! Parser_first_run(& /* ? */* p ) ) {
 /*if*/

 
 return  ;
 
 }
 ;
 
_PUSH(& p ->cgen ->type_aliases , ( s ), tmp37, string) ;
 
 
 }
 void CGen_add_to_main(CGen* g, string s) {
 
 println ( tos2("add to main") ) ;
 
 g ->fn_main  = string_add( g ->fn_main , s ) ;
 
 
 }
 Var Fn_find_var(Fn* f, string name) {
 
 int tmp1 =  0;
 ;
for (int tmp2 = tmp1; tmp2 <  f ->var_idx; tmp2++) {
 int i = tmp2;
 
 if (string_eq( ( *(Var*) array__get( f ->local_vars , i) ) .name , name ) ) {
 /*if*/

 
 return  ( *(Var*) array__get( f ->local_vars , i) ) ;
 
 }
 ;
 
 }
 ;

 
 return  (Var) { .typ = tos("", 0) , .name = tos("", 0) , .is_arg = 0 , .is_const = 0 , .is_import_const = 0 , .args = new_array(0, 1, sizeof(Var)) , .attr = tos("", 0) , .is_mut = 0 , .ptr = 0 , .ref = 0 , .parent_fn = tos("", 0) , .pkg = tos("", 0) , .line_nr = 0 , .is_global = 0 , .is_used = 0 , .scope_level = 0 } ;
 
 
 }
 void Fn_open_scope(Fn* f) {
 
 f ->scope_level ++ ;
 
 
 }
 void Fn_close_scope(Fn* f) {
 
int i= f ->var_idx - 1 ;
 
 for (
  ;  i >= 0  ;  i -- ) { 
 
Var v= ( *(Var*) array__get( f ->local_vars , i) ) ;
 
 if ( v .scope_level != f ->scope_level ) {
 /*if*/
 
 break
 ;
 
 }
 ;
 
 }
 ;
 
 f ->var_idx  =  i + 1 ;
 
 f ->scope_level -- ;
 
 
 }
 void Fn_mark_var_used(Fn* f, Var v) {
 
 array_Var tmp11 =  f ->local_vars ;
 ;
for (int i = 0; i < tmp11 .len; i ++) {
 Var vv = ((Var *) tmp11 . data)[i];
 
 if (string_eq( vv .name , v .name ) ) {
 /*if*/
 
Var* ptr= & /*vvar*/  ( *(Var*) array__get( f ->local_vars , i) ) ;
 
 ptr ->is_used  =  1 ;
 
 }
 ;
 
 }
 ;
 
 
 }
 bool Fn_known_var(Fn* f, string name) {
 
Var v= Fn_find_var(& /* ? */* f , name ) ;

 
 return  v .name .len > 0 ;
 
 
 }
 void Fn_register_var(Fn* f, Var v) {
 
Var new_var= (Var){ .scope_level =  f ->scope_level , .typ = v . typ, .name = v . name, .is_arg = v . is_arg, .is_const = v . is_const, .is_import_const = v . is_import_const, .args = v . args, .attr = v . attr, .is_mut = v . is_mut, .ptr = v . ptr, .ref = v . ref, .parent_fn = v . parent_fn, .pkg = v . pkg, .line_nr = v . line_nr, .access_mod = v . access_mod, .is_global = v . is_global, .is_used = v . is_used, } ;
 
 if ( f ->var_idx >= f ->local_vars .len ) {
 /*if*/
 
_PUSH(& f ->local_vars , ( new_var ), tmp17, Var) ;
 
 }
  else { 
 /*else if*/
Var tmp18 =  new_var;
 
array_set(&/*q*/ f ->local_vars , f ->var_idx , & tmp18) ;
 
 }
 ;
 
 f ->var_idx ++ ;
 
 
 }
 void Fn_clear_vars(Fn* f) {
 
 f ->var_idx  =  0 ;
 
 f ->local_vars  = new_array_from_c_array(0, 0, sizeof(Var), (Var[]) {   }) ;
 
 
 }
 bool Parser_is_sig(Parser* p) {

 
 return  (/*lpar*/ p ->build_mode == DEFAULT_MODE  ||  p ->build_mode == BUILD )  &&  (/*lpar*/ string_contains( p ->file_path , main__TmpPath ) ) ;
 
 
 }
 Fn* new_fn(string pkg, bool is_public) {
Var tmp19 =  (Var) { .typ = tos("", 0) , .name = tos("", 0) , .is_arg = 0 , .is_const = 0 , .is_import_const = 0 , .args = new_array(0, 1, sizeof(Var)) , .attr = tos("", 0) , .is_mut = 0 , .ptr = 0 , .ref = 0 , .parent_fn = tos("", 0) , .pkg = tos("", 0) , .line_nr = 0 , .is_global = 0 , .is_used = 0 , .scope_level = 0 };
 
Fn* f= ALLOC_INIT(Fn, { .pkg =  pkg , .local_vars =  array_repeat(&tmp19,  main__MaxLocalVars , sizeof(Var) ) , .is_public =  is_public , .var_idx = 0 , .args = new_array(0, 1, sizeof(Var)) , .is_interface = 0 , .scope_level = 0 , .typ = tos("", 0) , .name = tos("", 0) , .is_c = 0 , .receiver_typ = tos("", 0) , .is_method = 0 , .returns_error = 0 , .is_decl = 0 , .defer = tos("", 0) } ) ;

 
 return  f ;
 
 
 }
 void Parser_fn_decl(Parser* p) {
 
 Parser_fgen( p , tos2("fn ") ) ;
 
bool is_pub= p ->tok == PUB ;
 
 if ( is_pub ) {
 /*if*/
 
 Parser_next( p ) ;
 
 }
 ;
 
 p ->returns  =  0 ;
 
 Parser_next( p ) ;
 
Fn* f= new_fn ( p ->pkg , is_pub ) ;
 
string receiver_typ= tos2("") ;
 
 if ( p ->tok == LPAR ) {
 /*if*/
 
 f ->is_method  =  1 ;
 
 Parser_check( p , LPAR ) ;
 
string receiver_name= Parser_check_name( p ) ;
 
bool is_mut= p ->tok == MUT ;
 
bool is_amp= p ->tok == AMP ;
 
 if ( is_mut  ||  is_amp ) {
 /*if*/
 
 Parser_next( p ) ;
 
 }
 ;
 
 receiver_typ  =  Parser_get_type( p ) ;
 
Type* T= Table_find_type(& /* ? */* p ->table , receiver_typ ) ;
 
 if ( T ->is_interface ) {
 /*if*/
 
 Parser_error( p , _STR("invalid receiver type `%.*s` (`%.*s` is an interface)", receiver_typ.len, receiver_typ.str, receiver_typ.len, receiver_typ.str) ) ;
 
 }
 ;
 
 if ( ! Parser_first_run(& /* ? */* p )  &&  ! p ->builtin_pkg  && string_ne( T ->pkg , p ->pkg ) ) {
 /*if*/
 
 println ( _STR("T.pkg=%.*s", T ->pkg.len, T ->pkg.str) ) ;
 
 println ( _STR("pkg=%.*s", p ->pkg.len, p ->pkg.str) ) ;
 
 Parser_error( p , _STR("cannot define new methods on non-local type `%.*s`", receiver_typ.len, receiver_typ.str) ) ;
 
 }
 ;
 
 if ( ! p ->builtin_pkg  &&  string_contains( receiver_typ , tos2("*") ) ) {
 /*if*/
 
string t= string_replace( receiver_typ , tos2("*") , tos2("") ) ;
 
 Parser_error( p , _STR("use `(%.*s mut %.*s)` instead of `(%.*s *%.*s)`", receiver_name.len, receiver_name.str, t.len, t.str, receiver_name.len, receiver_name.str, t.len, t.str) ) ;
 
 }
 ;
 
 f ->receiver_typ  =  receiver_typ ;
 
 if ( is_mut  ||  is_amp ) {
 /*if*/
 
 receiver_typ  = string_add( receiver_typ , tos2("*") ) ;
 
 }
 ;
 
 Parser_check( p , RPAR ) ;
 
Var receiver= (Var) { .name =  receiver_name , .is_arg =  1 , .typ =  receiver_typ , .is_mut =  is_mut , .ref =  is_amp , .ptr =  is_mut , .line_nr =  p ->scanner ->line_nr , .is_const = 0 , .is_import_const = 0 , .args = new_array(0, 1, sizeof(Var)) , .attr = tos("", 0) , .parent_fn = tos("", 0) , .pkg = tos("", 0) , .is_global = 0 , .is_used = 0 , .scope_level = 0 } ;
 
_PUSH(& f ->args , ( receiver ), tmp30, Var) ;
 
 Fn_register_var( f , receiver ) ;
 
 }
 ;
 
 if ( p ->tok == PLUS  ||  p ->tok == MINUS  ||  p ->tok == MUL ) {
 /*if*/
 
 f ->name  =  Token_str( p ->tok ) ;
 
 Parser_next( p ) ;
 
 }
  else { 
 /*else if*/
 
 f ->name  =  Parser_check_name( p ) ;
 
 }
 ;
 
bool is_c=string_eq( f ->name , tos2("C") )  &&  p ->tok == DOT ;
 
bool is_sig= Parser_is_sig( p ) ;
 
 if ( is_c ) {
 /*if*/
 
 Parser_check( p , DOT ) ;
 
 f ->name  =  Parser_check_name( p ) ;
 
 f ->is_c  =  1 ;
 
 }
  else  if ( ! p ->translated  &&  ! string_contains( p ->file_path , tos2("view.v") ) ) {
 /*if*/
 
 if ( contains_capital ( f ->name ) ) {
 /*if*/
 
 Parser_error( p , tos2("function names cannot contain uppercase letters, use snake_case instead") ) ;
 
 }
 ;
 
 if ( string_contains( f ->name , tos2("__") ) ) {
 /*if*/
 
 Parser_error( p , tos2("function names cannot contain double underscores (\"__\"), use single underscores instead") ) ;
 
 }
 ;
 
 }
 ;
 
bool has_receiver= receiver_typ .len > 0 ;
 
 if (string_ne( receiver_typ , tos2("") ) ) {
 /*if*/
 
 }
 ;
 
 if ( ! is_c  &&  ! p ->builtin_pkg  && string_ne( p ->pkg , tos2("main") )  &&  receiver_typ .len == 0 ) {
 /*if*/
 
 f ->name  =  Parser_prepend_pkg(& /* ? */* p , f ->name ) ;
 
 }
 ;
 
 if ( Parser_first_run(& /* ? */* p )  &&  Table_known_fn(& /* ? */* p ->table , f ->name )  &&  receiver_typ .len == 0 ) {
 /*if*/
 
Fn existing_fn= Table_find_fn(& /* ? */* p ->table , f ->name ) ;
 
 if ( ! existing_fn .is_decl ) {
 /*if*/
 
 Parser_error( p , _STR("redefinition of `%.*s`", f ->name.len, f ->name.str) ) ;
 
 }
 ;
 
 }
 ;
 
bool is_generic= 0 ;
 
 if ( p ->tok == LT ) {
 /*if*/
 
 Parser_next( p ) ;
 
string gen_type= Parser_check_name( p ) ;
 
 if (string_ne( gen_type , tos2("T") ) ) {
 /*if*/
 
 Parser_error( p , tos2("only `T` is allowed as a generic type for now") ) ;
 
 }
 ;
 
 Parser_check( p , GT ) ;
 
 is_generic  =  1 ;
 
 }
 ;
 
 Parser_fn_args( p , f ) ;
 
 if ( p ->tok == NOT ) {
 /*if*/
 
 Parser_next( p ) ;
 
 f ->returns_error  =  1 ;
 
 }
 ;
 
string typ= tos2("void") ;
 
 if ( p ->tok == NAME  ||  p ->tok == MUL  ||  p ->tok == AMP  ||  p ->tok == LSBR  ||  p ->tok == QUESTION ) {
 /*if*/
 
 Parser_fgen( p , tos2(" ") ) ;
 
 typ  =  Parser_get_type( p ) ;
 
 }
 ;
 
bool is_fn_header= ! is_c  &&  ! is_sig  &&  (/*lpar*/ p ->translated  ||  p ->is_test )  &&  (/*lpar*/ p ->tok != LCBR ) ;
 
 if ( is_fn_header ) {
 /*if*/
 
 f ->is_decl  =  1 ;
 
 }
 ;
 
 if ( ! is_c  &&  ! is_sig  &&  ! is_fn_header ) {
 /*if*/
 
 Parser_fgen( p , tos2(" ") ) ;
 
 Parser_check( p , LCBR ) ;
 
 }
 ;
 
 if ( string_starts_with( typ , tos2("Option_") ) ) {
 /*if*/
 
_PUSH(& p ->cgen ->typedefs , ( _STR("typedef Option %.*s;", typ.len, typ.str) ), tmp39, string) ;
 
 }
 ;
 
 f ->typ  =  typ ;
 
string str_args= Fn_str_args(& /* ? */* f , p ->table ) ;
 
 if (string_eq( f ->name , tos2("main") )  &&  ! has_receiver ) {
 /*if*/
 
 if (string_ne( str_args , tos2("") ) ) {
 /*if*/
 
 Parser_error( p , tos2("fn main must have no arguments and no return values") ) ;
 
 }
 ;
 
 typ  =  tos2("int") ;
 
 str_args  =  tos2("int argc, char** argv") ;
 
 }
 ;
 
string fn_name_cgen= Table_cgen_name( p ->table , f ) ;
 
bool is_live= p ->is_live  && string_ne( f ->name , tos2("main") )  && string_ne( f ->name , tos2("reload_so") ) ;
 
bool skip_main_in_test=string_eq( f ->name , tos2("main") )  &&  p ->is_test ;
 
 if ( ! is_c  &&  ! is_live  &&  ! is_sig  &&  ! is_fn_header  &&  ! skip_main_in_test ) {
 /*if*/
 
 if ( p ->obfuscate ) {
 /*if*/
 
 Parser_genln( p , _STR("; // %.*s", f ->name.len, f ->name.str) ) ;
 
 }
 ;
 
 Parser_genln( p , _STR("%.*s %.*s(%.*s) {", typ.len, typ.str, fn_name_cgen.len, fn_name_cgen.str, str_args.len, str_args.str) ) ;
 
 }
 ;
 
 if ( is_fn_header ) {
 /*if*/
 
 Parser_genln( p , _STR("%.*s %.*s(%.*s);", typ.len, typ.str, fn_name_cgen.len, fn_name_cgen.str, str_args.len, str_args.str) ) ;
 
 Parser_fgenln( p , tos2("") ) ;
 
 }
 ;
 
 if ( is_c ) {
 /*if*/
 
 Parser_fgenln( p , tos2("\n") ) ;
 
 }
 ;
 
 p ->cur_fn  =  f ;
 
 if (string_ne( receiver_typ , tos2("") ) ) {
 /*if*/
 
Type* receiver_T= Table_find_type(& /* ? */* p ->table , receiver_typ ) ;
 
 if ( Parser_first_run(& /* ? */* p )  && string_eq( receiver_T ->name , tos2("") ) ) {
 /*if*/
 
Type ttyp= (Type) { .name =  string_replace( receiver_typ , tos2("*") , tos2("") ) , .pkg =  p ->pkg , .is_placeholder =  1 , .fields = new_array(0, 1, sizeof(Var)) , .methods = new_array(0, 1, sizeof(Fn)) , .parent = tos("", 0) , .gen_types = new_array(0, 1, sizeof(string)) , .is_c = 0 , .is_interface = 0 , .is_enum = 0 , } ;
 
 Table_register_type2( p ->table , ttyp ) ;
 
 }
 ;
 
 Type_add_method( receiver_T ,* f ) ;
 
 }
  else { 
 /*else if*/
 
 Table_register_fn( p ->table ,* f ) ;
 
 }
 ;
 
 if ( is_sig  ||  Parser_first_run(& /* ? */* p )  ||  is_live  ||  is_fn_header  ||  skip_main_in_test ) {
 /*if*/
 
 if ( ! is_sig  &&  ! is_fn_header ) {
 /*if*/
 
 while (1) { 
 Parser_next( p ) ;
 
 if ( Token_is_decl( p ->tok ) ) {
 /*if*/
 
 break
 ;
 
 }
 ;
 
 }
 ;
 
 }
 ;
 
 if ( is_live  &&  Parser_first_run(& /* ? */* p ) ) {
 /*if*/
 
_PUSH(& p ->cgen ->so_fns , ( fn_name_cgen ), tmp46, string) ;
 
 fn_name_cgen  =  _STR("(* %.*s )", fn_name_cgen.len, fn_name_cgen.str) ;
 
 }
 ;
 
string fn_decl= _STR("%.*s %.*s(%.*s)", typ.len, typ.str, fn_name_cgen.len, fn_name_cgen.str, str_args.len, str_args.str) ;
 
 if ( p ->obfuscate ) {
 /*if*/
 
 fn_decl  = string_add( fn_decl , _STR("; // %.*s", f ->name.len, f ->name.str) ) ;
 
 }
 ;
 
 if ( ! is_c  && string_ne( f ->name , tos2("main") )  &&  Parser_first_run(& /* ? */* p ) ) {
 /*if*/
 
 if (string_eq( f ->name , tos2("darwin__nsstring") )  &&  p ->build_mode == DEFAULT_MODE ) {
 /*if*/

 
 return  ;
 
 }
 ;
 
_PUSH(& p ->cgen ->fns , (string_add( fn_decl , tos2(";") ) ), tmp48, string) ;
 
 }
 ;
 
 Parser_fgenln( p , tos2("\n") ) ;

 
 return  ;
 
 }
 ;
 
 if (string_eq( f ->name , tos2("main") )  || string_eq( f ->name , tos2("WinMain") ) ) {
 /*if*/
 
 Parser_genln( p , tos2("init_consts();") ) ;
 
 if ( array_string_contains( p ->table ->imports , tos2("os") ) ) {
 /*if*/
 
 if (string_eq( f ->name , tos2("main") ) ) {
 /*if*/
 
 Parser_genln( p , tos2("os__args = os__init_os_args(argc, argv);") ) ;
 
 }
  else  if (string_eq( f ->name , tos2("WinMain") ) ) {
 /*if*/
 
 Parser_genln( p , tos2("os__args = os__parse_windows_cmd_line(pCmdLine);") ) ;
 
 }
 ;
 
 }
 ;
 
 if ( p ->is_live ) {
 /*if*/
 
 Parser_genln( p , tos2("load_so(\"bounce.so\");") ) ;
 Parser_genln( p , tos2("pthread_t _thread_so;") ) ;
 Parser_genln( p , tos2("pthread_create(&_thread_so , NULL, &reload_so, NULL); ") ) ;
 //Parser_genln( p , tos2(" \nload_so(\"bounce.so\"); \npthread_t _thread_so;\npthread_create(&_thread_so , NULL, &reload_so, NULL); ") ) ;
 }
 ;
 
 if ( p ->is_test  &&  ! string_contains( p ->scanner ->file_path , tos2("/volt") ) ) {
 /*if*/
 
 Parser_error( p , tos2("tests cannot have function `main`") ) ;
 
 }
 ;
 
 }
 ;
 
 if ( is_c  ||  is_sig  ||  is_fn_header ) {
 /*if*/
 
 Parser_fgenln( p , tos2("\n") ) ;

 
 return  ;
 
 }
 ;
 
 if ( p ->is_prof  && string_ne( f ->name , tos2("main") )  && string_ne( f ->name , tos2("time__ticks") ) ) {
 /*if*/
 
 Parser_genln( p , _STR("double _PROF_START = time__ticks();//%.*s", f ->name.len, f ->name.str) ) ;
 
string cgen_name= Table_cgen_name( p ->table , f ) ;
 
 f ->defer  =  _STR("  %.*s_time += time__ticks() - _PROF_START;", cgen_name.len, cgen_name.str) ;
 
 }
 ;
 
 Parser_statements_no_curly_end( p ) ;
 
 if ( p ->is_prof  && string_eq( f ->name , tos2("main") ) ) {
 /*if*/
 
 Parser_genln( p , Parser_print_prof_counters( p ) ) ;
 
 }
 ;
 
 Parser_genln( p , f ->defer ) ;
 
 if (string_ne( typ , tos2("void") )  &&  ! p ->returns  && string_ne( f ->name , tos2("main") )  && string_ne( f ->name , tos2("WinMain") ) ) {
 /*if*/
 
 Parser_error( p , _STR("%.*s must return \"%.*s\"", f ->name.len, f ->name.str, typ.len, typ.str) ) ;
 
 }
 ;
 
 if (string_eq( p ->pkg , tos2("main") ) ) {
 /*if*/
 
 }
 ;
 
 if ( p ->cur_fn ->scope_level > 2 ) {
 /*if*/
 
 }
 ;
 
 if (string_ne( p ->pkg , tos2("main") ) ) {
 /*if*/
 
 Parser_genln( p , tos2("}") ) ;
 
 Parser_fgenln( p , tos2("\n") ) ;

 
 return  ;
 
 }
 ;
 
 Parser_check_unused_variables( p ) ;
 
 p ->cur_fn  =  main__EmptyFn ;
 
 Parser_fgenln( p , tos2("\n") ) ;
 
 Parser_genln( p , tos2("}") ) ;
 
 
 }
 void Parser_check_unused_variables(Parser* p) {
 
 array_Var tmp50 =  p ->cur_fn ->local_vars;
 ;
for (int tmp51 = 0; tmp51 < tmp50 .len; tmp51 ++) {
 Var var = ((Var *) tmp50.data)[tmp51];
 
 if (string_eq( var .name , tos2("") ) ) {
 /*if*/
 
 break
 ;
 
 }
 ;
 
 if ( ! var .is_used  &&  ! var .is_arg  &&  ! p ->translated  && string_ne( var .name , tos2("_") ) ) {
 /*if*/
 
 p ->scanner ->line_nr  =  var .line_nr - 1 ;
 
 Parser_error( p , _STR("`%.*s` declared and not used", var .name.len, var .name.str) ) ;
 
 }
 ;
 
 if ( p ->is_test  &&  string_contains( var .typ , tos2("array_") ) ) {
 /*if*/
 
 }
 ;
 
 }
 ;
 
 
 }
 void Parser_async_fn_call(Parser* p, Fn f, int method_ph, string receiver_var, string receiver_type) {
 
string thread_name= tos2("") ;
 
string fn_name= f .name ;
 
 if ( f .is_method ) {
 /*if*/
 
 receiver_type  =  string_replace( receiver_type , tos2("*") , tos2("") ) ;
 
 fn_name  =  _STR("%.*s_%.*s", receiver_type.len, receiver_type.str, f .name.len, f .name.str) ;
 
 }
 ;
 
string arg_struct_name= _STR("thread_arg_%.*s", fn_name.len, fn_name.str) ;
 
string tmp_struct= Parser_get_tmp( p ) ;
 
 Parser_genln( p , _STR("%.*s * %.*s = malloc(sizeof(%.*s));", arg_struct_name.len, arg_struct_name.str, tmp_struct.len, tmp_struct.str, arg_struct_name.len, arg_struct_name.str) ) ;
 
string arg_struct= _STR("typedef struct  %.*s   { ", arg_struct_name.len, arg_struct_name.str) ;
 
 Parser_next( p ) ;
 
 Parser_check( p , LPAR ) ;
 
string str_args= tos2("") ;
 
 array_Var tmp58 =  f .args ;
 ;
for (int i = 0; i < tmp58 .len; i ++) {
 Var arg = ((Var *) tmp58 . data)[i];
 
 arg_struct  = string_add( arg_struct , _STR("%.*s %.*s ;", arg .typ.len, arg .typ.str, arg .name.len, arg .name.str) ) ;
 
 str_args  = string_add( str_args , _STR("arg->%.*s", arg .name.len, arg .name.str) ) ;
 
 if ( i == 0  &&  f .is_method ) {
 /*if*/
 
 Parser_genln( p , _STR("%.*s -> %.*s =  %.*s ;", tmp_struct.len, tmp_struct.str, arg .name.len, arg .name.str, receiver_var.len, receiver_var.str) ) ;
 
 if ( i < f .args .len - 1 ) {
 /*if*/
 
 str_args  = string_add( str_args , tos2(",") ) ;
 
 }
 ;
 
 continue
 ;
 
 }
 ;
 
 Parser_genln( p , _STR("%.*s -> %.*s =  ", tmp_struct.len, tmp_struct.str, arg .name.len, arg .name.str) ) ;
 
 Parser_expression( p ) ;
 
 Parser_genln( p , tos2(";") ) ;
 
 if ( i < f .args .len - 1 ) {
 /*if*/
 
 Parser_check( p , COMMA ) ;
 
 str_args  = string_add( str_args , tos2(",") ) ;
 
 }
 ;
 
 }
 ;
 
 arg_struct  = string_add( arg_struct , _STR("} %.*s ;", arg_struct_name.len, arg_struct_name.str) ) ;
 
 fn_name  =  Table_cgen_name( p ->table ,& /*11 EXP:"Fn*" GOT:"Fn" */ f ) ;
 
string wrapper_name= _STR("%.*s_thread_wrapper", fn_name.len, fn_name.str) ;
 
string wrapper_text= _STR("void* %.*s(%.*s * arg) {%.*s( /*f*/%.*s );  }", wrapper_name.len, wrapper_name.str, arg_struct_name.len, arg_struct_name.str, fn_name.len, fn_name.str, str_args.len, str_args.str) ;
 
 CGen_register_thread_fn( p ->cgen , wrapper_name , wrapper_text , arg_struct ) ;
 
int tmp_nr= Parser_get_tmp_counter( p ) ;
 
 thread_name  =  _STR("_thread%d", tmp_nr) ;
 
 if ( p ->os != WINDOWS ) {
 /*if*/
 
 Parser_genln( p , _STR("pthread_t %.*s;", thread_name.len, thread_name.str) ) ;
 
 }
 ;
 
string tmp2= Parser_get_tmp( p ) ;
 
string parg= tos2("NULL") ;
 
 if ( f .args .len > 0 ) {
 /*if*/
 
 parg  =  _STR(" %.*s", tmp_struct.len, tmp_struct.str) ;
 
 }
 ;
 
 if ( p ->os == WINDOWS ) {
 /*if*/
 
 Parser_genln( p , _STR(" CreateThread(0,0, %.*s, %.*s, 0,0);", wrapper_name.len, wrapper_name.str, parg.len, parg.str) ) ;
 
 }
  else { 
 /*else if*/
 
 Parser_genln( p , _STR("int %.*s = pthread_create(& %.*s, NULL, %.*s, %.*s);", tmp2.len, tmp2.str, thread_name.len, thread_name.str, wrapper_name.len, wrapper_name.str, parg.len, parg.str) ) ;
 
 }
 ;
 
 Parser_check( p , RPAR ) ;
 
 
 }
 void Parser_fn_call(Parser* p, Fn f, int method_ph, string receiver_var, string receiver_type) {
 
 if ( ! f .is_public  &&  ! f .is_c  &&  ! p ->is_test  && string_ne( f .pkg , p ->pkg ) ) {
 /*if*/
 
 Parser_error( p , _STR("function `%.*s` is private", f .name.len, f .name.str) ) ;
 
 }
 ;
 
 p ->calling_c  =  f .is_c ;
 
bool is_print= p ->is_prod  &&  ! p ->is_test  &&  ! p ->builtin_pkg  &&  f .is_c  && string_eq( f .name , tos2("printf") ) ;
 
 if ( ! p ->cgen ->nogen ) {
 /*if*/
 
 p ->cgen ->nogen  =  is_print ;
 
 }
 ;
 
string cgen_name= Table_cgen_name( p ->table ,& /*11 EXP:"Fn*" GOT:"Fn" */ f ) ;
 
 if ( ! f .is_method ) {
 /*if*/
 
 Parser_gen( p , cgen_name ) ;
 
 Parser_gen( p , tos2("(") ) ;
 
 }
  else { 
 /*else if*/
 
string method_call= _STR("%.*s(", cgen_name.len, cgen_name.str) ;
 
Var receiver=*(Var*)  array_first( f .args ) ;
 
 if ( receiver .is_mut  &&  ! p ->expr_var .is_mut ) {
 /*if*/
 
 println ( _STR("%.*s  recv=%.*s recv_mut=%d", method_call.len, method_call.str, receiver .name.len, receiver .name.str, receiver .is_mut) ) ;
 
 Parser_error( p , _STR("`%.*s` is immutable", p ->expr_var .name.len, p ->expr_var .name.str) ) ;
 
 }
 ;
 
 if ( receiver .ref  ||  (/*lpar*/ receiver .is_mut  &&  ! string_contains( receiver_type , tos2("*") ) ) ) {
 /*if*/
 
 method_call  = string_add( method_call , tos2("& /* ? */") ) ;
 
 }
 ;
 
 if ( ! receiver .is_mut  &&  string_contains( receiver_type , tos2("*") ) ) {
 /*if*/
 
 method_call  = string_add( method_call , tos2("*") ) ;
 
 }
 ;
 
string cast= tos2("") ;
 
 if (string_eq( f .typ , tos2("void*") ) ) {
 /*if*/
 
 cast  =  string_all_after( receiver_type , tos2("_") ) ;
 
 cast  =  _STR("*(%.*s*) ", cast.len, cast.str) ;
 
 }
 ;
 
 CGen_set_placeholder( p ->cgen , method_ph , _STR("%.*s %.*s", cast.len, cast.str, method_call.len, method_call.str) ) ;
 
 }
 ;
 
 Parser_next( p ) ;
 
 Parser_fn_call_args( p ,& /*11 EXP:"Fn*" GOT:"Fn" */ f ) ;
 
 Parser_gen( p , tos2(")") ) ;
 
 p ->calling_c  =  0 ;
 
 if ( is_print ) {
 /*if*/
 
 p ->cgen ->nogen  =  0 ;
 
 }
 ;
 
 
 }
 void Parser_fn_args(Parser* p, Fn* f) {
 
 Parser_check( p , LPAR ) ;
 
 if ( f ->is_interface ) {
 /*if*/
 
Var int_arg= (Var) { .typ =  f ->receiver_typ , .name = tos("", 0) , .is_arg = 0 , .is_const = 0 , .is_import_const = 0 , .args = new_array(0, 1, sizeof(Var)) , .attr = tos("", 0) , .is_mut = 0 , .ptr = 0 , .ref = 0 , .parent_fn = tos("", 0) , .pkg = tos("", 0) , .line_nr = 0 , .is_global = 0 , .is_used = 0 , .scope_level = 0 } ;
 
_PUSH(& f ->args , ( int_arg ), tmp70, Var) ;
 
 }
 ;
 
bool types_only= p ->tok == MUL  ||  (/*lpar*/ Parser_peek( p ) == COMMA  &&  Table_known_type(& /* ? */* p ->table , p ->lit ) )  ||  Parser_peek( p ) == RPAR ;
 
 if ( types_only ) {
 /*if*/
 
 while ( p ->tok != RPAR ) {
 
string typ= Parser_get_type( p ) ;
 
Var v= (Var) { .typ =  typ , .is_arg =  1 , .line_nr =  p ->scanner ->line_nr , .name = tos("", 0) , .is_const = 0 , .is_import_const = 0 , .args = new_array(0, 1, sizeof(Var)) , .attr = tos("", 0) , .is_mut = 0 , .ptr = 0 , .ref = 0 , .parent_fn = tos("", 0) , .pkg = tos("", 0) , .is_global = 0 , .is_used = 0 , .scope_level = 0 } ;
 
_PUSH(& f ->args , ( v ), tmp74, Var) ;
 
 if ( p ->tok == COMMA ) {
 /*if*/
 
 Parser_next( p ) ;
 
 }
 ;
 
 }
 ;
 
 }
 ;
 
 while ( p ->tok != RPAR ) {
 
array_string names=new_array_from_c_array(1, 1, sizeof(string), (string[]) {  Parser_check_name( p )  }) ;
 
 while ( p ->tok == COMMA ) {
 
 Parser_check( p , COMMA ) ;
 
 Parser_fspace( p ) ;
 
_PUSH(& names , ( Parser_check_name( p ) ), tmp76, string) ;
 
 }
 ;
 
 Parser_fspace( p ) ;
 
bool is_mut= p ->tok == MUT ;
 
 if ( is_mut ) {
 /*if*/
 
 Parser_next( p ) ;
 
 }
 ;
 
string typ2= Parser_get_type( p ) ;
 
 array_string tmp79 =  names;
 ;
for (int tmp80 = 0; tmp80 < tmp79 .len; tmp80 ++) {
 string name = ((string *) tmp79.data)[tmp80];
 
 if ( ! Parser_first_run(& /* ? */* p )  &&  ! Table_known_type(& /* ? */* p ->table , typ2 ) ) {
 /*if*/
 
 Parser_error( p , _STR("fn_args: unknown type %.*s", typ2.len, typ2.str) ) ;
 
 }
 ;
 
 if ( is_mut ) {
 /*if*/
 
 typ2  = string_add( typ2 , tos2("*") ) ;
 
 }
 ;
 
Var v= (Var) { .name =  name , .typ =  typ2 , .is_arg =  1 , .is_mut =  is_mut , .ptr =  is_mut , .line_nr =  p ->scanner ->line_nr , .is_const = 0 , .is_import_const = 0 , .args = new_array(0, 1, sizeof(Var)) , .attr = tos("", 0) , .ref = 0 , .parent_fn = tos("", 0) , .pkg = tos("", 0) , .is_global = 0 , .is_used = 0 , .scope_level = 0 } ;
 
 Fn_register_var( f , v ) ;
 
_PUSH(& f ->args , ( v ), tmp82, Var) ;
 
 }
 ;
 
 if ( p ->tok == COMMA ) {
 /*if*/
 
 Parser_next( p ) ;
 
 }
 ;
 
 if ( p ->tok == DOTDOT ) {
 /*if*/
 
_PUSH(& f ->args , ( (Var) { .name =  tos2("..") , .typ = tos("", 0) , .is_arg = 0 , .is_const = 0 , .is_import_const = 0 , .args = new_array(0, 1, sizeof(Var)) , .attr = tos("", 0) , .is_mut = 0 , .ptr = 0 , .ref = 0 , .parent_fn = tos("", 0) , .pkg = tos("", 0) , .line_nr = 0 , .is_global = 0 , .is_used = 0 , .scope_level = 0 } ), tmp83, Var) ;
 
 Parser_next( p ) ;
 
 }
 ;
 
 }
 ;
 
 Parser_check( p , RPAR ) ;
 
 
 }
 Fn* Parser_fn_call_args(Parser* p, Fn* f) {
 
 Parser_check( p , LPAR ) ;
 
 if ( f ->is_c ) {
 /*if*/
 
 while ( p ->tok != RPAR ) {
 
 Parser_bool_expression( p ) ;
 
 if ( p ->tok == COMMA ) {
 /*if*/
 
 Parser_gen( p , tos2(", ") ) ;
 
 Parser_check( p , COMMA ) ;
 
 }
 ;
 
 }
 ;
 
 Parser_check( p , RPAR ) ;

 
 return  f ;
 
 }
 ;
 
 array_Var tmp84 =  f ->args ;
 ;
for (int i = 0; i < tmp84 .len; i ++) {
 Var arg = ((Var *) tmp84 . data)[i];
 
 if ( i == 0  &&  f ->is_method ) {
 /*if*/
 
 if ( f ->args .len > 1 ) {
 /*if*/
 
 Parser_gen( p , tos2(",") ) ;
 
 }
 ;
 
 continue
 ;
 
 }
 ;
 
 if ( i == f ->args .len - 1  && string_eq( arg .name , tos2("..") ) ) {
 /*if*/
 
 break
 ;
 
 }
 ;
 
int amp_ph= CGen_add_placeholder( p ->cgen ) ;
 
 if ( p ->tok == RPAR ) {
 /*if*/
 
string str_args= Fn_str_args(& /* ? */* f , p ->table ) ;
 
 Parser_error( p , _STR("not enough arguments in call to `%.*s (%.*s)`", f ->name.len, f ->name.str, str_args.len, str_args.str) ) ;
 
 }
 ;
 
 if ( arg .is_mut ) {
 /*if*/
 
 if ( p ->tok != MUT ) {
 /*if*/
 
 Parser_error( p , _STR("`%.*s` is a mutable argument, you need to provide `mut`: `%.*s(...mut a...)`", arg .name.len, arg .name.str, f ->name.len, f ->name.str) ) ;
 
 }
 ;
 
 if ( Parser_peek( p ) != NAME ) {
 /*if*/
 
 Parser_error( p , _STR("`%.*s` is a mutable argument, you need to provide a variable to modify: `%.*s(... mut a...)`", arg .name.len, arg .name.str, f ->name.len, f ->name.str) ) ;
 
 }
 ;
 
 Parser_check( p , MUT ) ;
 
 }
 ;
 
string typ= Parser_bool_expression( p ) ;
 
 if ( i == 0  && string_eq( f ->name , tos2("println") )  && string_ne( typ , tos2("string") )  && string_ne( typ , tos2("void") ) ) {
 /*if*/
 
Type* T= Table_find_type(& /* ? */* p ->table , typ ) ;
 
 if (string_eq( typ , tos2("u8") ) ) {
 /*if*/
 
 CGen_set_placeholder( p ->cgen , amp_ph , tos2("u8_str(") ) ;
 
 }
  else  if (string_eq( T ->parent , tos2("int") ) ) {
 /*if*/
 
 CGen_set_placeholder( p ->cgen , amp_ph , tos2("int_str(") ) ;
 
 }
  else  if ( string_ends_with( typ , tos2("*") ) ) {
 /*if*/
 
 CGen_set_placeholder( p ->cgen , amp_ph , tos2("ptr_str(") ) ;
 
 }
  else { 
 /*else if*/
 
 if ( ! Type_has_method(& /* ? */* T , tos2("str") ) ) {
 /*if*/
 
 if ( T ->fields .len > 0 ) {
 /*if*/
 
int index= p ->cgen ->cur_line .len - 1 ;
 
 while ( index > 0  &&  string_at( p ->cgen ->cur_line , index) != ' ' ) {
 
 index -- ;
 
 }
 ;
 
string name= string_right( p ->cgen ->cur_line , index + 1 ) ;
 
 if (string_eq( name , tos2("}") ) ) {
 /*if*/
 
 Parser_error( p , _STR("`%.*s` needs to have method `str() string` to be printable", typ.len, typ.str) ) ;
 
 }
 ;
 
 p ->cgen ->cur_line  =  string_left( p ->cgen ->cur_line , index ) ;
 
 Parser_create_type_string( p ,* T , name ) ;
 
 string_replace( p ->cgen ->cur_line , typ , tos2("") ) ;
 
 Parser_next( p ) ;

 
 return  Parser_fn_call_args( p , f ) ;
 
 }
 ;
 
 Parser_error( p , _STR("`%.*s` needs to have method `str() string` to be printable", typ.len, typ.str) ) ;
 
 }
 ;
 
 CGen_set_placeholder( p ->cgen , amp_ph , _STR("%.*s_str(", typ.len, typ.str) ) ;
 
 }
 ;
 
 Parser_gen( p , tos2(")") ) ;
 
 continue
 ;
 
 }
 ;
 
string got= typ ;
 
string expected= arg .typ ;
 
 if ( ! Parser_check_types_no_throw( p , got , expected ) ) {
 /*if*/
 
string err= _STR("Fn \"%.*s\" wrong arg #%d. ", f ->name.len, f ->name.str, i + 1) ;
 
 err  = string_add( err , _STR("Expected \"%.*s\" (%.*s)  but got \"%.*s\"", arg .typ.len, arg .typ.str, arg .name.len, arg .name.str, typ.len, typ.str) ) ;
 
 Parser_error( p , err ) ;
 
 }
 ;
 
bool is_interface= Table_is_interface(& /* ? */* p ->table , arg .typ ) ;
 
 if ( ! is_interface ) {
 /*if*/
 
 if ( string_contains( got , tos2("*") )  &&  ! string_contains( expected , tos2("*") ) ) {
 /*if*/
 
 CGen_set_placeholder( p ->cgen , amp_ph , tos2("*") ) ;
 
 }
 ;
 
 if ( ! string_contains( got , tos2("*") )  &&  string_contains( expected , tos2("*") )  && string_ne( got , tos2("voidptr") ) ) {
 /*if*/
 
 if ( ! (/*lpar*/string_eq( expected , tos2("void*") )  && string_eq( got , tos2("int") ) )  &&  ! (/*lpar*/string_eq( expected , tos2("byte*") )  &&  string_contains( got , tos2("]byte") ) )  &&  ! (/*lpar*/string_eq( expected , tos2("byte*") )  && string_eq( got , tos2("string") ) ) ) {
 /*if*/
 
 CGen_set_placeholder( p ->cgen , amp_ph , _STR("& /*11 EXP:\"%.*s\" GOT:\"%.*s\" */", expected.len, expected.str, got.len, got.str) ) ;
 
 }
 ;
 
 }
 ;
 
 }
 ;
 
 if ( is_interface ) {
 /*if*/
 
 if ( ! string_contains( got , tos2("*") ) ) {
 /*if*/
 
 CGen_set_placeholder( p ->cgen , amp_ph , tos2("&") ) ;
 
 }
 ;
 
Type* interface_type= Table_find_type(& /* ? */* p ->table , arg .typ ) ;
 
 array_Fn tmp98 =  interface_type ->methods;
 ;
for (int tmp99 = 0; tmp99 < tmp98 .len; tmp99 ++) {
 Fn method = ((Fn *) tmp98.data)[tmp99];
 
 Parser_gen( p , _STR(", %.*s_%.*s ", typ.len, typ.str, method .name.len, method .name.str) ) ;
 
 }
 ;
 
 }
 ;
 
 if ( i < f ->args .len - 1 ) {
 /*if*/
 
bool is_vararg= i == f ->args .len - 2  && string_eq( ( *(Var*) array__get( f ->args , i + 1) ) .name , tos2("..") ) ;
 
 if ( p ->tok != COMMA  &&  ! is_vararg ) {
 /*if*/
 
 Parser_error( p , _STR("wrong number of arguments for %d,%.*s fn `%.*s`: expected %d, but got less", i, arg .name.len, arg .name.str, f ->name.len, f ->name.str, f ->args .len) ) ;
 
 }
 ;
 
 if ( p ->tok == COMMA ) {
 /*if*/
 
 Parser_fgen( p , tos2(", ") ) ;
 
 }
 ;
 
 if ( ! is_vararg ) {
 /*if*/
 
 Parser_next( p ) ;
 
 Parser_gen( p , tos2(",") ) ;
 
 }
 ;
 
 }
 ;
 
 }
 ;
 
 if ( f ->args .len > 0 ) {
 /*if*/
 
Var last_arg=*(Var*)  array_last( f ->args ) ;
 
 if (string_eq( last_arg .name , tos2("..") ) ) {
 /*if*/
 
 println ( tos2("GOT VAR ARGS AFTER") ) ;
 
 while ( p ->tok != RPAR ) {
 
 if ( p ->tok == COMMA ) {
 /*if*/
 
 Parser_gen( p , tos2(",") ) ;
 
 Parser_check( p , COMMA ) ;
 
 }
 ;
 
 Parser_bool_expression( p ) ;
 
 }
 ;
 
 }
 ;
 
 }
 ;
 
 if ( p ->tok == COMMA ) {
 /*if*/
 
 Parser_error( p , _STR("wrong number of arguments for fn `%.*s`: expected %d, but got more", f ->name.len, f ->name.str, f ->args .len) ) ;
 
 }
 ;
 
 Parser_check( p , RPAR ) ;
 
 
 }
 bool contains_capital(string s) {
 
 for (
int i= 0  ;  i < s .len  ;  i ++ ) { 
 
byte c= string_at( s , i) ;
 
 if ( c >= 'A'  &&  c <= 'Z' ) {
 /*if*/

 
 return  1 ;
 
 }
 ;
 
 }
 ;

 
 return  0 ;
 
 
 }
 string Fn_typ_str(Fn f) {
 
StringBuilder sb= new_string_builder ( 50 ) ;
 
 StringBuilder_write(& /* ? */ sb , tos2("fn (") ) ;
 
 array_Var tmp109 =  f .args ;
 ;
for (int i = 0; i < tmp109 .len; i ++) {
 Var arg = ((Var *) tmp109 . data)[i];
 
 StringBuilder_write(& /* ? */ sb , arg .typ ) ;
 
 if ( i < f .args .len - 1 ) {
 /*if*/
 
 StringBuilder_write(& /* ? */ sb , tos2(",") ) ;
 
 }
 ;
 
 }
 ;
 
 StringBuilder_write(& /* ? */ sb , tos2(")") ) ;
 
 if (string_ne( f .typ , tos2("void") ) ) {
 /*if*/
 
 StringBuilder_write(& /* ? */ sb , _STR(" %.*s", f .typ.len, f .typ.str) ) ;
 
 }
 ;

 
 return  StringBuilder_str( sb ) ;
 
 
 }
 string Fn_str_args(Fn* f, Table* table) {
 
string s= tos2("") ;
 
 array_Var tmp111 =  f ->args ;
 ;
for (int i = 0; i < tmp111 .len; i ++) {
 Var arg = ((Var *) tmp111 . data)[i];
 
 if ( Table_is_interface(& /* ? */* table , arg .typ ) ) {
 /*if*/
 
 s  = string_add( s , _STR(" void* %.*s", arg .name.len, arg .name.str) ) ;
 
Type* interface_type= Table_find_type(& /* ? */* table , arg .typ ) ;
 
 array_Fn tmp113 =  interface_type ->methods;
 ;
for (int tmp114 = 0; tmp114 < tmp113 .len; tmp114 ++) {
 Fn method = ((Fn *) tmp113.data)[tmp114];
 
 s  = string_add( s , _STR(", %.*s (*%.*s_%.*s)(void*) ", method .typ.len, method .typ.str, arg .typ.len, arg .typ.str, method .name.len, method .name.str) ) ;
 
 }
 ;
 
 }
  else  if (string_eq( arg .name , tos2("..") ) ) {
 /*if*/
 
 s  = string_add( s , tos2("...") ) ;
 
 }
  else { 
 /*else if*/
 
 s  = string_add( s , Table_cgen_name_type_pair(& /* ? */* table , arg .name , arg .typ ) ) ;
 
 }
 ;
 
 if ( i < f ->args .len - 1 ) {
 /*if*/
 
 s  = string_add( s , tos2(", ") ) ;
 
 }
 ;
 
 }
 ;

 
 return  s ;
 
 
 }
 void Parser_gen_json_for_type(Parser* p, Type typ) {
 
string dec= tos2("") ;
 
string enc= tos2("") ;
 
string t= typ .name ;
 
 if (string_eq( t , tos2("int") )  || string_eq( t , tos2("string") )  || string_eq( t , tos2("bool") ) ) {
 /*if*/

 
 return  ;
 
 }
 ;
 
 if ( Parser_first_run(& /* ? */* p ) ) {
 /*if*/

 
 return  ;
 
 }
 ;
 
Fn dec_fn= (Fn) { .pkg =  p ->pkg , .typ =  _STR("Option_%.*s", typ .name.len, typ .name.str) , .name =  js_dec_name ( t ) , .local_vars = new_array(0, 1, sizeof(Var)) , .var_idx = 0 , .args = new_array(0, 1, sizeof(Var)) , .is_interface = 0 , .scope_level = 0 , .is_c = 0 , .receiver_typ = tos("", 0) , .is_public = 0 , .is_method = 0 , .returns_error = 0 , .is_decl = 0 , .defer = tos("", 0) } ;
 
 if ( Table_known_fn(& /* ? */* p ->table , dec_fn .name ) ) {
 /*if*/

 
 return  ;
 
 }
 ;
 
Var arg= (Var) { .typ =  tos2("cJSON*") , .name = tos("", 0) , .is_arg = 0 , .is_const = 0 , .is_import_const = 0 , .args = new_array(0, 1, sizeof(Var)) , .attr = tos("", 0) , .is_mut = 0 , .ptr = 0 , .ref = 0 , .parent_fn = tos("", 0) , .pkg = tos("", 0) , .line_nr = 0 , .is_global = 0 , .is_used = 0 , .scope_level = 0 } ;
 
_PUSH(& dec_fn .args , ( arg ), tmp6, Var) ;
 
 Table_register_fn( p ->table , dec_fn ) ;
 
Fn enc_fn= (Fn) { .pkg =  p ->pkg , .typ =  tos2("cJSON*") , .name =  js_enc_name ( t ) , .local_vars = new_array(0, 1, sizeof(Var)) , .var_idx = 0 , .args = new_array(0, 1, sizeof(Var)) , .is_interface = 0 , .scope_level = 0 , .is_c = 0 , .receiver_typ = tos("", 0) , .is_public = 0 , .is_method = 0 , .returns_error = 0 , .is_decl = 0 , .defer = tos("", 0) } ;
 
Var enc_arg= (Var) { .typ =  t , .name = tos("", 0) , .is_arg = 0 , .is_const = 0 , .is_import_const = 0 , .args = new_array(0, 1, sizeof(Var)) , .attr = tos("", 0) , .is_mut = 0 , .ptr = 0 , .ref = 0 , .parent_fn = tos("", 0) , .pkg = tos("", 0) , .line_nr = 0 , .is_global = 0 , .is_used = 0 , .scope_level = 0 } ;
 
_PUSH(& enc_fn .args , ( enc_arg ), tmp9, Var) ;
 
 Table_register_fn( p ->table , enc_fn ) ;
 
 dec  = string_add( dec , _STR("\n//%.*s %.*s(cJSON* root) {  \nOption %.*s(cJSON* root, %.*s* res) {  \n//  %.*s res; \n  if (!root) {\n    const char *error_ptr = cJSON_GetErrorPtr();\n    if (error_ptr != NULL)	{\n      fprintf(stderr, \"Error in decode() for %.*s error_ptr=: %%s\\n\", error_ptr);\n//      printf(\"\\nbad js=%%s\\n\", js.str); \n      return v_error(tos2(error_ptr));\n    }\n  }\n", t.len, t.str, dec_fn .name.len, dec_fn .name.str, dec_fn .name.len, dec_fn .name.str, t.len, t.str, t.len, t.str, t.len, t.str) ) ;
 
 enc  = string_add( enc , _STR("\ncJSON* %.*s(%.*s val) {  \ncJSON *o = cJSON_CreateObject();\nstring res = tos2(\"\"); \n", enc_fn .name.len, enc_fn .name.str, t.len, t.str) ) ;
 
 if ( string_starts_with( t , tos2("array_") ) ) {
 /*if*/
 
 dec  = string_add( dec , Parser_decode_array( p , t ) ) ;
 
 enc  = string_add( enc , Parser_encode_array(& /* ? */* p , t ) ) ;
 
 }
 ;
 
 array_Var tmp10 =  typ .fields;
 ;
for (int tmp11 = 0; tmp11 < tmp10 .len; tmp11 ++) {
 Var field = ((Var *) tmp10.data)[tmp11];
 
 if (string_eq( field .attr , tos2("skip") ) ) {
 /*if*/
 
 continue
 ;
 
 }
 ;
 
Type* field_type= Table_find_type(& /* ? */* p ->table , field .typ ) ;
 
 Parser_gen_json_for_type( p ,* field_type ) ;
 
string name= field .name ;
 
string _typ= string_replace( field .typ , tos2("*") , tos2("") ) ;
 
string enc_name= js_enc_name ( _typ ) ;
 
string dec_name= js_dec_name ( _typ ) ;
 
 if ( is_js_prim ( _typ ) ) {
 /*if*/
 
 dec  = string_add( dec , _STR(" /*prim*/ res->%.*s = %.*s(js_get(root, \"%.*s\"))", name.len, name.str, dec_name.len, dec_name.str, field .name.len, field .name.str) ) ;
 
 }
  else { 
 /*else if*/
 
 dec  = string_add( dec , _STR(" /*!!*/ %.*s(js_get(root, \"%.*s\"), & (res->%.*s))", dec_name.len, dec_name.str, field .name.len, field .name.str, name.len, name.str) ) ;
 
 }
 ;
 
 dec  = string_add( dec , tos2(";\n") ) ;
 
 enc  = string_add( enc , _STR("  cJSON_AddItemToObject(o,  \"%.*s\", %.*s(val.%.*s)); \n", name.len, name.str, enc_name.len, enc_name.str, name.len, name.str) ) ;
 
 }
 ;
 
_PUSH(& p ->cgen ->fns , ( _STR("%.*s return opt_ok(res); \n}", dec.len, dec.str) ), tmp17, string) ;
 
_PUSH(& p ->cgen ->fns , ( _STR("/*enc start*/ %.*s return o;}", enc.len, enc.str) ), tmp18, string) ;
 
 
 }
 bool is_js_prim(string typ) {

 
 return string_eq( typ , tos2("int") )  || string_eq( typ , tos2("string") )  || string_eq( typ , tos2("bool") )  || string_eq( typ , tos2("f32") )  || string_eq( typ , tos2("f64") )  || string_eq( typ , tos2("i8") )  || string_eq( typ , tos2("i16") )  || string_eq( typ , tos2("i32") )  || string_eq( typ , tos2("i64") ) ;
 
 
 }
 string Parser_decode_array(Parser* p, string typ) {
 
 typ  =  string_replace( typ , tos2("array_") , tos2("") ) ;
 
Type* t= Table_find_type(& /* ? */* p ->table , typ ) ;
 
string fn_name= js_dec_name ( typ ) ;
 
 Parser_gen_json_for_type( p ,* t ) ;
 
string s= tos2("") ;
 
 if ( is_js_prim ( typ ) ) {
 /*if*/
 
 s  =  _STR("%.*s val= %.*s(jsval); ", typ.len, typ.str, fn_name.len, fn_name.str) ;
 
 }
  else { 
 /*else if*/
 
 s  =  _STR("  %.*s val; %.*s(jsval, &val); ", typ.len, typ.str, fn_name.len, fn_name.str) ;
 
 }
 ;

 
 return  _STR("\n*res = new_array(0, 0, sizeof(%.*s));\nconst cJSON *jsval = NULL;\ncJSON_ArrayForEach(jsval, root)\n{\n%.*s \n  array__push(res, &val);\n}\n", typ.len, typ.str, s.len, s.str) ;
 
 
 }
 string js_enc_name(string typ) {
 
string name= _STR("json__jsencode_%.*s", typ.len, typ.str) ;

 
 return  name ;
 
 
 }
 string js_dec_name(string typ) {
 
string name= _STR("json__jsdecode_%.*s", typ.len, typ.str) ;

 
 return  name ;
 
 
 }
 string Parser_encode_array(Parser* p, string typ) {
 
 typ  =  string_replace( typ , tos2("array_") , tos2("") ) ;
 
string fn_name= js_enc_name ( typ ) ;

 
 return  _STR("\no = cJSON_CreateArray();\nfor (int i = 0; i < val.len; i++){\n  cJSON_AddItemToArray(o, %.*s(  ((%.*s*)val.data)[i]  ));\n} \n", fn_name.len, fn_name.str, typ.len, typ.str) ;
 
 
 }
 string vtmp_path() {

 
 return string_add( os__home_dir ( ) , tos2("/.vlang/") ) ;
 
 
 }
 int main(int argc, char** argv) {
 init_consts();
 os__args = os__init_os_args(argc, argv);
 
array_string args= os__args ;
 
 if (_IN(string,  tos2("-v") ,  args )  || _IN(string,  tos2("version") ,  args ) ) {
 /*if*/
 
 println ( _STR("V %.*s", main__Version.len, main__Version.str) ) ;

 
 return   0 ;
 
 }
 ;
 
 if (_IN(string,  tos2("-h") ,  args )  || _IN(string,  tos2("--help") ,  args )  || _IN(string,  tos2("help") ,  args ) ) {
 /*if*/
 
 println ( main__HelpText ) ;

 
 return   0 ;
 
 }
 ;
 
 if (_IN(string,  tos2("translate") ,  args ) ) {
 /*if*/
 
 println ( tos2("Translating C to V will be available in V 0.3") ) ;

 
 return   0 ;
 
 }
 ;
 
 if ( ! os__file_exists ( main__TmpPath ) ) {
 /*if*/
 
 os__mkdir ( main__TmpPath ) ;
 
 }
 ;
 
 if ( array_string_contains( args , tos2("fmt") ) ) {
 /*if*/
 
string file=*(string*)  array_last( args ) ;
 
 if ( ! os__file_exists ( file ) ) {
 /*if*/
 
 println ( _STR("\"%.*s\" does not exist", file.len, file.str) ) ;
 
 v_exit ( 1 ) ;
 
 }
 ;
 
 if ( ! string_ends_with( file , tos2(".v") ) ) {
 /*if*/
 
 println ( tos2("v fmt can only be used on .v files") ) ;
 
 v_exit ( 1 ) ;
 
 }
 ;
 
 println ( tos2("vfmt is temporarily disabled") ) ;

 
 return   0 ;
 
 }
 ;
 
 if ( args .len < 2  ||  (/*lpar*/ args .len == 2  && string_eq( ( *(string*) array__get( args , 1) ) , tos2("-") ) ) ) {
 /*if*/
 
 run_repl ( ) ;

 
 return   0 ;
 
 }
 ;
 
V* c= new_v ( args ) ;
 
 if ( c ->is_verbose ) {
 /*if*/
 
 println (array_string_str( args ) ) ;
 
 }
 ;
 
 if ( array_string_contains( args , tos2("doc") ) ) {
 /*if*/
 
 v_exit ( 0 ) ;
 
 }
 ;
 
 V_compile( c ) ;
 
 
 }
 void V_compile(V* c) {
 
CGen* cgen= c ->cgen ;
 
 CGen_genln( cgen , tos2("// Generated by V") ) ;
 
 V_add_user_v_files( c ) ;
 
 if ( c ->is_verbose ) {
 /*if*/
 
 println ( tos2("all .v files:") ) ;
 
 println (array_string_str( c ->files ) ) ;
 
 }
 ;
 
 array_string tmp7 =  c ->files;
 ;
for (int tmp8 = 0; tmp8 < tmp7 .len; tmp8 ++) {
 string file = ((string *) tmp7.data)[tmp8];
 
Parser p= V_new_parser( c , file , RUN_DECLS ) ;
 
 Parser_parse(& /* ? */ p ) ;
 
 }
 ;
 
 cgen ->run  =  RUN_MAIN ;
 
 if ( c ->is_play ) {
 /*if*/
 
 CGen_genln( cgen , tos2("#define VPLAY (1) ") ) ;
 
 }
 ;
 
 CGen_genln( cgen , tos2("   \n#include <stdio.h>  // TODO remove all these includes, define all function signatures and types manually \n#include <stdlib.h>\n#include <signal.h>\n#include <stdarg.h> // for va_list \n#include <inttypes.h>  // int64_t etc \n\n\n#ifdef __linux__ \n#include <pthread.h> \n#endif \n\n\n#ifdef __APPLE__ \n\n#endif \n\n\n#ifdef _WIN32 \n#include <windows.h>\n//#include <WinSock2.h> \n#endif \n\n//================================== TYPEDEFS ================================*/ \n\ntypedef unsigned char byte;\ntypedef unsigned int uint;\ntypedef int64_t i64;\ntypedef int32_t i32;\ntypedef int16_t i16;\ntypedef int8_t i8;\ntypedef uint64_t u64;\ntypedef uint32_t u32;\ntypedef uint16_t u16;\ntypedef uint8_t u8;\ntypedef uint32_t rune;\ntypedef float f32;\ntypedef double f64; \ntypedef unsigned char* byteptr;\ntypedef int* intptr;\ntypedef void* voidptr;\ntypedef struct array array;\ntypedef struct map map;\ntypedef array array_string; \ntypedef array array_int; \ntypedef array array_byte; \ntypedef array array_uint; \ntypedef array array_float; \ntypedef map map_int; \ntypedef map map_string; \n#ifndef bool\n	typedef int bool;\n	#define true 1\n	#define false 0\n#endif\n\n//============================== HELPER C MACROS =============================*/ \n\n#define _PUSH(arr, val, tmp, tmp_typ) {tmp_typ tmp = (val); array__push(arr, &tmp);}\n#define _IN(typ, val, arr) array_##typ##_contains(arr, val) \n#define ALLOC_INIT(type, ...) (type *)memdup((type[]){ __VA_ARGS__ }, sizeof(type)) \n#define UTF8_CHAR_LEN( byte ) (( 0xE5000000 >> (( byte >> 3 ) & 0x1e )) & 3 ) + 1 \n\n//================================== GLOBALS =================================*/   \n//int V_ZERO = 0; \nbyteptr g_str_buf; \nint load_so(byteptr);\nvoid reload_so();\nvoid init_consts();") ) ;
 
bool imports_json= array_string_contains( c ->table ->imports , tos2("json") ) ;
 
 if ( c ->os == MAC  &&  (/*lpar*/ (/*lpar*/ c ->build_mode == EMBED_VLIB  &&  array_string_contains( c ->table ->imports , tos2("ui") ) )  ||  (/*lpar*/ c ->build_mode == BUILD  &&  string_contains( c ->dir , tos2("/ui") ) ) ) ) {
 /*if*/
 
 CGen_genln( cgen , tos2("id defaultFont = 0; // main.v") ) ;
 
 }
 ;
 
 if ( imports_json  &&  c ->build_mode == EMBED_VLIB  ||  (/*lpar*/ c ->build_mode == BUILD  &&  string_contains( c ->out_name , tos2("json.o") ) ) ) {
 /*if*/
 
 CGen_genln( cgen , tos2("#include \"cJSON.c\" ") ) ;
 
 }
 ;
 
 if ( c ->build_mode == DEFAULT_MODE ) {
 /*if*/
 
 if ( imports_json ) {
 /*if*/
 
 CGen_genln( cgen , tos2("#include \"cJSON.h\"") ) ;
 
 }
 ;
 
 }
 ;
 
 if ( c ->build_mode == EMBED_VLIB  ||  c ->build_mode == DEFAULT_MODE ) {
 /*if*/
 
 CGen_genln( cgen , tos2("int g_test_ok = 1; ") ) ;
 
 if ( array_string_contains( c ->table ->imports , tos2("json") ) ) {
 /*if*/
 
 CGen_genln( cgen , tos2(" \n#define js_get(object, key) cJSON_GetObjectItemCaseSensitive((object), (key))\n") ) ;
 
 }
 ;
 
 }
 ;
 
 if ( array_string_contains( os__args , tos2("-debug_alloc") ) ) {
 /*if*/
 
 CGen_genln( cgen , tos2("#define DEBUG_ALLOC 1") ) ;
 
 }
 ;
 
 CGen_genln( cgen , tos2("/*================================== FNS =================================*/") ) ;
 
 CGen_genln( cgen , tos2("this line will be replaced with definitions") ) ;
 
int defs_pos= cgen ->lines .len - 1 ;
 
 array_string tmp12 =  c ->files;
 ;
for (int tmp13 = 0; tmp13 < tmp12 .len; tmp13 ++) {
 string file = ((string *) tmp12.data)[tmp13];
 
Parser p= V_new_parser( c , file , RUN_MAIN ) ;
 
 Parser_parse(& /* ? */ p ) ;
 
 if ( ! c ->nofmt  &&  ! string_contains( file , tos2("/vlib/") ) ) {
 /*if*/
 
 }
 ;
 
 }
 ;
 
 V_log(& /* ? */* c , tos2("Done parsing.") ) ;
 
StringBuilder d= new_string_builder ( 10000 ) ;
 
 StringBuilder_writeln(& /* ? */ d , array_string_join_lines( cgen ->includes ) ) ;
 
 StringBuilder_writeln(& /* ? */ d , array_string_join_lines( cgen ->typedefs ) ) ;
 
 StringBuilder_writeln(& /* ? */ d , array_string_join_lines( cgen ->types ) ) ;
 
 StringBuilder_writeln(& /* ? */ d , tos2("\nstring _STR(const char*, ...);\n") ) ;
 
 StringBuilder_writeln(& /* ? */ d , tos2("\nstring _STR_TMP(const char*, ...);\n") ) ;
 
 StringBuilder_writeln(& /* ? */ d , array_string_join_lines( cgen ->fns ) ) ;
 
 StringBuilder_writeln(& /* ? */ d , array_string_join_lines( cgen ->consts ) ) ;
 
 StringBuilder_writeln(& /* ? */ d , array_string_join_lines( cgen ->thread_args ) ) ;
 
 if ( c ->is_prof ) {
 /*if*/
 
 StringBuilder_writeln(& /* ? */ d , tos2("; // Prof counters:") ) ;
 
 StringBuilder_writeln(& /* ? */ d , V_prof_counters( c ) ) ;
 
 }
 ;
 
string dd= StringBuilder_str( d ) ;
 
 array_set(& /* ? */ cgen ->lines , defs_pos ,& /*11 EXP:"void*" GOT:"string" */ dd ) ;
 
 if ( c ->build_mode == DEFAULT_MODE  ||  c ->build_mode == EMBED_VLIB ) {
 /*if*/
 
 CGen_genln( cgen , _STR("void init_consts() { g_str_buf=malloc(1000); %.*s }", array_string_join_lines( cgen ->consts_init ).len, array_string_join_lines( cgen ->consts_init ).str) ) ;
 
 CGen_genln( cgen , tos2("\nstring _STR(const char *fmt, ...) {\n	va_list argptr;\n	va_start(argptr, fmt);\n	size_t len = vsnprintf(0, 0, fmt, argptr) + 1;  \n	va_end(argptr);\n	byte* buf = malloc(len);  \n	va_start(argptr, fmt);\n	vsprintf(buf, fmt, argptr);\n	va_end(argptr);\n#ifdef DEBUG_ALLOC \n	puts(\"_STR:\"); \n	puts(buf); \n#endif \n	return tos2(buf);\n}\n\nstring _STR_TMP(const char *fmt, ...) {\n	va_list argptr;\n	va_start(argptr, fmt);\n	size_t len = vsnprintf(0, 0, fmt, argptr) + 1;  \n	va_end(argptr);\n	va_start(argptr, fmt);\n	vsprintf(g_str_buf, fmt, argptr);\n	va_end(argptr);\n#ifdef DEBUG_ALLOC \n	//puts(\"_STR_TMP:\"); \n	//puts(g_str_buf); \n#endif \n	return tos2(g_str_buf);\n}\n\n") ) ;
 
 }
 ;
 
 if ( c ->build_mode != BUILD ) {
 /*if*/
 
 if ( ! Table_main_exists(& /* ? */* c ->table )  &&  ! c ->is_test ) {
 /*if*/
 
 if ( c ->is_script ) {
 /*if*/
 
 CGen_genln( cgen , _STR("int main() { %.*s; return 0; }", cgen ->fn_main.len, cgen ->fn_main.str) ) ;
 
 }
  else { 
 /*else if*/
 
 println ( tos2("panic: function `main` is undeclared in the main module") ) ;
 
 }
 ;
 
 }
  else  if ( c ->is_test ) {
 /*if*/
 
 CGen_genln( cgen , tos2("int main() { init_consts();") ) ;
 
 array_Fn tmp17 =  c ->table ->fns;
 ;
for (int tmp18 = 0; tmp18 < tmp17 .len; tmp18 ++) {
 Fn v = ((Fn *) tmp17.data)[tmp18];
 
 if ( string_starts_with( v .name , tos2("test_") ) ) {
 /*if*/
 
 CGen_genln( cgen , _STR("%.*s();", v .name.len, v .name.str) ) ;
 
 }
 ;
 
 }
 ;
 
 CGen_genln( cgen , tos2("return g_test_ok == 0; }") ) ;
 
 }
 ;
 
 }
 ;
 
 if ( c ->is_live ) {
 /*if*/
 
 CGen_genln( cgen , tos2(" int load_so(byteptr path) {\n	 printf(\"load_so %s\\n\", path); dlclose(live_lib); live_lib = dlopen(path, RTLD_LAZY);\n	 if (!live_lib) {puts(\"open failed\"); exit(1); return 0;}\n	 ") ) ;
 
 array_string tmp19 =  cgen ->so_fns;
 ;
for (int tmp20 = 0; tmp20 < tmp19 .len; tmp20 ++) {
 string so_fn = ((string *) tmp19.data)[tmp20];
 
 CGen_genln( cgen , _STR("%.*s = dlsym(live_lib, \"%.*s\");  ", so_fn.len, so_fn.str, so_fn.len, so_fn.str) ) ;
 
 }
 ;
 
 CGen_genln( cgen , tos2("return 1; }") ) ;
 
 }
 ;
 
 CGen_save( cgen ) ;
 
 if ( c ->is_verbose ) {
 /*if*/
 
 V_log(& /* ? */* c , tos2("flags=") ) ;
 
 println (array_string_str( c ->table ->flags ) ) ;
 
 }
 ;
 
 V_cc( c ) ;
 
 if ( c ->is_test  ||  c ->is_run ) {
 /*if*/
 
 if ( 1  ||  c ->is_verbose ) {
 /*if*/
 
 println ( _STR("============ running %.*s ============", c ->out_name.len, c ->out_name.str) ) ;
 
 }
 ;
 
string cmd= ( string_starts_with( c ->out_name , tos2("/") ) ) ? ( c ->out_name ) : (string_add( tos2("./") , c ->out_name ) ) ;
 
 if ( os__args .len > 3 ) {
 /*if*/
 
 cmd  = string_add(string_add( cmd , tos2(" ") ) , array_string_join( array_right( os__args , 3 ) , tos2(" ") ) ) ;
 
 }
 ;
 
int ret= os__system ( cmd ) ;
 
 if ( ret != 0 ) {
 /*if*/
 
string s= os__exec ( cmd ) ;
 
 println ( s ) ;
 
 println ( tos2("ret not 0, exiting") ) ;
 
 v_exit ( 1 ) ;
 
 }
 ;
 
 }
 ;
 
 
 }
 void V_cc(V* c) {
 
bool linux_host=string_eq( os__user_os ( ) , tos2("linux") ) ;
 
 V_log(& /* ? */* c , _STR("cc() isprod=%d outname=%.*s", c ->is_prod, c ->out_name.len, c ->out_name.str) ) ;
 
array_string a=new_array_from_c_array(1, 1, sizeof(string), (string[]) {  tos2("-w")  }) ;
 
string flags= array_string_join( c ->table ->flags , tos2(" ") ) ;
 
 if ( c ->is_prod ) {
 /*if*/
 
_PUSH(& a , ( tos2("-O2") ), tmp27, string) ;
 
 }
  else { 
 /*else if*/
 
_PUSH(& a , ( tos2("-g") ), tmp28, string) ;
 
 }
 ;
 
string libs= tos2("") ;
 
 if ( c ->build_mode == BUILD ) {
 /*if*/
 
_PUSH(& a , ( tos2("-c") ), tmp30, string) ;
 
 }
  else  if ( c ->build_mode == EMBED_VLIB ) {
 /*if*/
 
 }
  else  if ( c ->build_mode == DEFAULT_MODE ) {
 /*if*/
 
 libs  =  _STR("%.*s/vlib/builtin.o", main__TmpPath.len, main__TmpPath.str) ;
 
 if ( ! os__file_exists ( libs ) ) {
 /*if*/
 
 println ( tos2("`builtin.o` not found") ) ;
 
 v_exit ( 1 ) ;
 
 }
 ;
 
 array_string tmp31 =  c ->table ->imports;
 ;
for (int tmp32 = 0; tmp32 < tmp31 .len; tmp32 ++) {
 string imp = ((string *) tmp31.data)[tmp32];
 
 if (string_eq( imp , tos2("webview") ) ) {
 /*if*/
 
 continue
 ;
 
 }
 ;
 
 libs  = string_add( libs , _STR(" %.*s/vlib/%.*s.o", main__TmpPath.len, main__TmpPath.str, imp.len, imp.str) ) ;
 
 }
 ;
 
 }
 ;
 
 if ( c ->sanitize ) {
 /*if*/
 
_PUSH(& a , ( tos2("-fsanitize=leak") ), tmp33, string) ;
 
 }
 ;
 
string sysroot= tos2("/Users/alex/tmp/lld/linuxroot/") ;
 
 if ( c ->os == LINUX  &&  ! linux_host ) {
 /*if*/
 
_PUSH(& a , ( _STR("-c --sysroot=%.*s -target x86_64-linux-gnu", sysroot.len, sysroot.str) ), tmp35, string) ;
 
 if ( ! string_ends_with( c ->out_name , tos2(".o") ) ) {
 /*if*/
 
 c ->out_name  = string_add( c ->out_name , tos2(".o") ) ;
 
 }
 ;
 
 }
 ;
 
_PUSH(& a , ( _STR("-o %.*s", c ->out_name.len, c ->out_name.str) ), tmp36, string) ;
 
_PUSH(& a , ( _STR("%.*s/%.*s", main__TmpPath.len, main__TmpPath.str, c ->out_name_c.len, c ->out_name_c.str) ), tmp37, string) ;
 
 if ( c ->os == MAC ) {
 /*if*/
 
_PUSH(& a , ( tos2("-mmacosx-version-min=10.7") ), tmp38, string) ;
 
 }
 ;
 
_PUSH(& a , ( flags ), tmp39, string) ;
 
_PUSH(& a , ( libs ), tmp40, string) ;
 
 if ( c ->os == MAC ) {
 /*if*/
 
_PUSH(& a , ( tos2("-x objective-c") ), tmp41, string) ;
 
 }
 ;
 
 if ( c ->os == LINUX  &&  c ->build_mode != BUILD ) {
 /*if*/
 
_PUSH(& a , ( tos2("-lm -ldl -lpthread") ), tmp42, string) ;
 
 }
 ;
 
string fast_clang= tos2("/usr/local/Cellar/llvm/8.0.0/bin/clang") ;
 
string args= array_string_join( a , tos2(" ") ) ;
 
string cmd= ( os__file_exists ( fast_clang ) ) ? ( _STR("%.*s -I. %.*s", fast_clang.len, fast_clang.str, args.len, args.str) ) : ( _STR("cc -I. %.*s", args.len, args.str) ) ;
 
 if ( c ->show_c_cmd  ||  c ->is_verbose ) {
 /*if*/
 
 println ( _STR("\n==========\n%.*s\n=========\n", cmd.len, cmd.str) ) ;
 
 }
 ;
 
string res= os__exec ( cmd ) ;
 
 if ( string_contains( res , tos2("error: ") ) ) {
 /*if*/
 
 println ( res ) ;
 
 v_panic ( tos2("clang error") ) ;
 
 }
 ;
 
 if ( c ->os == LINUX  &&  ! linux_host  &&  c ->build_mode != BUILD ) {
 /*if*/
 
 c ->out_name  =  string_replace( c ->out_name , tos2(".o") , tos2("") ) ;
 
string obj_file=string_add( c ->out_name , tos2(".o") ) ;
 
 println ( _STR("linux obj_file=%.*s out_name=%.*s", obj_file.len, obj_file.str, c ->out_name.len, c ->out_name.str) ) ;
 
string ress= os__exec (string_add(string_add(string_add(string_add(string_add(string_add(string_add(string_add( _STR("/usr/local/Cellar/llvm/8.0.0/bin/ld.lld --sysroot=%.*s ", sysroot.len, sysroot.str) , _STR("-v -o %.*s ", c ->out_name.len, c ->out_name.str) ) , tos2("-m elf_x86_64 -dynamic-linker /lib64/ld-linux-x86-64.so.2 ") ) , tos2("/usr/lib/x86_64-linux-gnu/crt1.o ") ) , _STR("%.*s/lib/x86_64-linux-gnu/libm-2.28.a ", sysroot.len, sysroot.str) ) , tos2("/usr/lib/x86_64-linux-gnu/crti.o ") ) , obj_file ) , tos2(" /usr/lib/x86_64-linux-gnu/libc.so ") ) , tos2("/usr/lib/x86_64-linux-gnu/crtn.o") ) ) ;
 
 println ( ress ) ;
 
 if ( string_contains( ress , tos2("error:") ) ) {
 /*if*/
 
 v_exit ( 1 ) ;
 
 }
 ;
 
 println ( _STR("linux cross compilation done. resulting binary: \"%.*s\"", c ->out_name.len, c ->out_name.str) ) ;
 
 }
 ;
 
 
 }
 array_string V_v_files_from_dir(V* c, string dir) {
 
array_string res=new_array_from_c_array(0, 0, sizeof(string), (string[]) {   }) ;
 
 if ( ! os__file_exists ( dir ) ) {
 /*if*/
 
 v_panic ( _STR("%.*s doesn\'t exist", dir.len, dir.str) ) ;
 
 }
  else  if ( ! os__dir_exists ( dir ) ) {
 /*if*/
 
 v_panic ( _STR("%.*s isn\'t a directory", dir.len, dir.str) ) ;
 
 }
 ;
 
array_string files= os__ls ( dir ) ;
 
 if ( c ->is_verbose ) {
 /*if*/
 
 println ( _STR("v_files_from_dir (\"%.*s\")", dir.len, dir.str) ) ;
 
 }
 ;
 
 array_string_sort(& /* ? */ files ) ;
 
 array_string tmp51 =  files;
 ;
for (int tmp52 = 0; tmp52 < tmp51 .len; tmp52 ++) {
 string file = ((string *) tmp51.data)[tmp52];
 
 V_log(& /* ? */* c , _STR("F=%.*s", file.len, file.str) ) ;
 
 if ( ! string_ends_with( file , tos2(".v") )  &&  ! string_ends_with( file , tos2(".vh") ) ) {
 /*if*/
 
 continue
 ;
 
 }
 ;
 
 if ( string_ends_with( file , tos2("_test.v") ) ) {
 /*if*/
 
 continue
 ;
 
 }
 ;
 
 if ( string_ends_with( file , tos2("_win.v") )  &&  c ->os != WINDOWS ) {
 /*if*/
 
 continue
 ;
 
 }
 ;
 
 if ( string_ends_with( file , tos2("_lin.v") )  &&  c ->os != LINUX ) {
 /*if*/
 
 continue
 ;
 
 }
 ;
 
 if ( string_ends_with( file , tos2("_mac.v") )  &&  c ->os != MAC ) {
 /*if*/
 
string lin_file= string_replace( file , tos2("_mac.v") , tos2("_lin.v") ) ;
 
 if ( os__file_exists ( _STR("%.*s/%.*s", dir.len, dir.str, lin_file.len, lin_file.str) ) ) {
 /*if*/
 
 continue
 ;
 
 }
  else  if ( c ->os == WINDOWS ) {
 /*if*/
 
 continue
 ;
 
 }
  else { 
 /*else if*/
 
 }
 ;
 
 }
 ;
 
_PUSH(& res , ( _STR("%.*s/%.*s", dir.len, dir.str, file.len, file.str) ), tmp54, string) ;
 
 }
 ;

 
 return  res ;
 
 
 }
 void V_add_user_v_files(V* c) {
 
string dir= c ->dir ;
 
 V_log(& /* ? */* c , _STR("add_v_files(%.*s)", dir.len, dir.str) ) ;
 
array_string user_files=new_array_from_c_array(0, 0, sizeof(string), (string[]) {   }) ;
 
bool is_test_with_imports= string_ends_with( dir , tos2("_test.v") )  &&  (/*lpar*/ string_contains( dir , tos2("/volt") )  ||  string_contains( dir , tos2("/c2volt") ) ) ;
 
 if ( is_test_with_imports ) {
 /*if*/
 
_PUSH(& user_files , ( dir ), tmp58, string) ;
 
int pos= string_last_index( dir , tos2("/") ) ;
 
 dir  = string_add( string_left( dir , pos ) , tos2("/") ) ;
 
 }
 ;
 
 if ( string_ends_with( dir , tos2(".v") ) ) {
 /*if*/
 
_PUSH(& user_files , ( dir ), tmp60, string) ;
 
 dir  =  string_all_before( dir , tos2("/") ) ;
 
 }
  else { 
 /*else if*/
 
array_string files= V_v_files_from_dir(& /* ? */* c , dir ) ;
 
 array_string tmp62 =  files;
 ;
for (int tmp63 = 0; tmp63 < tmp62 .len; tmp63 ++) {
 string file = ((string *) tmp62.data)[tmp63];
 
_PUSH(& user_files , ( file ), tmp64, string) ;
 
 }
 ;
 
 }
 ;
 
 if ( user_files .len == 0 ) {
 /*if*/
 
 println ( tos2("No input .v files") ) ;
 
 v_exit ( 1 ) ;
 
 }
 ;
 
 if ( c ->is_verbose ) {
 /*if*/
 
 V_log(& /* ? */* c , tos2("user_files:") ) ;
 
 println (array_string_str( user_files ) ) ;
 
 }
 ;
 
 array_string tmp65 =  user_files;
 ;
for (int tmp66 = 0; tmp66 < tmp65 .len; tmp66 ++) {
 string file = ((string *) tmp65.data)[tmp66];
 
Parser p= V_new_parser( c , file , RUN_IMPORTS ) ;
 
 Parser_parse(& /* ? */ p ) ;
 
 }
 ;
 
 if ( c ->build_mode == DEFAULT_MODE ) {
 /*if*/
 
 for (
int i= 0  ;  i < c ->table ->imports .len  ;  i ++ ) { 
 
string pkg= ( *(string*) array__get( c ->table ->imports , i) ) ;
 
array_string vfiles= V_v_files_from_dir(& /* ? */* c , _STR("%.*s/vlib/%.*s", main__TmpPath.len, main__TmpPath.str, pkg.len, pkg.str) ) ;
 
 array_string tmp73 =  vfiles;
 ;
for (int tmp74 = 0; tmp74 < tmp73 .len; tmp74 ++) {
 string file = ((string *) tmp73.data)[tmp74];
 
Parser p= V_new_parser( c , file , RUN_IMPORTS ) ;
 
 Parser_parse(& /* ? */ p ) ;
 
 }
 ;
 
 }
 ;
 
 }
  else { 
 /*else if*/
 
 for (
int i= 0  ;  i < c ->table ->imports .len  ;  i ++ ) { 
 
string pkg= ( *(string*) array__get( c ->table ->imports , i) ) ;
 
array_string vfiles= V_v_files_from_dir(& /* ? */* c , _STR("%.*s/vlib/%.*s", c ->lang_dir.len, c ->lang_dir.str, pkg.len, pkg.str) ) ;
 
 array_string tmp81 =  vfiles;
 ;
for (int tmp82 = 0; tmp82 < tmp81 .len; tmp82 ++) {
 string file = ((string *) tmp81.data)[tmp82];
 
Parser p= V_new_parser( c , file , RUN_IMPORTS ) ;
 
 Parser_parse(& /* ? */ p ) ;
 
 }
 ;
 
 }
 ;
 
 }
 ;
 
 if ( c ->is_verbose ) {
 /*if*/
 
 V_log(& /* ? */* c , tos2("imports:") ) ;
 
 println (array_string_str( c ->table ->imports ) ) ;
 
 }
 ;
 
 array_string tmp84 =  c ->table ->imports;
 ;
for (int tmp85 = 0; tmp85 < tmp84 .len; tmp85 ++) {
 string pkg = ((string *) tmp84.data)[tmp85];
 
string module_path= _STR("%.*s/vlib/%.*s", c ->lang_dir.len, c ->lang_dir.str, pkg.len, pkg.str) ;
 
 if ( c ->build_mode == DEFAULT_MODE  ||  c ->build_mode == BUILD ) {
 /*if*/
 
 module_path  =  _STR("%.*s/vlib/%.*s", main__TmpPath.len, main__TmpPath.str, pkg.len, pkg.str) ;
 
 }
 ;
 
array_string vfiles= V_v_files_from_dir(& /* ? */* c , module_path ) ;
 
 array_string tmp88 =  vfiles;
 ;
for (int tmp89 = 0; tmp89 < tmp88 .len; tmp89 ++) {
 string vfile = ((string *) tmp88.data)[tmp89];
 
_PUSH(& c ->files , ( vfile ), tmp90, string) ;
 
 }
 ;
 
 }
 ;
 
 array_string tmp91 =  user_files;
 ;
for (int tmp92 = 0; tmp92 < tmp91 .len; tmp92 ++) {
 string file = ((string *) tmp91.data)[tmp92];
 
_PUSH(& c ->files , ( file ), tmp93, string) ;
 
 }
 ;
 
 
 }
 string get_arg(string joined_args, string arg, string def) {
 
string key= _STR("-%.*s ", arg.len, arg.str) ;
 
int pos= string_index( joined_args , key ) ;
 
 if ( pos == - 1 ) {
 /*if*/

 
 return  def ;
 
 }
 ;
 
 pos  =  pos + key .len ;
 
int space= string_index_after( joined_args , tos2(" ") , pos ) ;
 
 if ( space == - 1 ) {
 /*if*/
 
 space  =  joined_args .len ;
 
 }
 ;
 
string res= string_substr( joined_args , pos , space ) ;

 
 return  res ;
 
 
 }
 void V_log(V* c, string s) {
 
 if ( ! c ->is_verbose ) {
 /*if*/

 
 return  ;
 
 }
 ;
 
 println ( s ) ;
 
 
 }
 V* new_v(array_string args) {
 
string dir=*(string*)  array_last( args ) ;
 
 if ( array_string_contains( args , tos2("run") ) ) {
 /*if*/
 
 dir  =  ( *(string*) array__get( args , 2) ) ;
 
 }
 ;
 
 if ( args .len < 2 ) {
 /*if*/
 
 dir  =  tos2("") ;
 
 }
 ;
 
string joined_args= array_string_join( args , tos2(" ") ) ;
 
string target_os= get_arg ( joined_args , tos2("os") , tos2("") ) ;
 
string out_name= get_arg ( joined_args , tos2("o") , tos2("a.out") ) ;
 
BuildMode build_mode= DEFAULT_MODE ;
 
 if ( array_string_contains( args , tos2("-lib") ) ) {
 /*if*/
 
 build_mode  =  BUILD ;
 
string base= string_all_after( dir , tos2("/") ) ;
 
 println ( _STR("Building module %.*s...", base.len, base.str) ) ;
 
 out_name  =  _STR("%.*s/vlib/%.*s.o", main__TmpPath.len, main__TmpPath.str, base.len, base.str) ;
 
 if (string_ne( target_os , os__user_os ( ) ) ) {
 /*if*/
 
 os__mkdir ( _STR("%.*s/vlib/%.*s", main__TmpPath.len, main__TmpPath.str, target_os.len, target_os.str) ) ;
 
 out_name  =  _STR("%.*s/vlib/%.*s/%.*s.o", main__TmpPath.len, main__TmpPath.str, target_os.len, target_os.str, base.len, base.str) ;
 
 println ( _STR("Cross compiling %.*s", out_name.len, out_name.str) ) ;
 
 }
 ;
 
 }
  else  if ( ! array_string_contains( args , tos2("-embed_vlib") ) ) {
 /*if*/
 
 build_mode  =  EMBED_VLIB ;
 
 }
 ;
 
bool is_test= string_ends_with( dir , tos2("_test.v") ) ;
 
bool is_script= string_ends_with( dir , tos2(".v") ) ;
 
 if ( is_script  &&  ! os__file_exists ( dir ) ) {
 /*if*/
 
 println ( _STR("`%.*s` does not exist", dir.len, dir.str) ) ;
 
 v_exit ( 1 ) ;
 
 }
 ;
 
 if (string_eq( out_name , tos2("a.out") )  &&  string_ends_with( dir , tos2(".v") ) ) {
 /*if*/
 
 out_name  =  string_left( dir , dir .len - 2 ) ;
 
 }
 ;
 
 if (string_eq( dir , tos2(".") )  && string_eq( out_name , tos2("a.out") ) ) {
 /*if*/
 
string base= string_all_after( os__getwd ( ) , tos2("/") ) ;
 
 out_name  =  string_trim_space( base ) ;
 
 }
 ;
 
Os _os= MAC ;
 
 if (string_eq( target_os , tos2("") ) ) {
 /*if*/
 
 #ifdef __linux__
 
 _os  =  LINUX ;
 
 #endif
 ;
 
 #ifdef __APPLE__
 
 _os  =  MAC ;
 
 #endif
 ;
 
 #ifdef _WIN32
 
 _os  =  WINDOWS ;
 
 #endif
 ;
 
 }
  else { 
 /*else if*/
 
 if ( string_eq( target_os,  tos2("linux") )) { /* case */
 
 _os  =  LINUX ;
 
 }
 else  if ( string_eq( target_os,  tos2("windows") )) { /* case */
 
 _os  =  WINDOWS ;
 
 }
 else  if ( string_eq( target_os,  tos2("mac") )) { /* case */
 
 _os  =  MAC ;
 
 }
 ;
 
 }
 ;
 
array_string builtins=new_array_from_c_array(8, 8, sizeof(string), (string[]) {  tos2("array.v") , tos2("string.v") , tos2("builtin.v") , tos2("int.v") , tos2("utf8.v") , tos2("map.v") , tos2("option.v") , tos2("string_builder.v") ,  }) ;
 
string lang_dir= tos2("") ;
 
 while (1) { 
string vroot_path=string_add( main__TmpPath , tos2("/VROOT") ) ;
 
 if ( os__file_exists ( vroot_path ) ) {
 /*if*/
 
Option_string tmp113 =  os__read_file ( vroot_path ) ; if (!tmp113 .ok) {
 
 break
 ;
 
 }
 string vroot = *(string*) tmp113 . data;
 ;
 
 vroot  =  string_trim_space( vroot ) ;
 
 if ( os__dir_exists ( vroot )  &&  os__dir_exists (string_add( vroot , tos2("/vlib/builtin") ) ) ) {
 /*if*/
 
 lang_dir  =  vroot ;
 
 }
 ;
 
 }
 ;
 
 break
 ;
 
 }
 ;
 
 if (string_eq( lang_dir , tos2("") ) ) {
 /*if*/
 
 println ( tos2("Looks like you are running V for the first time.") ) ;
 
 lang_dir  =  os__getwd ( ) ;
 
 if ( os__dir_exists ( _STR("%.*s/vlib/builtin", lang_dir.len, lang_dir.str) ) ) {
 /*if*/
 
 println ( _STR("Setting VROOT to \"%.*s\".", lang_dir.len, lang_dir.str) ) ;
 
 os__write_file (string_add( main__TmpPath , tos2("/VROOT") ) , lang_dir ) ;
 
 }
  else { 
 /*else if*/
 
 println ( tos2("V repo not found. Go to https://vlang.io to download V.zip ") ) ;
 
 println ( tos2("or install V from source.") ) ;
 
 v_exit ( 1 ) ;
 
 }
 ;
 
 }
 ;
 
string out_name_c=string_add( string_all_after( out_name , tos2("/") ) , tos2(".c") ) ;
 
array_string files=new_array_from_c_array(0, 0, sizeof(string), (string[]) {   }) ;
 
 if ( ! string_contains( out_name , tos2("builtin.o") ) ) {
 /*if*/
 
 array_string tmp116 =  builtins;
 ;
for (int tmp117 = 0; tmp117 < tmp116 .len; tmp117 ++) {
 string builtin = ((string *) tmp116.data)[tmp117];
 
string f= _STR("%.*s/vlib/builtin/%.*s", lang_dir.len, lang_dir.str, builtin.len, builtin.str) ;
 
 if ( build_mode == DEFAULT_MODE  ||  build_mode == BUILD ) {
 /*if*/
 
 f  =  _STR("%.*s/vlib/builtin/%.*sh", main__TmpPath.len, main__TmpPath.str, builtin.len, builtin.str) ;
 
 }
 ;
 
_PUSH(& files , ( f ), tmp119, string) ;
 
 }
 ;
 
 }
 ;
 
bool obfuscate= array_string_contains( args , tos2("-obf") ) ;

 
 return  ALLOC_INIT(V, { .os =  _os , .out_name =  out_name , .files =  files , .dir =  dir , .lang_dir =  lang_dir , .table =  new_table ( obfuscate ) , .out_name =  out_name , .out_name_c =  out_name_c , .is_test =  is_test , .is_script =  is_script , .is_so =  array_string_contains( args , tos2("-shared") ) , .is_play =  array_string_contains( args , tos2("play") ) , .is_prod =  array_string_contains( args , tos2("-prod") ) , .is_verbose =  array_string_contains( args , tos2("-verbose") ) , .obfuscate =  obfuscate , .is_prof =  array_string_contains( args , tos2("-prof") ) , .is_live =  array_string_contains( args , tos2("-live") ) , .sanitize =  array_string_contains( args , tos2("-sanitize") ) , .nofmt =  array_string_contains( args , tos2("-nofmt") ) , .show_c_cmd =  array_string_contains( args , tos2("-show_c_cmd") ) , .translated =  array_string_contains( args , tos2("translated") ) , .cgen =  new_cgen ( out_name_c ) , .build_mode =  build_mode , .is_run =  array_string_contains( args , tos2("run") ) , .is_repl =  array_string_contains( args , tos2("-repl") ) , .vroot =  lang_dir , } ) ;
 
 
 }
 array_string run_repl() {
 
 #ifdef _WIN32
 
 println ( tos2("REPL does not work on Windows yet, sorry!") ) ;
 
 v_exit ( 1 ) ;
 
 #endif
 ;
 
 println ( _STR("V %.*s", main__Version.len, main__Version.str) ) ;
 
 println ( tos2("Use Ctrl-D to exit") ) ;
 
 println ( tos2("For now you have to use println() to print values, this will be fixed soon\n") ) ;
 
string file=string_add( main__TmpPath , tos2("/vrepl.v") ) ;
 
array_string lines=new_array_from_c_array(0, 0, sizeof(string), (string[]) {   }) ;
 
 while (1) { 
 v_print ( tos2(">>> ") ) ;
 
string line= os__get_raw_line ( ) ;
 
 if (string_eq( string_trim_space( line ) , tos2("") )  &&  string_ends_with( line , tos2("\n") ) ) {
 /*if*/
 
 continue
 ;
 
 }
 ;
 
 line  =  string_trim_space( line ) ;
 
 if (string_eq( line , tos2("") ) ) {
 /*if*/
 
 break
 ;
 
 }
 ;
 
 if ( string_starts_with( line , tos2("print") ) ) {
 /*if*/
 
string void_line= string_substr( line , string_index( line , tos2("(") ) + 1 , line .len - 1 ) ;
 
_PUSH(& lines , ( void_line ), tmp125, string) ;
 
string source_code=string_add(string_add( array_string_join( lines , tos2("\n") ) , tos2("\n") ) , line ) ;
 
 os__write_file ( file , source_code ) ;
 
V* v= new_v (new_array_from_c_array(3, 3, sizeof(string), (string[]) {  tos2("v") , tos2("-repl") , file  }) ) ;
 
 V_compile( v ) ;
 
string s= os__exec (string_add( main__TmpPath , tos2("/vrepl") ) ) ;
 
 println ( s ) ;
 
 }
  else { 
 /*else if*/
 
_PUSH(& lines , ( line ), tmp129, string) ;
 
 }
 ;
 
 }
 ;

 
 return  lines ;
 
 
 }
 Parser V_new_parser(V* c, string path, Pass run) {
 
 V_log(& /* ? */* c , _STR("new_parser(\"%.*s\")", path.len, path.str) ) ;
 
 c ->cgen ->run  =  run ;
 
Parser p= (Parser) { .file_path =  path , .file_name =  string_all_after( path , tos2("/") ) , .scanner =  new_scanner ( path ) , .table =  c ->table , .cur_fn =  main__EmptyFn , .cgen =  c ->cgen , .is_test =  c ->is_test , .is_script =  (/*lpar*/ c ->is_script  && string_eq( path , c ->dir ) ) , .is_so =  c ->is_so , .os =  c ->os , .is_prof =  c ->is_prof , .is_prod =  c ->is_prod , .is_play =  c ->is_play , .translated =  c ->translated , .obfuscate =  c ->obfuscate , .is_verbose =  c ->is_verbose , .build_mode =  c ->build_mode , .is_repl =  c ->is_repl , .run =  run , .vroot =  c ->vroot , .token_idx = 0 , .lit = tos("", 0) , .pkg = tos("", 0) , .inside_const = 0 , .assigned_type = tos("", 0) , .tmp_cnt = 0 , .is_live = 0 , .builtin_pkg = 0 , .vh_lines = new_array(0, 1, sizeof(string)) , .inside_if_expr = 0 , .is_struct_init = 0 , .if_expr_cnt = 0 , .for_expr_cnt = 0 , .ptr_cast = 0 , .calling_c = 0 , .returns = 0 , .is_c_struct_init = 0 , .can_chash = 0 } ;
 
 Parser_next(& /* ? */ p ) ;

 
 return  p ;
 
 
 }
 void Parser_next(Parser* p) {
 
 p ->prev_tok2  =  p ->prev_tok ;
 
 p ->prev_tok  =  p ->tok ;
 
ScanRes res= Scanner_scan( p ->scanner ) ;
 
 p ->tok  =  res .tok ;
 
 p ->lit  =  res .lit ;
 
 
 }
 void Parser_log(Parser* p, string s) {
 
 if ( ! p ->is_verbose ) {
 /*if*/

 
 return  ;
 
 }
 ;
 
 println ( s ) ;
 
 
 }
 void Parser_parse(Parser* p) {
 
 Parser_log(& /* ? */* p , _STR("\nparse() run=%d file=%.*s tok=%.*s", p ->run, p ->file_name.len, p ->file_name.str, Parser_strtok(& /* ? */* p ).len, Parser_strtok(& /* ? */* p ).str) ) ;
 
 if ( p ->is_script  ||  p ->is_test ) {
 /*if*/
 
 p ->pkg  =  tos2("main") ;
 
 if ( p ->tok == PACKAGE ) {
 /*if*/
 
 Parser_next( p ) ;
 
 Parser_fgen( p , tos2("module ") ) ;
 
 p ->pkg  =  Parser_check_name( p ) ;
 
 }
 ;
 
 }
  else { 
 /*else if*/
 
 Parser_check( p , PACKAGE ) ;
 
 p ->pkg  =  Parser_check_name( p ) ;
 
 }
 ;
 
 Parser_fgenln( p , tos2("\n") ) ;
 
 p ->builtin_pkg  = string_eq( p ->pkg , tos2("builtin") ) ;
 
 p ->can_chash  = string_eq( p ->pkg , tos2("gg") )  || string_eq( p ->pkg , tos2("glm") )  || string_eq( p ->pkg , tos2("gl") )  || string_eq( p ->pkg , tos2("http") )  || string_eq( p ->pkg , tos2("glfw") ) ;
 
 Table_register_package( p ->table , p ->pkg ) ;
 
 if ( p ->run == RUN_IMPORTS ) {
 /*if*/
 
 while ( p ->tok == IMPORT  &&  Parser_peek( p ) != CONST ) {
 
 Parser_import_statement( p ) ;
 
 }
 ;

 
 return  ;
 
 }
 ;
 
 while (1) { 
 if ( ( p ->tok ==  IMPORT )) { /* case */
 
 if ( Parser_peek( p ) == CONST ) {
 /*if*/
 
 Parser_const_decl( p ) ;
 
 }
  else { 
 /*else if*/
 
 Parser_import_statement( p ) ;
 
 }
 ;
 
 }
 else  if ( ( p ->tok ==  ENUM )) { /* case */
 
 Parser_next( p ) ;
 
 if ( p ->tok == NAME ) {
 /*if*/
 
 Parser_fgen( p , tos2("enum ") ) ;
 
string name= Parser_check_name( p ) ;
 
 Parser_fgen( p , tos2(" ") ) ;
 
 Parser_enum_decl( p , name ) ;
 
 }
  else  if ( p ->translated ) {
 /*if*/
 
 Parser_enum_decl( p , tos2("int") ) ;
 
 }
  else { 
 /*else if*/
 
 Parser_check( p , NAME ) ;
 
 }
 ;
 
 }
 else  if ( ( p ->tok ==  PUB )) { /* case */
 
 if ( Parser_peek( p ) == FUNC ) {
 /*if*/
 
 Parser_fn_decl( p ) ;
 
 }
  else  if ( Parser_peek( p ) == STRUCT ) {
 /*if*/
 
 Parser_error( p , tos2("structs can\'t be declared public *yet*") ) ;
 
 }
  else { 
 /*else if*/
 
 Parser_error( p , tos2("wrong pub keyword usage") ) ;
 
 }
 ;
 
 }
 else  if ( ( p ->tok ==  FUNC )) { /* case */
 
 Parser_fn_decl( p ) ;
 
 }
 else  if ( ( p ->tok ==  TIP )) { /* case */
 
 Parser_type_decl( p ) ;
 
 }
 else  if ( ( p ->tok ==  STRUCT ) ||   ( p ->tok ==  INTERFACE ) ||   ( p ->tok ==  UNION ) ||   ( p ->tok ==  LSBR )) { /* case */
 
 Parser_struct_decl( p ) ;
 
 }
 else  if ( ( p ->tok ==  CONST )) { /* case */
 
 Parser_const_decl( p ) ;
 
 }
 else  if ( ( p ->tok ==  HASH )) { /* case */
 
 Parser_chash( p ) ;
 
 }
 else  if ( ( p ->tok ==  DOLLAR )) { /* case */
 
 Parser_comp_time( p ) ;
 
 }
 else  if ( ( p ->tok ==  GLOBAL )) { /* case */
 
 if ( ! p ->translated  &&  ! p ->builtin_pkg  &&  ! Parser_building_v(& /* ? */* p ) ) {
 /*if*/
 
 Parser_error( p , tos2("__global is only allowed in translated code") ) ;
 
 }
 ;
 
 Parser_next( p ) ;
 
string name= Parser_check_name( p ) ;
 
string typ= Parser_get_type( p ) ;
 
 Parser_register_global( p , name , typ ) ;
 
string g= Table_cgen_name_type_pair(& /* ? */* p ->table , name , typ ) ;
 
 if ( p ->tok == ASSIGN ) {
 /*if*/
 
 Parser_next( p ) ;
 
 g  = string_add( g , tos2(" = ") ) ;
 
 CGen_start_tmp( p ->cgen ) ;
 
 Parser_bool_expression( p ) ;
 
 g  = string_add( g , CGen_end_tmp( p ->cgen ) ) ;
 
 }
 ;
 
 g  = string_add( g , tos2("; // global") ) ;
 
_PUSH(& p ->cgen ->consts , ( g ), tmp7, string) ;
 
 }
 else  if ( ( p ->tok ==  EOF )) { /* case */
 
 Parser_log(& /* ? */* p , tos2("end of parse()") ) ;
 
 if ( p ->is_script  &&  ! p ->is_test ) {
 /*if*/
 
 p ->cur_fn  =  main__MainFn ;
 
 Parser_check_unused_variables( p ) ;
 
 }
 ;
 
 if ( 1  &&  ! Parser_first_run(& /* ? */* p )  &&  Parser_fileis(& /* ? */* p , tos2("test") ) ) {
 /*if*/
 
 os__File out= os__create ( _STR("%.*s/fmt.v", main__TmpPath.len, main__TmpPath.str) ) ;
 
 os__File_appendln( out , StringBuilder_str( p ->scanner ->fmt_out ) ) ;
 
 os__File_close( out ) ;
 
 }
 ;

 
 return  ;
 
 }
 else  { // default:
 
 if ( p ->is_script  &&  ! p ->is_test ) {
 /*if*/
 
 if ( Parser_first_run(& /* ? */* p ) ) {
 /*if*/
 
 if (string_eq( p ->cur_fn ->name , tos2("") ) ) {
 /*if*/
 
 p ->cur_fn  =  main__MainFn ;
 
 }
 ;

 
 return  ;
 
 }
 ;
 
 if (string_eq( p ->cur_fn ->name , tos2("") ) ) {
 /*if*/
 
 p ->cur_fn  =  main__MainFn ;
 
 if ( p ->is_repl ) {
 /*if*/
 
 Fn_clear_vars( p ->cur_fn ) ;
 
 }
 ;
 
 }
 ;
 
int start= p ->cgen ->lines .len ;
 
 Parser_statement( p , 1 ) ;
 
 Parser_genln( p , tos2("") ) ;
 
int end= p ->cgen ->lines .len ;
 
array_string lines= array_slice( p ->cgen ->lines , start , end ) ;
 
 p ->cgen ->fn_main  = string_add( p ->cgen ->fn_main , array_string_join( lines , tos2("\n") ) ) ;
 
 p ->cgen ->cur_line  =  tos2("") ;
 
 for (
int i= start  ;  i < end  ;  i ++ ) { 
string tmp13 =  tos2("");
 
array_set(&/*q*/ p ->cgen ->lines , i , & tmp13) ;
 
 }
 ;
 
 }
  else { 
 /*else if*/
 
 Parser_error( p , _STR("unexpected token `%.*s`", Parser_strtok(& /* ? */* p ).len, Parser_strtok(& /* ? */* p ).str) ) ;
 
 }
 ;
 
 }
 ;
 
 }
 ;
 
 
 }
 void Parser_import_statement(Parser* p) {
 
 Parser_check( p , IMPORT ) ;
 
 if ( p ->tok == LPAR ) {
 /*if*/
 
 Parser_check( p , LPAR ) ;
 
 while ( p ->tok != RPAR  &&  p ->tok != EOF ) {
 
string pkg= string_trim_space( p ->lit ) ;
 
 Parser_next( p ) ;
 
 if ( array_string_contains( p ->table ->imports , pkg ) ) {
 /*if*/
 
 continue
 ;
 
 }
 ;
 
_PUSH(& p ->table ->imports , ( pkg ), tmp15, string) ;
 
 Table_register_package( p ->table , pkg ) ;
 
 }
 ;
 
 Parser_check( p , RPAR ) ;

 
 return  ;
 
 }
 ;
 
 if ( p ->tok != NAME ) {
 /*if*/
 
 Parser_error( p , tos2("bad import format") ) ;
 
 }
 ;
 
string pkg= string_trim_space( p ->lit ) ;
 
 Parser_next( p ) ;
 
 Parser_fgenln( p ,string_add( tos2(" ") , pkg ) ) ;
 
 if ( array_string_contains( p ->table ->imports , pkg ) ) {
 /*if*/

 
 return  ;
 
 }
 ;
 
 Parser_log(& /* ? */* p , _STR("adding import %.*s", pkg.len, pkg.str) ) ;
 
_PUSH(& p ->table ->imports , ( pkg ), tmp17, string) ;
 
 Table_register_package( p ->table , pkg ) ;
 
 
 }
 void Parser_const_decl(Parser* p) {
 
bool is_import= p ->tok == IMPORT ;
 
 p ->inside_const  =  1 ;
 
 if ( is_import ) {
 /*if*/
 
 Parser_next( p ) ;
 
 }
 ;
 
 Parser_check( p , CONST ) ;
 
 Parser_fspace( p ) ;
 
 Parser_check( p , LPAR ) ;
 
 Parser_fgenln( p , tos2("") ) ;
 
 p ->scanner ->fmt_indent ++ ;
 
 while ( p ->tok == NAME ) {
 
string name= Parser_check_name( p ) ;
 
 if ( p ->is_play  &&  ! (/*lpar*/ string_at( name , 0) >= 'A'  &&  string_at( name , 0) <= 'Z' ) ) {
 /*if*/
 
 Parser_error( p , tos2("const name must be capitalized") ) ;
 
 }
 ;
 
 if ( ! is_import ) {
 /*if*/
 
 name  =  Parser_prepend_pkg(& /* ? */* p , name ) ;
 
 }
 ;
 
string typ= tos2("int") ;
 
 if ( ! is_import ) {
 /*if*/
 
 Parser_check_space( p , ASSIGN ) ;
 
 typ  =  Parser_expression( p ) ;
 
 }
 ;
 
 if ( Parser_first_run(& /* ? */* p )  &&  ! is_import  &&  Table_known_const(& /* ? */* p ->table , name ) ) {
 /*if*/
 
 Parser_error( p , _STR("redefinition of `%.*s`", name.len, name.str) ) ;
 
 }
 ;
 
 Table_register_const( p ->table , name , typ , p ->pkg , is_import ) ;
 
 if ( p ->run == RUN_MAIN  &&  ! is_import ) {
 /*if*/
 
 if ( is_compile_time_const ( p ->cgen ->cur_line ) ) {
 /*if*/
 
_PUSH(& p ->cgen ->consts , ( _STR("#define %.*s %.*s", name.len, name.str, p ->cgen ->cur_line.len, p ->cgen ->cur_line.str) ), tmp25, string) ;
 
 p ->cgen ->cur_line  =  tos2("") ;
 
 Parser_fgenln( p , tos2("") ) ;
 
 continue
 ;
 
 }
 ;
 
 if ( string_starts_with( typ , tos2("[") ) ) {
 /*if*/
 
_PUSH(& p ->cgen ->consts , (string_add( Table_cgen_name_type_pair(& /* ? */* p ->table , name , typ ) , _STR(" = %.*s;", p ->cgen ->cur_line.len, p ->cgen ->cur_line.str) ) ), tmp26, string) ;
 
 }
  else { 
 /*else if*/
 
_PUSH(& p ->cgen ->consts , (string_add( Table_cgen_name_type_pair(& /* ? */* p ->table , name , typ ) , tos2(";") ) ), tmp27, string) ;
 
_PUSH(& p ->cgen ->consts_init , ( _STR("%.*s = %.*s;", name.len, name.str, p ->cgen ->cur_line.len, p ->cgen ->cur_line.str) ), tmp28, string) ;
 
 }
 ;
 
 p ->cgen ->cur_line  =  tos2("") ;
 
 }
 ;
 
 Parser_fgenln( p , tos2("") ) ;
 
 }
 ;
 
 p ->scanner ->fmt_indent -- ;
 
 Parser_check( p , RPAR ) ;
 
 Parser_fgenln( p , tos2("\n") ) ;
 
 p ->inside_const  =  0 ;
 
 
 }
 void Parser_type_decl(Parser* p) {
 
 Parser_check( p , TIP ) ;
 
string name= Parser_check_name( p ) ;
 
string parent= Parser_get_type( p ) ;
 
string nt_pair= Table_cgen_name_type_pair(& /* ? */* p ->table , name , parent ) ;
 
string _struct= ( ! string_contains( parent , tos2("[") )  &&  ! string_starts_with( parent , tos2("fn ") )  &&  ! Table_known_type(& /* ? */* p ->table , parent ) ) ? ( tos2("struct") ) : ( tos2("") ) ;
 
 Parser_gen_typedef( p , _STR("typedef %.*s %.*s; // type alias name=\"%.*s\" parent=\"%.*s\"", _struct.len, _struct.str, nt_pair.len, nt_pair.str, name.len, name.str, parent.len, parent.str) ) ;
 
 Table_register_type_with_parent( p ->table , name , parent ) ;
 
 
 }
 void Parser_struct_decl(Parser* p) {
 
string objc_parent= tos2("") ;
 
bool is_objc= 0 ;
 
 if ( p ->tok == LSBR ) {
 /*if*/
 
 Parser_check( p , LSBR ) ;
 
 is_objc  =  p ->tok == INTERFACE ;
 
 Parser_next( p ) ;
 
 if ( is_objc ) {
 /*if*/
 
 Parser_check( p , COLON ) ;
 
 objc_parent  =  Parser_check_name( p ) ;
 
 }
 ;
 
 Parser_check( p , RSBR ) ;
 
 }
 ;
 
bool is_interface= p ->tok == INTERFACE ;
 
bool is_union= p ->tok == UNION ;
 
bool is_struct= p ->tok == STRUCT ;
 
 Parser_fgen( p ,string_add( Token_str( p ->tok ) , tos2(" ") ) ) ;
 
 Parser_next( p ) ;
 
string name= Parser_check_name( p ) ;
 
 if ( string_contains( name , tos2("_") )  &&  ! p ->translated ) {
 /*if*/
 
 Parser_error( p , tos2("type names cannot contain `_`") ) ;
 
 }
 ;
 
 if ( is_interface  &&  ! string_ends_with( name , tos2("er") ) ) {
 /*if*/
 
 Parser_error( p , tos2("interface names temporarily have to end with `er` (e.g. `Speaker`, `Reader`)") ) ;
 
 }
 ;
 
bool is_c=string_eq( name , tos2("C") )  &&  p ->tok == DOT ;
 
 if ( is_c ) {
 /*if*/
 
 Parser_check( p , DOT ) ;
 
 name  =  Parser_check_name( p ) ;
 
 }
 ;
 
 if ( ! is_c  &&  ! p ->builtin_pkg  && string_ne( p ->pkg , tos2("main") ) ) {
 /*if*/
 
 name  =  Parser_prepend_pkg(& /* ? */* p , name ) ;
 
 }
 ;
 
 if ( p ->run == RUN_DECLS  &&  Table_known_type(& /* ? */* p ->table , name ) ) {
 /*if*/
 
 Parser_error( p , _STR("`%.*s` redeclared", name.len, name.str) ) ;
 
 }
 ;
 
 if ( is_objc ) {
 /*if*/
 
 Parser_gen_type( p , _STR("@interface %.*s : %.*s { @public", name.len, name.str, objc_parent.len, objc_parent.str) ) ;
 
 }
  else { 
 /*else if*/
 
 if ( ! is_c ) {
 /*if*/
 
string kind= ( is_union ) ? ( tos2("union") ) : ( tos2("struct") ) ;
 
 Parser_gen_typedef( p , _STR("typedef %.*s %.*s %.*s;", kind.len, kind.str, name.len, name.str, name.len, name.str) ) ;
 
 Parser_gen_type( p , _STR("%.*s /*kind*/ %.*s {", kind.len, kind.str, name.len, name.str) ) ;
 
 }
 ;
 
 }
 ;
 
 if ( ! is_c  &&  p ->tok == STRUCT ) {
 /*if*/
 
 Parser_error( p , _STR("use `struct %.*s {` instead of `type %.*s struct {`", name.len, name.str, name.len, name.str) ) ;
 
 }
 ;
 
Type* typ= Table_find_type(& /* ? */* p ->table , name ) ;
 
bool is_ph= 0 ;
 
 if ( typ ->is_placeholder ) {
 /*if*/
 
 is_ph  =  1 ;
 
 typ ->name  =  name ;
 
 typ ->pkg  =  p ->pkg ;
 
 typ ->is_c  =  is_c ;
 
 typ ->is_placeholder  =  0 ;
 
 }
  else { 
 /*else if*/
 
 typ  =  ALLOC_INIT(Type, { .name =  name , .pkg =  p ->pkg , .is_c =  is_c , .is_interface =  is_interface , .fields = new_array(0, 1, sizeof(Var)) , .methods = new_array(0, 1, sizeof(Fn)) , .parent = tos("", 0) , .gen_types = new_array(0, 1, sizeof(string)) , .is_enum = 0 , .is_placeholder = 0 } ) ;
 
 }
 ;
 
 if ( is_c  &&  is_struct  &&  p ->tok != LCBR ) {
 /*if*/
 
 Table_register_type2( p ->table ,* typ ) ;

 
 return  ;
 
 }
 ;
 
 Parser_fgen( p , tos2(" ") ) ;
 
 Parser_check( p , LCBR ) ;
 
bool is_pub= 0 ;
 
bool is_mut= 0 ;
 
array_string names=new_array_from_c_array(0, 0, sizeof(string), (string[]) {   }) ;
 
 while ( p ->tok != RCBR ) {
 
 if ( p ->tok == PUB ) {
 /*if*/
 
 if ( is_pub ) {
 /*if*/
 
 Parser_error( p , tos2("structs can only have one `pub:`, all public fields have to be grouped") ) ;
 
 }
 ;
 
 is_pub  =  1 ;
 
 p ->scanner ->fmt_indent -- ;
 
 Parser_check( p , PUB ) ;
 
 if ( p ->tok != MUT ) {
 /*if*/
 
 Parser_check( p , COLON ) ;
 
 }
 ;
 
 p ->scanner ->fmt_indent ++ ;
 
 Parser_fgenln( p , tos2("") ) ;
 
 }
 ;
 
 if ( p ->tok == MUT ) {
 /*if*/
 
 if ( is_mut ) {
 /*if*/
 
 Parser_error( p , tos2("structs can only have one `mut:`, all private mutable fields have to be grouped") ) ;
 
 }
 ;
 
 is_mut  =  1 ;
 
 p ->scanner ->fmt_indent -- ;
 
 Parser_check( p , MUT ) ;
 
 if ( p ->tok != MUT ) {
 /*if*/
 
 Parser_check( p , COLON ) ;
 
 }
 ;
 
 p ->scanner ->fmt_indent ++ ;
 
 Parser_fgenln( p , tos2("") ) ;
 
 }
 ;
 
string field_name= Parser_check_name( p ) ;
 
 if (_IN(string,  field_name ,  names ) ) {
 /*if*/
 
 Parser_error( p , _STR("duplicate field `%.*s`", field_name.len, field_name.str) ) ;
 
 }
 ;
 
_PUSH(& names , ( field_name ), tmp47, string) ;
 
 if ( is_interface ) {
 /*if*/
 
Fn* interface_method= ALLOC_INIT(Fn, { .name =  field_name , .is_interface =  1 , .is_method =  1 , .receiver_typ =  name , .pkg = tos("", 0) , .local_vars = new_array(0, 1, sizeof(Var)) , .var_idx = 0 , .args = new_array(0, 1, sizeof(Var)) , .scope_level = 0 , .typ = tos("", 0) , .is_c = 0 , .is_public = 0 , .returns_error = 0 , .is_decl = 0 , .defer = tos("", 0) } ) ;
 
 println ( _STR("is interface. field=%.*s run=%d", field_name.len, field_name.str, p ->run) ) ;
 
 Parser_fn_args( p , interface_method ) ;
 
 Parser_fspace( p ) ;
 
 interface_method ->typ  =  Parser_get_type( p ) ;
 
 Type_add_method( typ ,* interface_method ) ;
 
 Parser_fgenln( p , tos2("") ) ;
 
 continue
 ;
 
 }
 ;
 
AccessMod access_mod= ( is_pub ) ? ( PUBLIC ) : ( PRIVATE ) ;
 
 Parser_fgen( p , tos2(" ") ) ;
 
string field_type= Parser_get_type( p ) ;
 
bool is_atomic= p ->tok == ATOMIC ;
 
 if ( is_atomic ) {
 /*if*/
 
 Parser_next( p ) ;
 
 Parser_gen_type( p , tos2("_Atomic ") ) ;
 
 }
 ;
 
 if ( ! is_c ) {
 /*if*/
 
 Parser_gen_type( p ,string_add( Table_cgen_name_type_pair(& /* ? */* p ->table , field_name , field_type ) , tos2(";") ) ) ;
 
 }
 ;
 
string attr= tos2("") ;
 
 if ( p ->tok == LSBR ) {
 /*if*/
 
 Parser_next( p ) ;
 
 attr  =  Parser_check_name( p ) ;
 
 Parser_check( p , RSBR ) ;
 
 }
 ;
 
 Type_add_field( typ , field_name , field_type , is_mut , attr , access_mod ) ;
 
 Parser_fgenln( p , tos2("") ) ;
 
 }
 ;
 
 if ( ! is_ph  &&  Parser_first_run(& /* ? */* p ) ) {
 /*if*/
 
 Table_register_type2( p ->table ,* typ ) ;
 
 }
 ;
 
 Parser_check( p , RCBR ) ;
 
 if ( ! is_c ) {
 /*if*/
 
 Parser_gen_type( p , tos2("}; ") ) ;
 
 }
 ;
 
 if ( is_objc ) {
 /*if*/
 
 Parser_gen_type( p , tos2("@end") ) ;
 
 }
 ;
 
 Parser_fgenln( p , tos2("\n") ) ;
 
 
 }
 void Parser_enum_decl(Parser* p, string _enum_name) {
 
string enum_name= _enum_name ;
 
 if ( ! p ->builtin_pkg  && string_ne( p ->pkg , tos2("main") ) ) {
 /*if*/
 
 enum_name  =  Parser_prepend_pkg(& /* ? */* p , enum_name ) ;
 
 }
 ;
 
 Table_register_type2( p ->table ,* ALLOC_INIT(Type, { .name =  enum_name , .pkg =  p ->pkg , .parent =  tos2("int") , .is_enum =  1 , .fields = new_array(0, 1, sizeof(Var)) , .methods = new_array(0, 1, sizeof(Fn)) , .gen_types = new_array(0, 1, sizeof(string)) , .is_c = 0 , .is_interface = 0 , .is_placeholder = 0 } ) ) ;
 
 if (string_ne( enum_name , tos2("int") ) ) {
 /*if*/
 
_PUSH(& p ->cgen ->typedefs , ( _STR("typedef int %.*s ;\n", enum_name.len, enum_name.str) ), tmp54, string) ;
 
 }
 ;
 
 Parser_check( p , LCBR ) ;
 
int val= 0 ;
 
 while ( p ->tok == NAME ) {
 
string field= Parser_check_name( p ) ;
 
string name= _STR("%.*s", field.len, field.str) ;
 
 Parser_fgenln( p , tos2("") ) ;
 
 if ( p ->run == RUN_MAIN ) {
 /*if*/
 
_PUSH(& p ->cgen ->consts , ( _STR("#define %.*s %d \n", name.len, name.str, val) ), tmp58, string) ;
 
 }
 ;
 
 if ( p ->tok == COMMA ) {
 /*if*/
 
 Parser_next( p ) ;
 
 }
 ;
 
 Table_register_const( p ->table , name , enum_name , p ->pkg , 0 ) ;
 
 val ++ ;
 
 }
 ;
 
 Parser_check( p , RCBR ) ;
 
 Parser_fgenln( p , tos2("\n") ) ;
 
 
 }
 string Parser_check_name(Parser* p) {
 
string name= p ->lit ;
 
 Parser_check( p , NAME ) ;

 
 return  name ;
 
 
 }
 string Parser_check_string(Parser* p) {
 
string s= p ->lit ;
 
 Parser_check( p , STRING ) ;

 
 return  s ;
 
 
 }
 string Parser_strtok(Parser* p) {
 
 if ( p ->tok == NAME ) {
 /*if*/

 
 return  p ->lit ;
 
 }
 ;
 
 if ( p ->tok == STRING ) {
 /*if*/

 
 return  _STR("\"%.*s\"", p ->lit.len, p ->lit.str) ;
 
 }
 ;
 
string res= Token_str( p ->tok ) ;
 
 if (string_eq( res , tos2("") ) ) {
 /*if*/
 
int n= ((int)( p ->tok ) ) ;

 
 return  int_str( n ) ;
 
 }
 ;

 
 return  res ;
 
 
 }
 void Parser_check_space(Parser* p, Token expected) {
 
 Parser_fspace( p ) ;
 
 Parser_check( p , expected ) ;
 
 Parser_fspace( p ) ;
 
 
 }
 void Parser_check(Parser* p, Token expected) {
 
 if ( p ->tok != expected ) {
 /*if*/
 
 println ( tos2("check()") ) ;
 
string s= _STR("expected `%.*s` but got `%.*s`", Token_str( expected ).len, Token_str( expected ).str, Parser_strtok(& /* ? */* p ).len, Parser_strtok(& /* ? */* p ).str) ;
 
 Parser_next( p ) ;
 
 println ( _STR("next token = `%.*s`", Parser_strtok(& /* ? */* p ).len, Parser_strtok(& /* ? */* p ).str) ) ;
 
 print_backtrace ( ) ;
 
 Parser_error( p , s ) ;
 
 }
 ;
 
 if ( expected == RCBR ) {
 /*if*/
 
 p ->scanner ->fmt_indent -- ;
 
 }
 ;
 
 Parser_fgen( p , Parser_strtok(& /* ? */* p ) ) ;
 
 if ( expected == LCBR  &&  string_at( p ->scanner ->text , p ->scanner ->pos + 1) != '}' ) {
 /*if*/
 
 Parser_fgenln( p , tos2("") ) ;
 
 p ->scanner ->fmt_indent ++ ;
 
 }
 ;
 
 Parser_next( p ) ;
 
 
 }
 void Parser_error(Parser* p, string s) {
 
 if ( 0 ) {
 /*if*/
 
os__File file_types= os__create ( _STR("%.*s/types", main__TmpPath.len, main__TmpPath.str) ) ;
 
os__File file_vars= os__create ( _STR("%.*s/vars", main__TmpPath.len, main__TmpPath.str) ) ;
 
 os__File_close( file_types ) ;
 
 os__File_close( file_vars ) ;
 
 }
 ;
 
 if ( ! p ->is_repl ) {
 /*if*/
 
 println ( _STR("pass=%d fn=`%.*s`", p ->run, p ->cur_fn ->name.len, p ->cur_fn ->name.str) ) ;
 
 }
 ;
 
 CGen_save( p ->cgen ) ;
 
string cur_path= os__getwd ( ) ;
 
 if ( ! p ->is_repl  &&  (/*lpar*/ string_contains( p ->file_path , tos2("v/compiler") )  ||  string_contains( cur_path , tos2("v/compiler") ) ) ) {
 /*if*/
 
 println ( tos2("\n=========================") ) ;
 
 println ( tos2("It looks like you are building V. It is being frequently updated every day.") ) ;
 
 println ( tos2("If you didn\'t modify the compiler\'s code, most likely there was a change that ") ) ;
 
 println ( tos2("lead to this error.") ) ;
 
 println ( tos2("\nRun `git pull && make`, that will most likely fix it.") ) ;
 
 println ( tos2("\nIf this doesn\'t help, please create a GitHub issue.") ) ;
 
 println ( tos2("=========================\n") ) ;
 
 }
 ;
 
 Scanner_error(& /* ? */* p ->scanner , string_replace( string_replace( s , tos2("array_") , tos2("[]") ) , tos2("__") , tos2(".") ) ) ;
 
 
 }
 bool Parser_first_run(Parser* p) {

 
 return  p ->run == RUN_DECLS ;
 
 
 }
 string Parser_get_type(Parser* p) {
 
bool debug= Parser_fileis(& /* ? */* p , tos2("fn_test") )  &&  0 ;
 
bool mul= 0 ;
 
int nr_muls= 0 ;
 
string typ= tos2("") ;
 
 if ( p ->tok == FUNC ) {
 /*if*/
 
 if ( debug ) {
 /*if*/
 
 println ( _STR("\nget_type() GOT FN TYP line=%d", p ->scanner ->line_nr) ) ;
 
 }
 ;
 
Fn f= (Fn) { .name =  tos2("_") , .pkg =  p ->pkg , .local_vars = new_array(0, 1, sizeof(Var)) , .var_idx = 0 , .args = new_array(0, 1, sizeof(Var)) , .is_interface = 0 , .scope_level = 0 , .typ = tos("", 0) , .is_c = 0 , .receiver_typ = tos("", 0) , .is_public = 0 , .is_method = 0 , .returns_error = 0 , .is_decl = 0 , .defer = tos("", 0) } ;
 
 Parser_next( p ) ;
 
int line_nr= p ->scanner ->line_nr ;
 
 Parser_fn_args( p ,& /*11 EXP:"Fn*" GOT:"Fn" */ f ) ;
 
 if ( p ->scanner ->line_nr == line_nr ) {
 /*if*/
 
 if ( debug ) {
 /*if*/
 
 println ( tos2("same line getting type") ) ;
 
 }
 ;
 
 f .typ  =  Parser_get_type( p ) ;
 
 }
  else { 
 /*else if*/
 
 f .typ  =  tos2("void") ;
 
 }
 ;
 
Type fn_typ= (Type) { .name =  Fn_typ_str( f ) , .pkg =  p ->pkg , .func =  f , .fields = new_array(0, 1, sizeof(Var)) , .methods = new_array(0, 1, sizeof(Fn)) , .parent = tos("", 0) , .gen_types = new_array(0, 1, sizeof(string)) , .is_c = 0 , .is_interface = 0 , .is_enum = 0 , .is_placeholder = 0 } ;
 
 Table_register_type2( p ->table , fn_typ ) ;

 
 return  Fn_typ_str( f ) ;
 
 }
 ;
 
bool is_arr= 0 ;
 
bool is_arr2= 0 ;
 
bool is_question= p ->tok == QUESTION ;
 
 if ( is_question ) {
 /*if*/
 
 Parser_check( p , QUESTION ) ;
 
 }
 ;
 
 if ( p ->tok == LSBR ) {
 /*if*/
 
 Parser_check( p , LSBR ) ;
 
 if ( p ->tok == INT ) {
 /*if*/
 
 typ  =  _STR("[%.*s]", p ->lit.len, p ->lit.str) ;
 
 Parser_next( p ) ;
 
 }
  else { 
 /*else if*/
 
 is_arr  =  1 ;
 
 }
 ;
 
 Parser_check( p , RSBR ) ;
 
 if ( p ->tok == LSBR ) {
 /*if*/
 
 Parser_next( p ) ;
 
 if ( p ->tok == INT ) {
 /*if*/
 
 typ  = string_add( typ , _STR("[%.*s]", p ->lit.len, p ->lit.str) ) ;
 
 Parser_check( p , INT ) ;
 
 }
  else { 
 /*else if*/
 
 is_arr2  =  1 ;
 
 }
 ;
 
 Parser_check( p , RSBR ) ;
 
 }
 ;
 
 }
 ;
 
 while ( p ->tok == MUL ) {
 
 mul  =  1 ;
 
 nr_muls ++ ;
 
 Parser_next( p ) ;
 
 }
 ;
 
 if ( p ->tok == AMP ) {
 /*if*/
 
 mul  =  1 ;
 
 nr_muls ++ ;
 
 Parser_next( p ) ;
 
 }
 ;
 
 typ  = string_add( typ , p ->lit ) ;
 
 if ( ! p ->is_struct_init ) {
 /*if*/
 
 Parser_fgen( p , p ->lit ) ;
 
 }
 ;
 
 if (string_eq( p ->lit , tos2("C") )  &&  Parser_peek( p ) == DOT ) {
 /*if*/
 
 Parser_next( p ) ;
 
 Parser_check( p , DOT ) ;
 
 typ  =  p ->lit ;
 
 }
  else { 
 /*else if*/
 
 if ( Parser_peek( p ) == DOT ) {
 /*if*/
 
 Parser_next( p ) ;
 
 Parser_check( p , DOT ) ;
 
 typ  = string_add( typ , _STR("__%.*s", p ->lit.len, p ->lit.str) ) ;
 
 }
 ;
 
Type* t= Table_find_type(& /* ? */* p ->table , typ ) ;
 
 if (string_eq( t ->name , tos2("") )  &&  ! p ->builtin_pkg ) {
 /*if*/
 
 if ( ! string_contains( typ , tos2("array_") )  && string_ne( p ->pkg , tos2("main") )  &&  ! string_contains( typ , tos2("__") ) ) {
 /*if*/
 
 typ  =  Parser_prepend_pkg(& /* ? */* p , typ ) ;
 
 }
 ;
 
 t  =  Table_find_type(& /* ? */* p ->table , typ ) ;
 
 if (string_eq( t ->name , tos2("") )  &&  ! p ->translated  &&  ! Parser_first_run(& /* ? */* p )  &&  ! string_starts_with( typ , tos2("[") ) ) {
 /*if*/
 
 println ( tos2("get_type() bad type") ) ;
 
 Parser_error( p , _STR("unknown type `%.*s`", typ.len, typ.str) ) ;
 
 }
 ;
 
 }
 ;
 
 }
 ;
 
 if (string_eq( typ , tos2("void") ) ) {
 /*if*/
 
 Parser_error( p , _STR("unknown type `%.*s`", typ.len, typ.str) ) ;
 
 }
 ;
 
 if ( mul ) {
 /*if*/
 
 typ  = string_add( typ , repeat_char ( '*' , nr_muls ) ) ;
 
 }
 ;
 
 if ( is_arr2 ) {
 /*if*/
 
 typ  =  _STR("array_array_%.*s", typ.len, typ.str) ;
 
 Parser_register_array( p , typ ) ;
 
 }
  else  if ( is_arr ) {
 /*if*/
 
 typ  =  _STR("array_%.*s", typ.len, typ.str) ;
 
 Parser_register_array( p , typ ) ;
 
 }
 ;
 
 Parser_next( p ) ;
 
 if ( p ->tok == QUESTION  ||  is_question ) {
 /*if*/
 
 typ  =  _STR("Option_%.*s", typ.len, typ.str) ;
 
 Table_register_type_with_parent( p ->table , typ , tos2("Option") ) ;
 
 if ( p ->tok == QUESTION ) {
 /*if*/
 
 Parser_next( p ) ;
 
 }
 ;
 
 }
 ;
 
 if (string_eq( typ , tos2("byteptr") ) ) {
 /*if*/

 
 return  tos2("byte*") ;
 
 }
 ;
 
 if (string_eq( typ , tos2("voidptr") ) ) {
 /*if*/

 
 return  tos2("void*") ;
 
 }
 ;
 
 if ( string_last_index( typ , tos2("__") ) > string_index( typ , tos2("__") ) ) {
 /*if*/
 
 Parser_error( p , _STR("2 __ in gettype(): typ=\"%.*s\"", typ.len, typ.str) ) ;
 
 }
 ;

 
 return  typ ;
 
 
 }
 void Parser_print_tok(Parser* p) {
 
 if ( p ->tok == NAME ) {
 /*if*/
 
 println ( p ->lit ) ;

 
 return  ;
 
 }
 ;
 
 if ( p ->tok == STRING ) {
 /*if*/
 
 println ( _STR("\"%.*s\"", p ->lit.len, p ->lit.str) ) ;

 
 return  ;
 
 }
 ;
 
 println ( Token_str( p ->tok ) ) ;
 
 
 }
 string Parser_statements(Parser* p) {
 
 Parser_log(& /* ? */* p , tos2("statements()") ) ;
 
string typ= Parser_statements_no_curly_end( p ) ;
 
 if ( ! p ->inside_if_expr ) {
 /*if*/
 
 Parser_genln( p , tos2("}") ) ;
 
 }
 ;
 
 if ( Parser_fileis(& /* ? */* p , tos2("if_expr") ) ) {
 /*if*/
 
 println ( _STR("statements() ret=%.*s line=%d", typ.len, typ.str, p ->scanner ->line_nr) ) ;
 
 }
 ;

 
 return  typ ;
 
 
 }
 string Parser_statements_no_curly_end(Parser* p) {
 
 Fn_open_scope( p ->cur_fn ) ;
 
 if ( ! p ->inside_if_expr ) {
 /*if*/
 
 Parser_genln( p , tos2("") ) ;
 
 }
 ;
 
int i= 0 ;
 
string last_st_typ= tos2("") ;
 
 while ( p ->tok != RCBR  &&  p ->tok != EOF  &&  p ->tok != CASE  &&  p ->tok != DEFAULT ) {
 
 last_st_typ  =  Parser_statement( p , 1 ) ;
 
 if ( ! p ->inside_if_expr ) {
 /*if*/
 
 Parser_genln( p , tos2("") ) ;
 
 Parser_fgenln( p , tos2("") ) ;
 
 }
 ;
 
 i ++ ;
 
 if ( i > 50000 ) {
 /*if*/
 
 CGen_save( p ->cgen ) ;
 
 Parser_error( p , _STR("more than 50 000 statements in function `%.*s`", p ->cur_fn ->name.len, p ->cur_fn ->name.str) ) ;
 
 }
 ;
 
 }
 ;
 
 if ( p ->tok != CASE  &&  p ->tok != DEFAULT ) {
 /*if*/
 
 Parser_check( p , RCBR ) ;
 
 }
  else { 
 /*else if*/
 
 }
 ;
 
 p ->scanner ->fmt_indent -- ;
 
 Fn_close_scope( p ->cur_fn ) ;

 
 return  last_st_typ ;
 
 
 }
 void Parser_genln(Parser* p, string s) {
 
 CGen_genln( p ->cgen , s ) ;
 
 
 }
 void Parser_gen(Parser* p, string s) {
 
 CGen_gen( p ->cgen , s ) ;
 
 
 }
 void Parser_vh_genln(Parser* p, string s) {
 
_PUSH(& p ->vh_lines , ( s ), tmp83, string) ;
 
 
 }
 void Parser_fmt_inc(Parser* p) {
 
 p ->scanner ->fmt_indent ++ ;
 
 
 }
 void Parser_fmt_dec(Parser* p) {
 
 p ->scanner ->fmt_indent -- ;
 
 
 }
 string Parser_statement(Parser* p, bool add_semi) {
 
 p ->cgen ->is_tmp  =  0 ;
 
Token tok= p ->tok ;
 
string q= tos2("") ;
 
 if ( ( tok ==  NAME )) { /* case */
 
Token next= Parser_peek( p ) ;
 
 if ( p ->is_verbose ) {
 /*if*/
 
 println ( Token_str( next ) ) ;
 
 }
 ;
 
 if ( Parser_peek( p ) == COLON ) {
 /*if*/
 
 Parser_fmt_dec( p ) ;
 
string label= Parser_check_name( p ) ;
 
 Parser_fmt_inc( p ) ;
 
 Parser_genln( p ,string_add( label , tos2(":") ) ) ;
 
 Parser_check( p , COLON ) ;

 
 return  tos2("") ;
 
 }
  else  if ( Parser_peek( p ) == DECL_ASSIGN ) {
 /*if*/
 
 Parser_log(& /* ? */* p , tos2("var decl") ) ;
 
 Parser_var_decl( p ) ;
 
 }
  else  if (string_eq( p ->lit , tos2("jsdecode") ) ) {
 /*if*/
 
 Parser_js_decode( p ) ;
 
 }
  else { 
 /*else if*/
 
 q  =  Parser_bool_expression( p ) ;
 
 }
 ;
 
 }
 else  if ( ( tok ==  GOTO )) { /* case */
 
 Parser_check( p , GOTO ) ;
 
 Parser_fgen( p , tos2(" ") ) ;
 
string label= Parser_check_name( p ) ;
 
 Parser_genln( p , _STR("goto %.*s;", label.len, label.str) ) ;

 
 return  tos2("") ;
 
 }
 else  if ( ( tok ==  HASH )) { /* case */
 
 Parser_chash( p ) ;

 
 return  tos2("") ;
 
 }
 else  if ( ( tok ==  DOLLAR )) { /* case */
 
 Parser_comp_time( p ) ;
 
 }
 else  if ( ( tok ==  IF )) { /* case */
 
 Parser_if_st( p , 0 ) ;
 
 }
 else  if ( ( tok ==  FOR )) { /* case */
 
 Parser_for_st( p ) ;
 
 }
 else  if ( ( tok ==  SWITCH ) ||   ( tok ==  MATCH )) { /* case */
 
 Parser_switch_statement( p ) ;
 
 }
 else  if ( ( tok ==  MUT ) ||   ( tok ==  STATIC )) { /* case */
 
 Parser_var_decl( p ) ;
 
 }
 else  if ( ( tok ==  RETURN )) { /* case */
 
 Parser_return_st( p ) ;
 
 }
 else  if ( ( tok ==  LCBR )) { /* case */
 
 Parser_next( p ) ;
 
 Parser_genln( p , tos2("{") ) ;
 
 Parser_statements( p ) ;

 
 return  tos2("") ;
 
 }
 else  if ( ( tok ==  CONTINUE )) { /* case */
 
 if ( p ->for_expr_cnt == 0 ) {
 /*if*/
 
 Parser_error( p , tos2("`continue` statement outside `for`") ) ;
 
 }
 ;
 
 Parser_genln( p , tos2("continue") ) ;
 
 Parser_next( p ) ;
 
 }
 else  if ( ( tok ==  BREAK )) { /* case */
 
 if ( p ->for_expr_cnt == 0 ) {
 /*if*/
 
 Parser_error( p , tos2("`break` statement outside `for`") ) ;
 
 }
 ;
 
 Parser_genln( p , tos2("break") ) ;
 
 Parser_next( p ) ;
 
 }
 else  if ( ( tok ==  GO )) { /* case */
 
 Parser_go_statement( p ) ;
 
 }
 else  if ( ( tok ==  ASSERT )) { /* case */
 
 Parser_assert_statement( p ) ;
 
 }
 else  { // default:
 
string typ= Parser_expression( p ) ;
 
 if ( p ->inside_if_expr ) {
 /*if*/
 
 }
  else { 
 /*else if*/
 
 Parser_genln( p , tos2("; ") ) ;
 
 }
 ;

 
 return  typ ;
 
 }
 ;
 
 if ( p ->inside_if_expr  &&  p ->tok != RCBR ) {
 /*if*/
 
 Parser_gen( p , tos2(", ") ) ;
 
 }
 ;
 
 if ( add_semi  &&  ! p ->inside_if_expr ) {
 /*if*/
 
 Parser_genln( p , tos2(";") ) ;
 
 }
 ;

 
 return  q ;
 
 
 }
 void Parser_assign_statement(Parser* p, Var v, int ph, bool is_map) {
 
 Parser_log(& /* ? */* p , _STR("assign_statement() name=%.*s tok=", v .name.len, v .name.str) ) ;
 
Token tok= p ->tok ;
 
 if ( ! v .is_mut  &&  ! v .is_arg  &&  ! p ->translated  &&  ! v .is_global ) {
 /*if*/
 
 Parser_error( p , _STR("`%.*s` is immutable", v .name.len, v .name.str) ) ;
 
 }
 ;
 
bool is_str=string_eq( v .typ , tos2("string") ) ;
 
 if ( ( tok ==  ASSIGN )) { /* case */
 
 if ( ! is_map ) {
 /*if*/
 
 Parser_gen( p , tos2(" = ") ) ;
 
 }
 ;
 
 }
 else  if ( ( tok ==  PLUS_ASSIGN )) { /* case */
 
 if ( is_str ) {
 /*if*/
 
 Parser_gen( p , _STR("= string_add(%.*s, ", v .name.len, v .name.str) ) ;
 
 }
  else  if ( ! is_map ) {
 /*if*/
 
 Parser_gen( p , tos2(" += ") ) ;
 
 }
 ;
 
 }
 else  { // default:
 
 if ( tok != MINUS_ASSIGN  &&  tok != MULT_ASSIGN  &&  tok != XOR_ASSIGN  &&  tok != MOD_ASSIGN  &&  tok != AND_ASSIGN  &&  tok != OR_ASSIGN  &&  tok != RIGHT_SHIFT_ASSIGN  &&  tok != LEFT_SHIFT_ASSIGN  &&  tok != DIV_ASSIGN ) {
 /*if*/
 
 Parser_gen( p ,string_add(string_add( tos2(" ") , Token_str( p ->tok ) ) , tos2(" ") ) ) ;
 
 }
 ;
 
 }
 ;
 
 Parser_fgen( p ,string_add(string_add( tos2(" ") , Token_str( p ->tok ) ) , tos2(" ") ) ) ;
 
 Parser_next( p ) ;
 
int pos= p ->cgen ->cur_line .len ;
 
string expr_type= Parser_bool_expression( p ) ;
 
 if ( string_starts_with( p ->assigned_type , tos2("Option_") )  && string_eq( expr_type , string_right( p ->assigned_type , tos2("Option_") .len ) ) ) {
 /*if*/
 
 println ( tos2("allowing option asss") ) ;
 
string expr= string_right( p ->cgen ->cur_line , pos ) ;
 
string left= string_left( p ->cgen ->cur_line , pos ) ;
 
 p ->cgen ->cur_line  = string_add( left , _STR("opt_ok(%.*s)", expr.len, expr.str) ) ;
 
 }
  else  if ( ! p ->builtin_pkg  &&  ! Parser_check_types_no_throw( p , expr_type , p ->assigned_type ) ) {
 /*if*/
 
 p ->scanner ->line_nr -- ;
 
 Parser_error( p , _STR("cannot use type `%.*s` as type `%.*s` in assignment", expr_type.len, expr_type.str, p ->assigned_type.len, p ->assigned_type.str) ) ;
 
 }
 ;
 
 if ( is_str  &&  tok == PLUS_ASSIGN ) {
 /*if*/
 
 Parser_gen( p , tos2(")") ) ;
 
 }
 ;
 
 p ->assigned_type  =  tos2("") ;
 
 if ( ! v .is_used ) {
 /*if*/
 
 Fn_mark_var_used(& /* ? */* p ->cur_fn , v ) ;
 
 }
 ;
 
 
 }
 void Parser_var_decl(Parser* p) {
 
bool is_mut= p ->tok == MUT  ||  p ->prev_tok == FOR ;
 
bool is_static= p ->tok == STATIC ;
 
 if ( p ->tok == MUT ) {
 /*if*/
 
 Parser_check( p , MUT ) ;
 
 Parser_fspace( p ) ;
 
 }
 ;
 
 if ( p ->tok == STATIC ) {
 /*if*/
 
 Parser_check( p , STATIC ) ;
 
 Parser_fspace( p ) ;
 
 }
 ;
 
string name= Parser_check_name( p ) ;
 
 if ( ! p ->builtin_pkg  &&  Fn_known_var(& /* ? */* p ->cur_fn , name ) ) {
 /*if*/
 
Var v= Fn_find_var(& /* ? */* p ->cur_fn , name ) ;
 
 Parser_error( p , _STR("redefinition of `%.*s`", name.len, name.str) ) ;
 
 }
 ;
 
 Parser_check_space( p , DECL_ASSIGN ) ;
 
int pos= CGen_add_placeholder( p ->cgen ) ;
 
string typ= Parser_bool_expression( p ) ;
 
bool or_else= p ->tok == OR_ELSE ;
 
string tmp= Parser_get_tmp( p ) ;
 
 if ( or_else ) {
 /*if*/
 
 CGen_set_placeholder( p ->cgen , pos , _STR("%.*s %.*s = ", typ.len, typ.str, tmp.len, tmp.str) ) ;
 
 Parser_gen( p , tos2(";") ) ;
 
 typ  =  string_replace( typ , tos2("Option_") , tos2("") ) ;
 
 Parser_next( p ) ;
 
 Parser_check( p , LCBR ) ;
 
 Parser_genln( p , _STR("if (!%.*s .ok) {", tmp.len, tmp.str) ) ;
 
 Parser_statements( p ) ;
 
 Parser_genln( p , _STR("%.*s %.*s = *(%.*s*) %.*s . data;", typ.len, typ.str, name.len, name.str, typ.len, typ.str, tmp.len, tmp.str) ) ;
 
 if ( ! p ->returns  &&  p ->prev_tok2 != CONTINUE  &&  p ->prev_tok2 != BREAK ) {
 /*if*/
 
 println (int_str( p ->prev_tok2 ) ) ;
 
 Parser_error( p , tos2("`or` statement must return/continue/break") ) ;
 
 }
 ;
 
 }
 ;
 
 Parser_register_var( p , (Var) { .name =  name , .typ =  typ , .is_mut =  is_mut , .is_arg = 0 , .is_const = 0 , .is_import_const = 0 , .args = new_array(0, 1, sizeof(Var)) , .attr = tos("", 0) , .ptr = 0 , .ref = 0 , .parent_fn = tos("", 0) , .pkg = tos("", 0) , .line_nr = 0 , .is_global = 0 , .is_used = 0 , .scope_level = 0 } ) ;
 
string cgen_typ= typ ;
 
 if ( ! or_else ) {
 /*if*/
 
string gen_name= Table_var_cgen_name( p ->table , name ) ;
 
string nt_gen=string_add( Table_cgen_name_type_pair(& /* ? */* p ->table , gen_name , cgen_typ ) , tos2("=") ) ;
 
 if ( is_static ) {
 /*if*/
 
 nt_gen  =  _STR("static %.*s", nt_gen.len, nt_gen.str) ;
 
 }
 ;
 
 CGen_set_placeholder( p ->cgen , pos , nt_gen ) ;
 
 }
 ;
 
 
 }
 string Parser_bool_expression(Parser* p) {
 
Token tok= p ->tok ;
 
string typ= Parser_bterm( p ) ;
 
 while ( p ->tok == AND  ||  p ->tok == OR ) {
 
 Parser_gen( p , _STR(" %.*s ", Token_str( p ->tok ).len, Token_str( p ->tok ).str) ) ;
 
 Parser_next( p ) ;
 
 Parser_check_types( p , Parser_bterm( p ) , typ ) ;
 
 }
 ;
 
 if (string_eq( typ , tos2("") ) ) {
 /*if*/
 
 println ( tos2("curline:") ) ;
 
 println ( p ->cgen ->cur_line ) ;
 
 println ( Token_str( tok ) ) ;
 
 Parser_error( p , tos2("expr() returns empty type") ) ;
 
 }
 ;

 
 return  typ ;
 
 
 }
 string Parser_bterm(Parser* p) {
 
int ph= CGen_add_placeholder( p ->cgen ) ;
 
string typ= Parser_expression( p ) ;
 
bool is_str=string_eq( typ , tos2("string") ) ;
 
Token tok= p ->tok ;
 
 if ( tok == EQ  ||  tok == GT  ||  tok == LT  ||  tok == LE  ||  tok == GE  ||  tok == NE ) {
 /*if*/
 
 Parser_fgen( p , _STR(" %.*s ", Token_str( p ->tok ).len, Token_str( p ->tok ).str) ) ;
 
 if ( is_str ) {
 /*if*/
 
 Parser_gen( p , tos2(",") ) ;
 
 }
  else { 
 /*else if*/
 
 Parser_gen( p , Token_str( tok ) ) ;
 
 }
 ;
 
 Parser_next( p ) ;
 
 Parser_check_types( p , Parser_expression( p ) , typ ) ;
 
 typ  =  tos2("bool") ;
 
 if ( is_str ) {
 /*if*/
 
 Parser_gen( p , tos2(")") ) ;
 
 if ( ( tok ==  EQ )) { /* case */
 
 CGen_set_placeholder( p ->cgen , ph , tos2("string_eq(") ) ;
 
 }
 else  if ( ( tok ==  NE )) { /* case */
 
 CGen_set_placeholder( p ->cgen , ph , tos2("string_ne(") ) ;
 
 }
 else  if ( ( tok ==  LE )) { /* case */
 
 CGen_set_placeholder( p ->cgen , ph , tos2("string_le(") ) ;
 
 }
 else  if ( ( tok ==  GE )) { /* case */
 
 CGen_set_placeholder( p ->cgen , ph , tos2("string_ge(") ) ;
 
 }
 else  if ( ( tok ==  GT )) { /* case */
 
 CGen_set_placeholder( p ->cgen , ph , tos2("string_gt(") ) ;
 
 }
 else  if ( ( tok ==  LT )) { /* case */
 
 CGen_set_placeholder( p ->cgen , ph , tos2("string_lt(") ) ;
 
 }
 ;
 
 }
 ;
 
 }
 ;

 
 return  typ ;
 
 
 }
 string Parser_name_expr(Parser* p) {
 
 Parser_log(& /* ? */* p , _STR("\nname expr() pass=%d tok=%.*s %.*s", p ->run, Token_str( p ->tok ).len, Token_str( p ->tok ).str, p ->lit.len, p ->lit.str) ) ;
 
int hack_pos= p ->scanner ->pos ;
 
Token hack_tok= p ->tok ;
 
string hack_lit= p ->lit ;
 
bool ptr= p ->tok == AMP ;
 
bool deref= p ->tok == MUL ;
 
 if ( ptr  ||  deref ) {
 /*if*/
 
 Parser_next( p ) ;
 
 }
 ;
 
 if ( deref ) {
 /*if*/
 
 if ( p ->is_play  &&  ! p ->builtin_pkg ) {
 /*if*/
 
 Parser_error( p , tos2("dereferencing is temporarily disabled on the playground, will be fixed soon") ) ;
 
 }
 ;
 
 }
 ;
 
string name= p ->lit ;
 
 Parser_fgen( p , name ) ;
 
string orig_name= name ;
 
bool is_c=string_eq( name , tos2("C") )  &&  Parser_peek( p ) == DOT ;
 
bool is_c_struct_init= is_c  &&  ptr ;
 
 if ( is_c ) {
 /*if*/
 
 Parser_next( p ) ;
 
 Parser_check( p , DOT ) ;
 
 name  =  p ->lit ;
 
 Parser_fgen( p , name ) ;
 
 if ( ! is_c_struct_init  &&  Parser_peek( p ) == LCBR ) {
 /*if*/
 
 is_c_struct_init  =  1 ;
 
 }
 ;
 
 }
 ;
 
 if ( Table_known_pkg(& /* ? */* p ->table , name )  &&  ! Fn_known_var(& /* ? */* p ->cur_fn , name )  &&  ! is_c ) {
 /*if*/
 
string pkg= name ;
 
 Parser_next( p ) ;
 
 Parser_check( p , DOT ) ;
 
 name  =  p ->lit ;
 
 Parser_fgen( p , name ) ;
 
 name  =  prepend_pkg ( pkg , name ) ;
 
 }
  else  if ( ! Table_known_type(& /* ? */* p ->table , name )  &&  ! Fn_known_var(& /* ? */* p ->cur_fn , name )  &&  ! Table_known_fn(& /* ? */* p ->table , name )  &&  ! Table_known_const(& /* ? */* p ->table , name )  &&  ! is_c ) {
 /*if*/
 
 name  =  Parser_prepend_pkg(& /* ? */* p , name ) ;
 
 }
 ;
 
Var v= Fn_find_var(& /* ? */* p ->cur_fn , name ) ;
 
 if ( v .name .len != 0 ) {
 /*if*/
 
 if ( ptr ) {
 /*if*/
 
 Parser_gen( p , tos2("& /*vvar*/ ") ) ;
 
 }
  else  if ( deref ) {
 /*if*/
 
 Parser_gen( p , tos2("*") ) ;
 
 }
 ;
 
string typ= Parser_var_expr( p , v ) ;
 
 if ( deref ) {
 /*if*/
 
 if ( ! string_contains( typ , tos2("*") )  &&  ! string_ends_with( typ , tos2("ptr") ) ) {
 /*if*/
 
 println ( _STR("name=\"%.*s\", t=%.*s", name.len, name.str, v .typ.len, v .typ.str) ) ;
 
 Parser_error( p , _STR("dereferencing requires a pointer, but got `%.*s`", typ.len, typ.str) ) ;
 
 }
 ;
 
 typ  =  string_replace( typ , tos2("ptr") , tos2("") ) ;
 
 typ  =  string_replace( typ , tos2("*") , tos2("") ) ;
 
 }
  else  if ( ptr ) {
 /*if*/
 
 typ  = string_add( typ , tos2("*") ) ;
 
 }
 ;

 
 return  typ ;
 
 }
 ;
 
 if ( Table_known_type(& /* ? */* p ->table , name ) ) {
 /*if*/
 
 if ( ! is_c  &&  (/*lpar*/ Parser_peek( p ) == LPAR  ||  (/*lpar*/ deref  &&  Parser_peek( p ) == RPAR ) ) ) {
 /*if*/
 
 if ( deref ) {
 /*if*/
 
 name  = string_add( name , tos2("*") ) ;
 
 }
  else  if ( ptr ) {
 /*if*/
 
 name  = string_add( name , tos2("*") ) ;
 
 }
 ;
 
 Parser_gen( p , tos2("(") ) ;
 
string typ= Parser_cast( p , name ) ;
 
 Parser_gen( p , tos2(")") ) ;
 
 while ( p ->tok == DOT ) {
 
 typ  =  Parser_dot( p , typ , 0 ) ;
 
 }
 ;

 
 return  typ ;
 
 }
  else  if ( Parser_peek( p ) == DOT ) {
 /*if*/
 
Type* enum_type= Table_find_type(& /* ? */* p ->table , name ) ;
 
 if ( ! enum_type ->is_enum ) {
 /*if*/
 
 Parser_error( p , _STR("`%.*s` is not an enum", name.len, name.str) ) ;
 
 }
 ;
 
 Parser_next( p ) ;
 
 Parser_check( p , DOT ) ;
 
string val= p ->lit ;
 
 Parser_gen( p ,string_add(string_add(string_add(string_add( p ->pkg , tos2("__") ) , enum_type ->name ) , tos2("_") ) , val ) ) ;
 
 Parser_next( p ) ;

 
 return  enum_type ->name ;
 
 }
  else  if ( Parser_peek( p ) == LCBR ) {
 /*if*/
 
 p ->scanner ->pos  =  hack_pos ;
 
 p ->tok  =  hack_tok ;
 
 p ->lit  =  hack_lit ;
 
 if ( is_c_struct_init ) {
 /*if*/
 
 p ->is_c_struct_init  =  1 ;
 
 CGen_insert_before( p ->cgen , tos2("struct /*c struct init*/") ) ;
 
 }
 ;

 
 return  Parser_struct_init( p , is_c_struct_init ) ;
 
 }
 ;
 
 }
 ;
 
 if ( is_c ) {
 /*if*/
 
Fn f= (Fn) { .name =  name , .is_c =  1 , .pkg = tos("", 0) , .local_vars = new_array(0, 1, sizeof(Var)) , .var_idx = 0 , .args = new_array(0, 1, sizeof(Var)) , .is_interface = 0 , .scope_level = 0 , .typ = tos("", 0) , .receiver_typ = tos("", 0) , .is_public = 0 , .is_method = 0 , .returns_error = 0 , .is_decl = 0 , .defer = tos("", 0) } ;
 
 Parser_fn_call( p , f , 0 , tos2("") , tos2("") ) ;
 
Fn cfn= Table_find_fn(& /* ? */* p ->table , name ) ;
 
 if (string_eq( cfn .name , tos2("") ) ) {
 /*if*/

 
 return  tos2("void*") ;
 
 }
 ;

 
 return  cfn .typ ;
 
 }
 ;
 
Var c= Table_find_const(& /* ? */* p ->table , name ) ;
 
 if (string_ne( c .name , tos2("") )  &&  ptr  &&  ! c .is_global ) {
 /*if*/
 
 Parser_error( p , _STR("cannot take the address of constant `%.*s`", c .name.len, c .name.str) ) ;
 
 }
 ;
 
 if ( c .name .len != 0 ) {
 /*if*/
 
 if ( ptr ) {
 /*if*/
 
 Parser_gen( p , tos2("& /*const*/ ") ) ;
 
 }
 ;
 
 Parser_log(& /* ? */* p , tos2("calling var expr") ) ;
 
string typ= Parser_var_expr( p , c ) ;
 
 if ( ptr ) {
 /*if*/
 
 typ  = string_add( typ , tos2("*") ) ;
 
 }
 ;

 
 return  typ ;
 
 }
 ;
 
Fn f= Table_find_fn(& /* ? */* p ->table , name ) ;
 
 if (string_eq( f .name , tos2("") ) ) {
 /*if*/
 
 if ( ! Parser_first_run(& /* ? */* p ) ) {
 /*if*/
 
 if ( Table_known_pkg(& /* ? */* p ->table , orig_name ) ) {
 /*if*/
 
 name  =  string_replace( name , tos2("__") , tos2(".") ) ;
 
 Parser_error( p , _STR("undefined: `%.*s`", name.len, name.str) ) ;
 
 }
  else { 
 /*else if*/
 
 Parser_error( p , _STR("undefined: `%.*s`", orig_name.len, orig_name.str) ) ;
 
 }
 ;
 
 }
 ;
 
 Parser_next( p ) ;

 
 return  tos2("void") ;
 
 }
 ;
 
 if ( Parser_peek( p ) != LPAR ) {
 /*if*/
 
 Parser_gen( p , Table_cgen_name( p ->table ,& /*11 EXP:"Fn*" GOT:"Fn" */ f ) ) ;
 
 Parser_next( p ) ;

 
 return  tos2("void*") ;
 
 }
 ;
 
 if (string_eq( f .typ , tos2("void") )  &&  ! p ->inside_if_expr ) {
 /*if*/
 
 }
 ;
 
 Parser_log(& /* ? */* p , tos2("calling function") ) ;
 
 Parser_fn_call( p , f , 0 , tos2("") , tos2("") ) ;
 
 if ( p ->tok == DOT ) {
 /*if*/
 
string typ= tos2("") ;
 
 while ( p ->tok == DOT ) {
 
 typ  =  Parser_dot( p , f .typ , 0 ) ;
 
 }
 ;

 
 return  typ ;
 
 }
 ;
 
 Parser_log(& /* ? */* p , tos2("end of name_expr") ) ;

 
 return  f .typ ;
 
 
 }
 string Parser_var_expr(Parser* p, Var v) {
 
 Parser_log(& /* ? */* p , _STR("\nvar_expr() v.name=\"%.*s\" v.typ=\"%.*s\"", v .name.len, v .name.str, v .typ.len, v .typ.str) ) ;
 
 Fn_mark_var_used(& /* ? */* p ->cur_fn , v ) ;
 
int fn_ph= CGen_add_placeholder( p ->cgen ) ;
 
 p ->expr_var  =  v ;
 
 Parser_gen( p , Table_var_cgen_name( p ->table , v .name ) ) ;
 
 Parser_next( p ) ;
 
string typ= v .typ ;
 
 if ( string_starts_with( typ , tos2("fn ") ) ) {
 /*if*/
 
 println ( tos2("CALLING FN PTR") ) ;
 
 Parser_print_tok(& /* ? */* p ) ;
 
Type* T= Table_find_type(& /* ? */* p ->table , typ ) ;
 
 Parser_gen( p , tos2("(") ) ;
 
 Parser_fn_call_args( p ,& /*11 EXP:"Fn*" GOT:"Fn" */ T ->func ) ;
 
 Parser_gen( p , tos2(")") ) ;
 
 typ  =  T ->func .typ ;
 
 }
 ;
 
 if ( p ->tok == LSBR ) {
 /*if*/
 
 typ  =  Parser_index_expr( p , typ , fn_ph ) ;
 
 }
 ;
 
 while ( p ->tok == DOT ) {
 
 typ  =  Parser_dot( p , typ , fn_ph ) ;
 
 Parser_log(& /* ? */* p , _STR("typ after dot=%.*s", typ.len, typ.str) ) ;
 
 if ( p ->tok == LSBR ) {
 /*if*/
 
 }
 ;
 
 }
 ;
 
 if ( p ->tok == INC  ||  p ->tok == DEC ) {
 /*if*/
 
 if ( ! v .is_mut  &&  ! v .is_arg  &&  ! p ->translated ) {
 /*if*/
 
 Parser_error( p , _STR("`%.*s` is immutable", v .name.len, v .name.str) ) ;
 
 }
 ;
 
 if (string_ne( typ , tos2("int") ) ) {
 /*if*/
 
 if ( ! p ->translated  &&  ! is_number_type ( typ ) ) {
 /*if*/
 
 Parser_error( p , _STR("cannot ++/-- value of type `%.*s`", typ.len, typ.str) ) ;
 
 }
 ;
 
 }
 ;
 
 Parser_gen( p , Token_str( p ->tok ) ) ;
 
 Parser_fgen( p , Token_str( p ->tok ) ) ;
 
 Parser_next( p ) ;
 
 if ( p ->translated ) {
 /*if*/

 
 return  Parser_index_expr( p , typ , fn_ph ) ;
 
 }
  else { 
 /*else if*/

 
 return  tos2("void") ;
 
 }
 ;
 
 }
 ;
 
 typ  =  Parser_index_expr( p , typ , fn_ph ) ;

 
 return  typ ;
 
 
 }
 bool Parser_fileis(Parser* p, string s) {

 
 return  string_contains( p ->scanner ->file_path , s ) ;
 
 
 }
 string Parser_dot(Parser* p, string str_typ, int method_ph) {
 
 Parser_check( p , DOT ) ;
 
string field_name= p ->lit ;
 
 Parser_fgen( p , field_name ) ;
 
 Parser_log(& /* ? */* p , _STR("dot() field_name=%.*s typ=%.*s", field_name.len, field_name.str, str_typ.len, str_typ.str) ) ;
 
 if ( Parser_fileis(& /* ? */* p , tos2("hi_test") ) ) {
 /*if*/
 
 println ( _STR("dot() field_name=%.*s typ=%.*s", field_name.len, field_name.str, str_typ.len, str_typ.str) ) ;
 
 }
 ;
 
Type* typ= Parser_find_type(& /* ? */* p , str_typ ) ;
 
 if ( typ ->name .len == 0 ) {
 /*if*/
 
 Parser_error( p , _STR("dot(): cannot find type `%.*s`", str_typ.len, str_typ.str) ) ;
 
 }
 ;
 
bool has_field= Table_type_has_field(& /* ? */* p ->table , typ , field_name ) ;
 
bool has_method= Table_type_has_method(& /* ? */* p ->table , typ , field_name ) ;
 
 if ( ! typ ->is_c  &&  ! has_field  &&  ! has_method  &&  ! Parser_first_run(& /* ? */* p ) ) {
 /*if*/
 
 if ( string_starts_with( typ ->name , tos2("Option_") ) ) {
 /*if*/
 
string opt_type= string_substr( typ ->name , 7 , typ ->name .len ) ;
 
 Parser_error( p , _STR("unhandled option type: %.*s?", opt_type.len, opt_type.str) ) ;
 
 }
 ;
 
 println ( tos2("dot():") ) ;
 
 println ( tos2("fields:") ) ;
 
 array_Var tmp142 =  typ ->fields;
 ;
for (int tmp143 = 0; tmp143 < tmp142 .len; tmp143 ++) {
 Var field = ((Var *) tmp142.data)[tmp143];
 
 println ( field .name ) ;
 
 }
 ;
 
 println ( tos2("methods:") ) ;
 
 array_Fn tmp144 =  typ ->methods;
 ;
for (int tmp145 = 0; tmp145 < tmp144 .len; tmp145 ++) {
 Fn field = ((Fn *) tmp144.data)[tmp145];
 
 println ( field .name ) ;
 
 }
 ;
 
 println ( _STR("str_typ==\"%.*s\"", str_typ.len, str_typ.str) ) ;
 
 Parser_error( p , _STR("type `%.*s`  has no field or method `%.*s`", typ ->name.len, typ ->name.str, field_name.len, field_name.str) ) ;
 
 }
 ;
 
string dot= tos2(".") ;
 
 if ( string_contains( str_typ , tos2("*") ) ) {
 /*if*/
 
 dot  =  tos2("->") ;
 
 }
 ;
 
 if ( has_field ) {
 /*if*/
 
Var field= Table_find_field(& /* ? */* p ->table , typ , field_name ) ;
 
Token next= Parser_peek( p ) ;
 
bool modifying= Token_is_assign( next )  ||  next == INC  ||  next == DEC ;
 
bool is_vi= Parser_fileis(& /* ? */* p , tos2("vi") ) ;
 
 if ( ! p ->builtin_pkg  &&  ! p ->translated  &&  modifying  &&  ! field .is_mut  &&  ! is_vi ) {
 /*if*/
 
 Parser_error( p , _STR("cannot modify immutable field `%.*s` (type `%.*s`)", field_name.len, field_name.str, typ ->name.len, typ ->name.str) ) ;
 
 }
 ;
 
 if ( ! p ->builtin_pkg  && string_ne( p ->pkg , typ ->pkg ) ) {
 /*if*/
 
 }
 ;
 
 if ( field .access_mod == PRIVATE  &&  ! p ->builtin_pkg  &&  ! p ->translated  && string_ne( p ->pkg , typ ->pkg ) ) {
 /*if*/
 
 Parser_error( p , _STR("cannot refer to unexported field `%.*s` (type `%.*s`)", field_name.len, field_name.str, typ ->name.len, typ ->name.str) ) ;
 
 }
 ;
 
 if ( field .access_mod == PUBLIC  &&  ! p ->builtin_pkg  && string_ne( p ->pkg , typ ->pkg ) ) {
 /*if*/
 
 if ( ! field .is_mut  &&  ! p ->translated  &&  modifying ) {
 /*if*/
 
 Parser_error( p , _STR("cannot modify public immutable field `%.*s` (type `%.*s`)", field_name.len, field_name.str, typ ->name.len, typ ->name.str) ) ;
 
 }
 ;
 
 }
 ;
 
 Parser_gen( p , _STR("%.*s%.*s", dot.len, dot.str, field_name.len, field_name.str) ) ;
 
 Parser_next( p ) ;

 
 return  field .typ ;
 
 }
 ;
 
Fn method= Table_find_method(& /* ? */* p ->table , typ , field_name ) ;
 
 Parser_fn_call( p , method , method_ph , tos2("") , str_typ ) ;
 
 if (string_eq( method .typ , tos2("array") )  &&  string_starts_with( typ ->name , tos2("array_") ) ) {
 /*if*/

 
 return  typ ->name ;
 
 }
 ;
 
 if (string_eq( method .typ , tos2("void*") )  &&  string_starts_with( typ ->name , tos2("array_") ) ) {
 /*if*/

 
 return  string_right( typ ->name , 6 ) ;
 
 }
 ;
 
 if ( 0  &&  p ->tok == LSBR ) {
 /*if*/

 
 return  Parser_index_expr( p , method .typ , method_ph ) ;
 
 }
 ;

 
 return  method .typ ;
 
 
 }
 string Parser_index_expr(Parser* p, string typ, int fn_ph) {
 
 if ( Parser_fileis(& /* ? */* p , tos2("int_test") ) ) {
 /*if*/
 
 println ( _STR("index expr typ=%.*s", typ.len, typ.str) ) ;
 
 }
 ;
 
Var v= p ->expr_var ;
 
bool is_map= string_starts_with( typ , tos2("map_") ) ;
 
bool is_str=string_eq( typ , tos2("string") ) ;
 
bool is_arr0= string_starts_with( typ , tos2("array_") ) ;
 
bool is_arr= is_arr0  || string_eq( typ , tos2("array") ) ;
 
bool is_ptr=string_eq( typ , tos2("byte*") )  || string_eq( typ , tos2("byteptr") )  ||  string_contains( typ , tos2("*") ) ;
 
bool is_indexer= p ->tok == LSBR ;
 
bool close_bracket= 0 ;
 
 if ( is_indexer ) {
 /*if*/
 
bool is_fixed_arr= string_at( typ , 0) == '[' ;
 
 if ( ! is_str  &&  ! is_arr  &&  ! is_map  &&  ! is_ptr  &&  ! is_fixed_arr ) {
 /*if*/
 
 Parser_error( p , _STR("Cant [] non-array/string/map. Got type \"%.*s\"", typ.len, typ.str) ) ;
 
 }
 ;
 
 Parser_check( p , LSBR ) ;
 
 if ( is_str ) {
 /*if*/
 
 typ  =  tos2("byte") ;
 
 Parser_fgen( p , tos2("[") ) ;
 
 if ( p ->builtin_pkg ) {
 /*if*/
 
 Parser_gen( p , tos2(".str[") ) ;
 
 close_bracket  =  1 ;
 
 }
  else { 
 /*else if*/
 
 Parser_gen( p , tos2(",") ) ;
 
 }
 ;
 
 }
 ;
 
 if ( is_fixed_arr ) {
 /*if*/
 
 if ( string_contains( typ , tos2("][") ) ) {
 /*if*/
 
int pos= string_index_after( typ , tos2("[") , 1 ) ;
 
 typ  =  string_right( typ , pos ) ;
 
 }
  else { 
 /*else if*/
 
 typ  =  string_all_after( typ , tos2("]") ) ;
 
 }
 ;
 
 Parser_gen( p , tos2("[") ) ;
 
 close_bracket  =  1 ;
 
 }
  else  if ( is_ptr ) {
 /*if*/
 
 typ  =  string_replace( typ , tos2("*") , tos2("") ) ;
 
 if ( ! is_arr ) {
 /*if*/
 
 Parser_gen( p , tos2("[/*ptr*/") ) ;
 
 close_bracket  =  1 ;
 
 }
 ;
 
 }
 ;
 
 if ( is_arr ) {
 /*if*/
 
 Parser_fgen( p , tos2("[") ) ;
 
 if ( is_arr0 ) {
 /*if*/
 
 if ( Parser_fileis(& /* ? */* p , tos2("int_test") ) ) {
 /*if*/
 
 println ( _STR("\nRRRR0 %.*s", typ.len, typ.str) ) ;
 
 }
 ;
 
 typ  =  string_right( typ , 6 ) ;
 
 if ( Parser_fileis(& /* ? */* p , tos2("int_test") ) ) {
 /*if*/
 
 println ( _STR("RRRR %.*s", typ.len, typ.str) ) ;
 
 }
 ;
 
 }
 ;
 
 if (string_eq( typ , tos2("array") ) ) {
 /*if*/
 
 typ  =  tos2("void*") ;
 
 }
 ;
 
 if ( p ->translated ) {
 /*if*/
 
 CGen_set_placeholder( p ->cgen , fn_ph , _STR("((%.*s*)(", typ.len, typ.str) ) ;
 
 Parser_gen( p , tos2(".data))[") ) ;
 
 }
  else { 
 /*else if*/
 
 Parser_gen( p , tos2(",") ) ;
 
 }
 ;
 
 }
 ;
 
 if ( is_map ) {
 /*if*/
 
 typ  =  string_replace( typ , tos2("map_") , tos2("") ) ;
 
 if (string_eq( typ , tos2("map") ) ) {
 /*if*/
 
 typ  =  tos2("void*") ;
 
 }
 ;
 
 Parser_gen( p , tos2(",") ) ;
 
 }
 ;
 
 if ( is_arr ) {
 /*if*/
 
Type* T= Table_find_type(& /* ? */* p ->table , Parser_expression( p ) ) ;
 
 if (string_ne( T ->parent , tos2("int") ) ) {
 /*if*/
 
 Parser_check_types( p , T ->name , tos2("int") ) ;
 
 }
 ;
 
 }
  else { 
 /*else if*/
 
 Parser_expression( p ) ;
 
 }
 ;
 
 Parser_check( p , RSBR ) ;
 
 if ( close_bracket ) {
 /*if*/
 
 Parser_gen( p , _STR("]/*r%.*s %d*/", typ.len, typ.str, v .is_mut) ) ;
 
 }
 ;
 
 }
 ;
 
 if ( p ->tok == ASSIGN  ||  p ->tok == PLUS_ASSIGN  ||  p ->tok == MINUS_ASSIGN  ||  p ->tok == MULT_ASSIGN  ||  p ->tok == DIV_ASSIGN  ||  p ->tok == XOR_ASSIGN  ||  p ->tok == MOD_ASSIGN  ||  p ->tok == OR_ASSIGN  ||  p ->tok == AND_ASSIGN  ||  p ->tok == RIGHT_SHIFT_ASSIGN  ||  p ->tok == LEFT_SHIFT_ASSIGN ) {
 /*if*/
 
 if ( is_map  ||  is_arr ) {
 /*if*/
 
 }
 ;
 
 if ( is_indexer  &&  is_str  &&  ! p ->builtin_pkg ) {
 /*if*/
 
 Parser_error( p , tos2("strings are immutable") ) ;
 
 }
 ;
 
int assign_pos= p ->cgen ->cur_line .len ;
 
 p ->assigned_type  =  typ ;
 
 Parser_assign_statement( p , v , fn_ph , is_indexer  &&  (/*lpar*/ is_map  ||  is_arr ) ) ;
 
 if ( is_indexer  &&  (/*lpar*/ is_map  ||  is_arr ) ) {
 /*if*/
 
string tmp= Parser_get_tmp( p ) ;
 
string tmp_val= string_right( p ->cgen ->cur_line , assign_pos ) ;
 
 p ->cgen ->cur_line  =  string_left( p ->cgen ->cur_line , assign_pos ) ;
 
 if ( is_map ) {
 /*if*/
 
 CGen_set_placeholder( p ->cgen , fn_ph , tos2("map__set(&") ) ;
 
 }
  else { 
 /*else if*/
 
 if ( is_ptr ) {
 /*if*/
 
 CGen_set_placeholder( p ->cgen , fn_ph , tos2("array_set(") ) ;
 
 }
  else { 
 /*else if*/
 
 CGen_set_placeholder( p ->cgen , fn_ph , tos2("array_set(&/*q*/") ) ;
 
 }
 ;
 
 }
 ;
 
 Parser_gen( p , _STR(", & %.*s)", tmp.len, tmp.str) ) ;
 
 CGen_insert_before( p ->cgen , _STR("%.*s %.*s = %.*s;", typ.len, typ.str, tmp.len, tmp.str, tmp_val.len, tmp_val.str) ) ;
 
 }
 ;

 
 return  typ ;

 
 return  tos2("void") ;
 
 }
  else  if ( (/*lpar*/ is_map  ||  is_arr  ||  (/*lpar*/ is_str  &&  ! p ->builtin_pkg ) )  &&  is_indexer ) {
 /*if*/
 
string index_expr= string_right( p ->cgen ->cur_line , fn_ph ) ;
 
 p ->cgen ->cur_line  =  string_left( p ->cgen ->cur_line , fn_ph ) ;
 
string tmp= Parser_get_tmp( p ) ;
 
string tmp_ok= Parser_get_tmp( p ) ;
 
 if ( is_map ) {
 /*if*/
 
 Parser_gen( p , _STR("%.*s", tmp.len, tmp.str) ) ;
 
string def= type_default ( typ ) ;
 
 CGen_insert_before( p ->cgen , _STR("%.*s %.*s = %.*s; bool %.*s = map_get(%.*s, & %.*s);", typ.len, typ.str, tmp.len, tmp.str, def.len, def.str, tmp_ok.len, tmp_ok.str, index_expr.len, index_expr.str, tmp.len, tmp.str) ) ;
 
 }
  else  if ( is_arr ) {
 /*if*/
 
 if ( p ->translated ) {
 /*if*/
 
 Parser_gen( p , _STR("%.*s ]", index_expr.len, index_expr.str) ) ;
 
 }
  else { 
 /*else if*/
 
 Parser_gen( p , _STR("( *(%.*s*) array__get(%.*s) )", typ.len, typ.str, index_expr.len, index_expr.str) ) ;
 
 }
 ;
 
 }
  else  if ( is_str  &&  ! p ->builtin_pkg ) {
 /*if*/
 
 Parser_gen( p , _STR("string_at(%.*s)", index_expr.len, index_expr.str) ) ;
 
 }
 ;
 
 if ( is_map  && string_eq( typ , tos2("string") ) ) {
 /*if*/
 
 CGen_insert_before( p ->cgen , _STR("if (!%.*s) %.*s = tos(\"\", 0);", tmp_ok.len, tmp_ok.str, tmp.len, tmp.str) ) ;
 
 }
 ;
 
 }
 ;

 
 return  typ ;
 
 
 }
 string Parser_expression(Parser* p) {
 
 if ( string_contains( p ->scanner ->file_path , tos2("test_test") ) ) {
 /*if*/
 
 println ( _STR("epxression() pass=%d tok=", p ->run) ) ;
 
 Parser_print_tok(& /* ? */* p ) ;
 
 }
 ;
 
 p ->cgen ;
 
 (/*lpar*/ tos2("/* expr start*/") ) ; 
 
int ph= CGen_add_placeholder( p ->cgen ) ;
 
string typ= Parser_term( p ) ;
 
bool is_str=string_eq( typ , tos2("string") ) ;
 
 if ( p ->tok == LEFT_SHIFT ) {
 /*if*/
 
 if ( string_contains( typ , tos2("array_") ) ) {
 /*if*/
 
string tmp= Parser_get_tmp( p ) ;
 
string tmp_typ= string_right( typ , 6 ) ;
 
 Parser_next( p ) ;
 
 Parser_gen( p , tos2(", (") ) ;
 
 if ( ! p ->expr_var .is_mut  &&  ! p ->translated ) {
 /*if*/
 
 Parser_error( p , _STR("`%.*s` is immutable (can\'t <<)", p ->expr_var .name.len, p ->expr_var .name.str) ) ;
 
 }
 ;
 
 Parser_check_types( p , Parser_expression( p ) , tmp_typ ) ;
 
 Parser_gen( p , _STR("), %.*s, %.*s)", tmp.len, tmp.str, tmp_typ.len, tmp_typ.str) ) ;
 
string push_call= ( string_contains( typ , tos2("*") ) ) ? ( tos2("_PUSH(") ) : ( tos2("_PUSH(&") ) ;
 
 CGen_set_placeholder( p ->cgen , ph , push_call ) ;

 
 return  tos2("void") ;
 
 }
  else { 
 /*else if*/
 
 Parser_next( p ) ;
 
 Parser_gen( p , tos2(" << ") ) ;
 
 Parser_check_types( p , Parser_expression( p ) , typ ) ;

 
 return  tos2("int") ;
 
 }
 ;
 
 }
 ;
 
 if ( p ->tok == IN ) {
 /*if*/
 
 Parser_fgen( p , tos2(" ") ) ;
 
 Parser_check( p , IN ) ;
 
 Parser_fgen( p , tos2(" ") ) ;
 
 Parser_gen( p , tos2(", ") ) ;
 
string arr_typ= Parser_expression( p ) ;
 
 if ( ! string_starts_with( arr_typ , tos2("array_") ) ) {
 /*if*/
 
 Parser_error( p , tos2("`in` requires an array") ) ;
 
 }
 ;
 
Type* T= Table_find_type(& /* ? */* p ->table , arr_typ ) ;
 
 if ( ! Type_has_method(& /* ? */* T , tos2("contains") ) ) {
 /*if*/
 
 Parser_error( p , _STR("%.*s has no method `contains`", arr_typ.len, arr_typ.str) ) ;
 
 }
 ;
 
 CGen_set_placeholder( p ->cgen , ph , _STR("_IN(%.*s, ", typ.len, typ.str) ) ;
 
 Parser_gen( p , tos2(")") ) ;

 
 return  tos2("bool") ;
 
 }
 ;
 
 if ( p ->tok == RIGHT_SHIFT ) {
 /*if*/
 
 Parser_next( p ) ;
 
 Parser_gen( p , tos2(" >> ") ) ;
 
 Parser_check_types( p , Parser_expression( p ) , typ ) ;

 
 return  tos2("int") ;
 
 }
 ;
 
 if ( p ->tok == DOT ) {
 /*if*/
 
 while ( p ->tok == DOT ) {
 
 typ  =  Parser_dot( p , typ , 0 ) ;
 
 }
 ;
 
 }
 ;
 
 while ( p ->tok == PLUS  ||  p ->tok == MINUS  ||  p ->tok == PIPE  ||  p ->tok == AMP  ||  p ->tok == XOR ) {
 
Token tok_op= p ->tok ;
 
bool is_num=string_eq( typ , tos2("void*") )  || string_eq( typ , tos2("byte*") )  ||  is_number_type ( typ ) ;
 
 Parser_next( p ) ;
 
 if ( is_str  &&  tok_op == PLUS ) {
 /*if*/
 
 CGen_set_placeholder( p ->cgen , ph , tos2("string_add(") ) ;
 
 Parser_gen( p , tos2(",") ) ;
 
 }
  else  if ( is_num ) {
 /*if*/
 
 Parser_gen( p , Token_str( tok_op ) ) ;
 
 }
  else { 
 /*else if*/
 
 if ( p ->translated ) {
 /*if*/
 
 Parser_gen( p ,string_add( Token_str( tok_op ) , tos2(" /*doom hack*/") ) ) ;
 
 }
  else { 
 /*else if*/
 
 Parser_gen( p , tos2(",") ) ;
 
 }
 ;
 
 }
 ;
 
 Parser_check_types( p , Parser_term( p ) , typ ) ;
 
 if ( is_str  &&  tok_op == PLUS ) {
 /*if*/
 
 Parser_gen( p , tos2(")") ) ;
 
 }
 ;
 
 if ( ! p ->translated  &&  ! is_str  &&  ! is_num ) {
 /*if*/
 
Type* T= Table_find_type(& /* ? */* p ->table , typ ) ;
 
 if ( tok_op == PLUS ) {
 /*if*/
 
 if ( Type_has_method(& /* ? */* T , tos2("+") ) ) {
 /*if*/
 
 CGen_set_placeholder( p ->cgen , ph ,string_add( typ , tos2("_plus(") ) ) ;
 
 Parser_gen( p , tos2(")") ) ;
 
 }
  else { 
 /*else if*/
 
 Parser_error( p , _STR("operator + not defined on `%.*s`", typ.len, typ.str) ) ;
 
 }
 ;
 
 }
  else  if ( tok_op == MINUS ) {
 /*if*/
 
 if ( Type_has_method(& /* ? */* T , tos2("-") ) ) {
 /*if*/
 
 CGen_set_placeholder( p ->cgen , ph , _STR("%.*s_minus(", typ.len, typ.str) ) ;
 
 Parser_gen( p , tos2(")") ) ;
 
 }
  else { 
 /*else if*/
 
 Parser_error( p , _STR("operator - not defined on `%.*s`", typ.len, typ.str) ) ;
 
 }
 ;
 
 }
 ;
 
 }
 ;
 
 }
 ;

 
 return  typ ;
 
 
 }
 string Parser_term(Parser* p) {
 
int line_nr= p ->scanner ->line_nr ;
 
 if ( Parser_fileis(& /* ? */* p , tos2("fn_test") ) ) {
 /*if*/
 
 println ( _STR("\nterm() %d", line_nr) ) ;
 
 }
 ;
 
string typ= Parser_unary( p ) ;
 
 if ( Parser_fileis(& /* ? */* p , tos2("fn_test") ) ) {
 /*if*/
 
 println ( _STR("2: %d", line_nr) ) ;
 
 }
 ;
 
 if ( p ->tok == MUL  &&  line_nr != p ->scanner ->line_nr ) {
 /*if*/

 
 return  typ ;
 
 }
 ;
 
 while ( p ->tok == MUL  ||  p ->tok == DIV  ||  p ->tok == MOD ) {
 
Token tok= p ->tok ;
 
bool is_div= tok == DIV ;
 
bool is_mod= tok == MOD ;
 
 Parser_next( p ) ;
 
 Parser_gen( p , Token_str( tok ) ) ;
 
 Parser_fgen( p ,string_add(string_add( tos2(" ") , Token_str( tok ) ) , tos2(" ") ) ) ;
 
 if ( is_div  &&  p ->tok == INT  && string_eq( p ->lit , tos2("0") ) ) {
 /*if*/
 
 Parser_error( p , tos2("division by zero") ) ;
 
 }
 ;
 
 if ( is_mod  &&  (/*lpar*/ is_float_type ( typ )  ||  ! is_number_type ( typ ) ) ) {
 /*if*/
 
 Parser_error( p , tos2("operator MOD requires integer types") ) ;
 
 }
 ;
 
 Parser_check_types( p , Parser_unary( p ) , typ ) ;
 
 }
 ;

 
 return  typ ;
 
 
 }
 string Parser_unary(Parser* p) {
 
string typ= tos2("") ;
 
Token tok= p ->tok ;
 
 if ( ( tok ==  NOT )) { /* case */
 
 Parser_gen( p , tos2("!") ) ;
 
 Parser_next( p ) ;
 
 typ  =  tos2("bool") ;
 
 Parser_bool_expression( p ) ;
 
 }
 else  if ( ( tok ==  BIT_NOT )) { /* case */
 
 Parser_gen( p , tos2("~") ) ;
 
 Parser_next( p ) ;
 
 typ  =  Parser_bool_expression( p ) ;
 
 }
 else  { // default:
 
 typ  =  Parser_factor( p ) ;
 
 }
 ;

 
 return  typ ;
 
 
 }
 string Parser_factor(Parser* p) {
 
string typ= tos2("") ;
 
Token tok= p ->tok ;
 
 if ( ( tok ==  INT )) { /* case */
 
 typ  =  tos2("int") ;
 
 if ( (/*lpar*/ string_contains( p ->lit , tos2(".") )  ||  string_contains( p ->lit , tos2("e") ) )  &&  ! (/*lpar*/ string_at( p ->lit , 0) == '0'  &&  string_at( p ->lit , 1) == 'x' ) ) {
 /*if*/
 
 typ  =  tos2("f32") ;
 
 }
 ;
 
 Parser_gen( p , p ->lit ) ;
 
 Parser_fgen( p , p ->lit ) ;
 
 }
 else  if ( ( tok ==  MINUS )) { /* case */
 
 Parser_gen( p , tos2("-") ) ;
 
 Parser_fgen( p , tos2("-") ) ;
 
 Parser_next( p ) ;

 
 return  Parser_factor( p ) ;
 
 }
 else  if ( ( tok ==  SIZEOF )) { /* case */
 
 Parser_gen( p , tos2("sizeof(") ) ;
 
 Parser_fgen( p , tos2("sizeof(") ) ;
 
 Parser_next( p ) ;
 
 Parser_check( p , LPAR ) ;
 
string sizeof_typ= Parser_get_type( p ) ;
 
 if ( string_ends_with( sizeof_typ , tos2("*") ) ) {
 /*if*/
 
 sizeof_typ  = string_add( tos2("*") , string_left( sizeof_typ , sizeof_typ .len - 1 ) ) ;
 
 }
 ;
 
 Parser_check( p , RPAR ) ;
 
 Parser_gen( p , _STR("%.*s)", sizeof_typ.len, sizeof_typ.str) ) ;
 
 Parser_fgen( p , _STR("%.*s)", sizeof_typ.len, sizeof_typ.str) ) ;

 
 return  tos2("int") ;
 
 }
 else  if ( ( tok ==  AMP )) { /* case */

 
 return  Parser_name_expr( p ) ;
 
 }
 else  if ( ( tok ==  DOT )) { /* case */

 
 return  Parser_name_expr( p ) ;
 
 }
 else  if ( ( tok ==  MUL )) { /* case */

 
 return  Parser_name_expr( p ) ;
 
 }
 else  if ( ( tok ==  NAME )) { /* case */
 
 if (string_eq( p ->lit , tos2("map") )  &&  Parser_peek( p ) == LSBR ) {
 /*if*/

 
 return  Parser_map_init( p ) ;
 
 }
 ;
 
 if (string_eq( p ->lit , tos2("json") )  &&  Parser_peek( p ) == DOT ) {
 /*if*/

 
 return  Parser_js_decode( p ) ;
 
 }
 ;
 
 typ  =  Parser_name_expr( p ) ;

 
 return  typ ;
 
 }
 else  if ( ( tok ==  DEFAULT )) { /* case */
 
 Parser_next( p ) ;
 
 Parser_next( p ) ;
 
string name= Parser_check_name( p ) ;
 
 if (string_ne( name , tos2("T") ) ) {
 /*if*/
 
 Parser_error( p , tos2("default needs T") ) ;
 
 }
 ;
 
 Parser_gen( p , tos2("default(T)") ) ;
 
 Parser_next( p ) ;

 
 return  tos2("T") ;
 
 }
 else  if ( ( tok ==  LPAR )) { /* case */
 
 Parser_gen( p , tos2("(/*lpar*/") ) ;
 
 Parser_next( p ) ;
 
 typ  =  Parser_bool_expression( p ) ;
 
 if ( ! p ->ptr_cast ) {
 /*if*/
 
 Parser_check( p , RPAR ) ;
 
 }
 ;
 
 p ->ptr_cast  =  0 ;
 
 Parser_gen( p , tos2(")") ) ;

 
 return  typ ;
 
 }
 else  if ( ( tok ==  CHAR )) { /* case */
 
 Parser_char_expr( p ) ;
 
 typ  =  tos2("byte") ;

 
 return  typ ;
 
 }
 else  if ( ( tok ==  STRING )) { /* case */
 
 Parser_string_expr( p ) ;
 
 typ  =  tos2("string") ;

 
 return  typ ;
 
 }
 else  if ( ( tok ==  FALSE )) { /* case */
 
 typ  =  tos2("bool") ;
 
 Parser_gen( p , tos2("0") ) ;
 
 Parser_fgen( p , tos2("false") ) ;
 
 }
 else  if ( ( tok ==  TRUE )) { /* case */
 
 typ  =  tos2("bool") ;
 
 Parser_gen( p , tos2("1") ) ;
 
 Parser_fgen( p , tos2("true") ) ;
 
 }
 else  if ( ( tok ==  LSBR )) { /* case */

 
 return  Parser_array_init( p ) ;
 
 }
 else  if ( ( tok ==  LCBR )) { /* case */

 
 return  Parser_assoc( p ) ;
 
 }
 else  if ( ( tok ==  IF )) { /* case */
 
 typ  =  Parser_if_st( p , 1 ) ;

 
 return  typ ;
 
 }
 else  { // default:
 
Token next= Parser_peek( p ) ;
 
 println ( _STR("PREV=%.*s", Token_str( p ->prev_tok ).len, Token_str( p ->prev_tok ).str) ) ;
 
 println ( _STR("NEXT=%.*s", Token_str( next ).len, Token_str( next ).str) ) ;
 
 Parser_error( p , _STR("unexpected token: `%.*s`", Token_str( p ->tok ).len, Token_str( p ->tok ).str) ) ;
 
 }
 ;
 
 Parser_next( p ) ;

 
 return  typ ;
 
 
 }
 string Parser_assoc(Parser* p) {
 
 Parser_next( p ) ;
 
string name= Parser_check_name( p ) ;
 
 if ( ! Fn_known_var(& /* ? */* p ->cur_fn , name ) ) {
 /*if*/
 
 Parser_error( p , _STR("unknown variable `%.*s`", name.len, name.str) ) ;
 
 }
 ;
 
Var var= Fn_find_var(& /* ? */* p ->cur_fn , name ) ;
 
 Parser_check( p , PIPE ) ;
 
 Parser_gen( p , _STR("(%.*s){", var .typ.len, var .typ.str) ) ;
 
array_string fields=new_array_from_c_array(0, 0, sizeof(string), (string[]) {   }) ;
 
 while ( p ->tok != RCBR ) {
 
string field= Parser_check_name( p ) ;
 
_PUSH(& fields , ( field ), tmp203, string) ;
 
 Parser_gen( p , _STR(".%.*s = ", field.len, field.str) ) ;
 
 Parser_check( p , COLON ) ;
 
 Parser_bool_expression( p ) ;
 
 Parser_gen( p , tos2(",") ) ;
 
 if ( p ->tok != RCBR ) {
 /*if*/
 
 Parser_check( p , COMMA ) ;
 
 }
 ;
 
 }
 ;
 
Type* T= Table_find_type(& /* ? */* p ->table , var .typ ) ;
 
 array_Var tmp205 =  T ->fields;
 ;
for (int tmp206 = 0; tmp206 < tmp205 .len; tmp206 ++) {
 Var ffield = ((Var *) tmp205.data)[tmp206];
 
string f= ffield .name ;
 
 if (_IN(string,  f ,  fields ) ) {
 /*if*/
 
 continue
 ;
 
 }
 ;
 
 Parser_gen( p , _STR(".%.*s = %.*s . %.*s,", f.len, f.str, name.len, name.str, f.len, f.str) ) ;
 
 }
 ;
 
 Parser_check( p , RCBR ) ;
 
 Parser_gen( p , tos2("}") ) ;

 
 return  var .typ ;
 
 
 }
 void Parser_char_expr(Parser* p) {
 
 Parser_gen( p , _STR("\'%.*s\'", p ->lit.len, p ->lit.str) ) ;
 
 Parser_next( p ) ;
 
 
 }
 string format_str(string str) {
 
 str  =  string_replace( str , tos2("\"") , tos2("\\\"") ) ;
 
 str  =  string_replace( str , tos2("\n") , tos2("\\n") ) ;

 
 return  str ;
 
 
 }
 string Parser_typ_to_fmt(Parser* p, string typ) {
 
Type* t= Table_find_type(& /* ? */* p ->table , typ ) ;
 
 if (string_eq( t ->parent , tos2("int") ) ) {
 /*if*/

 
 return  tos2("%d") ;
 
 }
 ;
 
 if ( string_eq( typ,  tos2("string") )) { /* case */

 
 return  tos2("%.*s") ;
 
 }
 else  if ( string_eq( typ,  tos2("ustring") )) { /* case */

 
 return  tos2("%.*s") ;
 
 }
 else  if ( string_eq( typ,  tos2("byte") )) { /* case */

 
 return  tos2("%d") ;
 
 }
 else  if ( string_eq( typ,  tos2("int") )) { /* case */

 
 return  tos2("%d") ;
 
 }
 else  if ( string_eq( typ,  tos2("char") )) { /* case */

 
 return  tos2("%d") ;
 
 }
 else  if ( string_eq( typ,  tos2("byte") )) { /* case */

 
 return  tos2("%d") ;
 
 }
 else  if ( string_eq( typ,  tos2("bool") )) { /* case */

 
 return  tos2("%d") ;
 
 }
 else  if ( string_eq( typ,  tos2("u32") )) { /* case */

 
 return  tos2("%d") ;
 
 }
 else  if ( string_eq( typ,  tos2("f64") ) ||   string_eq( typ,  tos2("f32") )) { /* case */

 
 return  tos2("%f") ;
 
 }
 else  if ( string_eq( typ,  tos2("i64") )) { /* case */

 
 return  tos2("%lld") ;
 
 }
 else  if ( string_eq( typ,  tos2("byte*") ) ||   string_eq( typ,  tos2("byteptr") )) { /* case */

 
 return  tos2("%s") ;
 
 }
 else  if ( string_eq( typ,  tos2("void") )) { /* case */
 
 Parser_error( p , tos2("cannot interpolate this value") ) ;
 
 }
 else  { // default:
 
 if ( string_ends_with( typ , tos2("*") ) ) {
 /*if*/

 
 return  tos2("%p") ;
 
 }
 ;
 
 Parser_error( p , _STR("unhandled sprintf format \"%.*s\" ", typ.len, typ.str) ) ;
 
 }
 ;

 
 return  tos2("") ;
 
 
 }
 void Parser_string_expr(Parser* p) {
 
string str= p ->lit ;
 
 Parser_fgen( p , _STR("\'%.*s\'", str.len, str.str) ) ;
 
 if ( Parser_peek( p ) != DOLLAR ) {
 /*if*/
 
string f= format_str ( str ) ;
 
 if ( p ->calling_c  ||  p ->translated ) {
 /*if*/
 
 Parser_gen( p , _STR("\"%.*s\"", f.len, f.str) ) ;
 
 }
  else { 
 /*else if*/
 
 Parser_gen( p , _STR("tos2(\"%.*s\")", f.len, f.str) ) ;
 
 }
 ;
 
 Parser_next( p ) ;

 
 return  ;
 
 }
 ;
 
string args= tos2("\"") ;
 
string format= tos2("\"") ;
 
 while ( p ->tok == STRING ) {
 
 format  = string_add( format , format_str ( p ->lit ) ) ;
 
 Parser_next( p ) ;
 
 if ( p ->tok != DOLLAR ) {
 /*if*/
 
 continue
 ;
 
 }
 ;
 
 Parser_next( p ) ;
 
 CGen_start_tmp( p ->cgen ) ;
 
string typ= Parser_bool_expression( p ) ;
 
string val= CGen_end_tmp( p ->cgen ) ;
 
 val  =  string_trim_space( val ) ;
 
 args  = string_add( args , _STR(", %.*s", val.len, val.str) ) ;
 
 if (string_eq( typ , tos2("string") ) ) {
 /*if*/
 
 args  = string_add( args , _STR(".len, %.*s.str", val.len, val.str) ) ;
 
 }
 ;
 
 if (string_eq( typ , tos2("ustring") ) ) {
 /*if*/
 
 args  = string_add( args , _STR(".len, %.*s.s.str", val.len, val.str) ) ;
 
 }
 ;
 
bool custom= p ->tok == COLON ;
 
 if ( custom ) {
 /*if*/
 
 format  = string_add( format , tos2("%") ) ;
 
 Parser_next( p ) ;
 
 if ( p ->tok == DOT ) {
 /*if*/
 
 format  = string_add( format , tos2(".") ) ;
 
 Parser_next( p ) ;
 
 }
 ;
 
 format  = string_add( format , p ->lit ) ;
 
 Parser_next( p ) ;
 
 format  = string_add( format , p ->lit ) ;
 
 Parser_next( p ) ;
 
 }
  else { 
 /*else if*/
 
 format  = string_add( format , Parser_typ_to_fmt( p , typ ) ) ;
 
 }
 ;
 
 }
 ;
 
 if ( p ->cgen ->nogen ) {
 /*if*/

 
 return  ;
 
 }
 ;
 
string cur_line= string_trim_space( p ->cgen ->cur_line ) ;
 
 if ( string_contains( cur_line , tos2("println(") )  &&  p ->tok != PLUS  &&  ! p ->is_prod  &&  ! string_contains( cur_line , tos2("string_add") ) ) {
 /*if*/
 
 p ->cgen ->cur_line  =  string_replace( cur_line , tos2("println(") , tos2("printf(") ) ;
 
 Parser_gen( p , _STR("%.*s\\n%.*s", format.len, format.str, args.len, args.str) ) ;

 
 return  ;
 
 }
 ;
 
 if ( p ->tok == NOT ) {
 /*if*/
 
 Parser_next( p ) ;
 
 Parser_gen( p , _STR("_STR_TMP(%.*s%.*s)", format.len, format.str, args.len, args.str) ) ;
 
 }
  else { 
 /*else if*/
 
 Parser_gen( p , _STR("_STR(%.*s%.*s)", format.len, format.str, args.len, args.str) ) ;
 
 }
 ;
 
 
 }
 string Parser_map_init(Parser* p) {
 
 Parser_next( p ) ;
 
 Parser_check( p , LSBR ) ;
 
string key_type= Parser_check_name( p ) ;
 
 if (string_ne( key_type , tos2("string") ) ) {
 /*if*/
 
 Parser_error( p , tos2("only string key maps allowed for now") ) ;
 
 }
 ;
 
 Parser_check( p , RSBR ) ;
 
string val_type= Parser_check_name( p ) ;
 
 if ( ! Table_known_type(& /* ? */* p ->table , val_type ) ) {
 /*if*/
 
 Parser_error( p , _STR("map init unknown type \"%.*s\"", val_type.len, val_type.str) ) ;
 
 }
 ;
 
 Parser_gen( p , _STR("new_map(1, sizeof(%.*s))", val_type.len, val_type.str) ) ;
 
 Parser_check( p , LCBR ) ;
 
 Parser_check( p , RCBR ) ;

 
 return  _STR("map_%.*s", val_type.len, val_type.str) ;
 
 
 }
 string Parser_array_init(Parser* p) {
 
 Parser_check( p , LSBR ) ;
 
bool is_integer= p ->tok == INT ;
 
string lit= p ->lit ;
 
string typ= tos2("") ;
 
int new_arr_ph= CGen_add_placeholder( p ->cgen ) ;
 
int i= 0 ;
 
int pos= p ->cgen ->cur_line .len ;
 
 while ( p ->tok != RSBR ) {
 
string val_typ= Parser_bool_expression( p ) ;
 
 if ( i == 0 ) {
 /*if*/
 
 typ  =  val_typ ;
 
 if ( is_integer  &&  p ->tok == RSBR  &&  Parser_peek( p ) == NAME ) {
 /*if*/
 
byte nextc= string_at( p ->scanner ->text , p ->scanner ->pos + 1) ;
 
 if ( ! byte_is_space( nextc ) ) {
 /*if*/
 
 Parser_check( p , RSBR ) ;
 
string name= Parser_check_name( p ) ;
 
 if ( Table_known_type(& /* ? */* p ->table , name ) ) {
 /*if*/
 
 p ->cgen ->cur_line  =  tos2("") ;
 
 Parser_gen( p , tos2("{} /* arkek init*/") ) ;

 
 return  _STR("[%.*s]%.*s", lit.len, lit.str, name.len, name.str) ;
 
 }
  else { 
 /*else if*/
 
 Parser_error( p , _STR("bad type `%.*s`", name.len, name.str) ) ;
 
 }
 ;
 
 }
 ;
 
 }
 ;
 
 }
 ;
 
 if (string_ne( val_typ , typ ) ) {
 /*if*/
 
 if ( ! Parser_check_types_no_throw( p , val_typ , typ ) ) {
 /*if*/
 
 Parser_error( p , _STR("bad array element type `%.*s` instead of `%.*s`", val_typ.len, val_typ.str, typ.len, typ.str) ) ;
 
 }
 ;
 
 }
 ;
 
 if ( p ->tok != RSBR  &&  p ->tok != SEMICOLON ) {
 /*if*/
 
 Parser_gen( p , tos2(",") ) ;
 
 Parser_check( p , COMMA ) ;
 
 }
 ;
 
 i ++ ;
 
 if ( i == 1  &&  p ->tok == SEMICOLON ) {
 /*if*/
 
 Parser_check_space( p , SEMICOLON ) ;
 
string val= string_right( p ->cgen ->cur_line , pos ) ;
 
 p ->cgen ->cur_line  =  string_left( p ->cgen ->cur_line , pos ) ;
 
 if ( 0  && string_eq( string_trim_space( val ) , tos2("0") ) ) {
 /*if*/
 
 Parser_gen( p , tos2("array_repeat( & V_ZERO, ") ) ;
 
 }
  else { 
 /*else if*/
 
string tmp= Parser_get_tmp( p ) ;
 
 CGen_insert_before( p ->cgen , _STR("%.*s %.*s = %.*s;", typ.len, typ.str, tmp.len, tmp.str, val.len, val.str) ) ;
 
 Parser_gen( p , _STR("array_repeat(&%.*s, ", tmp.len, tmp.str) ) ;
 
 }
 ;
 
 Parser_check_types( p , Parser_bool_expression( p ) , tos2("int") ) ;
 
 Parser_gen( p , _STR(", sizeof(%.*s) )", typ.len, typ.str) ) ;
 
 Parser_check( p , RSBR ) ;

 
 return  _STR("array_%.*s", typ.len, typ.str) ;
 
 }
 ;
 
 }
 ;
 
 Parser_check( p , RSBR ) ;
 
 if ( p ->tok != NAME  &&  i == 0 ) {
 /*if*/
 
 Parser_error( p , tos2("specify array type: `[]typ` instead of `[]`") ) ;
 
 }
 ;
 
 if ( p ->tok == NAME  &&  i == 0 ) {
 /*if*/
 
 typ  =  Parser_get_type( p ) ;
 
 }
 ;
 
bool no_alloc= p ->tok == NOT ;
 
 if ( no_alloc ) {
 /*if*/
 
 Parser_next( p ) ;
 
 }
 ;
 
bool is_fixed_size= p ->tok == NOT ;
 
 if ( is_fixed_size ) {
 /*if*/
 
 Parser_next( p ) ;
 
 Parser_gen( p , tos2(" }") ) ;
 
 if ( ! Parser_first_run(& /* ? */* p ) ) {
 /*if*/
 
 if ( p ->inside_const ) {
 /*if*/
 
 CGen_set_placeholder( p ->cgen , new_arr_ph , tos2("{ ") ) ;
 
 }
  else { 
 /*else if*/
 
 CGen_set_placeholder( p ->cgen , new_arr_ph , _STR("(%.*s[]) { ", typ.len, typ.str) ) ;
 
 }
 ;
 
 }
 ;

 
 return  _STR("[%d]%.*s", i, typ.len, typ.str) ;
 
 }
 ;
 
string new_arr= tos2("new_array_from_c_array") ;
 
 if ( no_alloc ) {
 /*if*/
 
 new_arr  = string_add( new_arr , tos2("_no_alloc") ) ;
 
 }
 ;
 
 Parser_gen( p , tos2(" })") ) ;
 
 if ( ! Parser_first_run(& /* ? */* p ) ) {
 /*if*/
 
 CGen_set_placeholder( p ->cgen , new_arr_ph , _STR("%.*s(%d, %d, sizeof(%.*s), (%.*s[]) { ", new_arr.len, new_arr.str, i, i, typ.len, typ.str, typ.len, typ.str) ) ;
 
 }
 ;
 
 typ  =  _STR("array_%.*s", typ.len, typ.str) ;
 
 Parser_register_array( p , typ ) ;

 
 return  typ ;
 
 
 }
 void Parser_register_array(Parser* p, string typ) {
 
 if ( string_contains( typ , tos2("*") ) ) {
 /*if*/
 
 println ( _STR("bad arr %.*s", typ.len, typ.str) ) ;

 
 return  ;
 
 }
 ;
 
 if ( ! Table_known_type(& /* ? */* p ->table , typ ) ) {
 /*if*/
 
 Parser_register_type_with_parent( p , typ , tos2("array") ) ;
 
_PUSH(& p ->cgen ->typedefs , ( _STR("typedef array %.*s;", typ.len, typ.str) ), tmp235, string) ;
 
 }
 ;
 
 
 }
 string Parser_struct_init(Parser* p, bool is_c_struct_init) {
 
 p ->is_struct_init  =  1 ;
 
string typ= Parser_get_type( p ) ;
 
 StringBuilder_cut( p ->scanner ->fmt_out , typ .len ) ;
 
bool ptr= string_contains( typ , tos2("*") ) ;
 
 if (string_eq( typ , tos2("tm") ) ) {
 /*if*/
string tmp238 =  tos2("");
 
array_set(&/*q*/ p ->cgen ->lines , p ->cgen ->lines .len - 1 , & tmp238) ;
string tmp239 =  tos2("");
 
array_set(&/*q*/ p ->cgen ->lines , p ->cgen ->lines .len - 2 , & tmp239) ;
 
 }
 ;
 
 Parser_check( p , LCBR ) ;
 
 if ( ! ptr ) {
 /*if*/
 
 if ( p ->is_c_struct_init ) {
 /*if*/
 
 Parser_gen( p , _STR("(struct %.*s) {", typ.len, typ.str) ) ;
 
 p ->is_c_struct_init  =  0 ;
 
 }
  else { 
 /*else if*/
 
 Parser_gen( p , _STR("(%.*s) {", typ.len, typ.str) ) ;
 
 }
 ;
 
 }
  else { 
 /*else if*/
 
 if ( p ->tok == NOT ) {
 /*if*/
 
 Parser_next( p ) ;
 
 Parser_gen( p , tos2("0") ) ;
 
 Parser_check( p , RCBR ) ;

 
 return  typ ;
 
 }
 ;
 
string no_star= string_replace( typ , tos2("*") , tos2("") ) ;
 
 Parser_gen( p , _STR("ALLOC_INIT(%.*s, {", no_star.len, no_star.str) ) ;
 
 }
 ;
 
array_string inited_fields=new_array_from_c_array(0, 0, sizeof(string), (string[]) {   }) ;
 
Token peek= Parser_peek( p ) ;
 
 if ( peek == COLON  ||  p ->tok == RCBR ) {
 /*if*/
 
Type* t= Table_find_type(& /* ? */* p ->table , typ ) ;
 
 while ( p ->tok != RCBR ) {
 
string field= Parser_check_name( p ) ;
 
 if ( ! Type_has_field(& /* ? */* t , field ) ) {
 /*if*/
 
 Parser_error( p , _STR("`%.*s` has no field `%.*s`", t ->name.len, t ->name.str, field.len, field.str) ) ;
 
 }
 ;
 
_PUSH(& inited_fields , ( field ), tmp245, string) ;
 
 Parser_gen( p , _STR(".%.*s = ", field.len, field.str) ) ;
 
 Parser_check( p , COLON ) ;
 
 Parser_fspace( p ) ;
 
 Parser_expression( p ) ;
 
 if ( p ->tok == COMMA ) {
 /*if*/
 
 Parser_next( p ) ;
 
 }
 ;
 
 if ( p ->tok != RCBR ) {
 /*if*/
 
 Parser_gen( p , tos2(",") ) ;
 
 }
 ;
 
 Parser_fgenln( p , tos2("") ) ;
 
 }
 ;
 
 if ( t ->fields .len != inited_fields .len  &&  inited_fields .len > 0 ) {
 /*if*/
 
 Parser_gen( p , tos2(",") ) ;
 
 }
 ;
 
 array_Var tmp246 =  t ->fields ;
 ;
for (int i = 0; i < tmp246 .len; i ++) {
 Var field = ((Var *) tmp246 . data)[i];
 
 if ( array_string_contains( inited_fields , field .name ) ) {
 /*if*/
 
 continue
 ;
 
 }
 ;
 
string field_typ= field .typ ;
 
 if ( ! p ->builtin_pkg  &&  string_ends_with( field_typ , tos2("*") )  &&  string_contains( field_typ , tos2("Cfg") ) ) {
 /*if*/
 
 Parser_error( p , _STR("pointer field `%.*s.%.*s` must be initialized", typ.len, typ.str, field .name.len, field .name.str) ) ;
 
 }
 ;
 
string def_val= type_default ( field_typ ) ;
 
 if (string_ne( def_val , tos2("") ) ) {
 /*if*/
 
 Parser_gen( p , _STR(".%.*s = %.*s", field .name.len, field .name.str, def_val.len, def_val.str) ) ;
 
 if ( i != t ->fields .len - 1 ) {
 /*if*/
 
 Parser_gen( p , tos2(",") ) ;
 
 }
 ;
 
 }
 ;
 
 }
 ;
 
 }
  else { 
 /*else if*/
 
Type* T= Table_find_type(& /* ? */* p ->table , typ ) ;
 
 if ( T ->fields .len == 0  && string_ne( T ->parent , tos2("") ) ) {
 /*if*/
 
 T  =  Table_find_type(& /* ? */* p ->table , T ->parent ) ;
 
 }
 ;
 
 array_Var tmp250 =  T ->fields ;
 ;
for (int i = 0; i < tmp250 .len; i ++) {
 Var ffield = ((Var *) tmp250 . data)[i];
 
string expr_typ= Parser_bool_expression( p ) ;
 
 if ( ! Parser_check_types_no_throw( p , expr_typ , ffield .typ ) ) {
 /*if*/
 
 Parser_error( p , _STR("field value #%d `%.*s` has type `%.*s`, got `%.*s` ", i + 1, ffield .name.len, ffield .name.str, ffield .typ.len, ffield .typ.str, expr_typ.len, expr_typ.str) ) ;
 
 }
 ;
 
 if ( i < T ->fields .len - 1 ) {
 /*if*/
 
 if ( p ->tok != COMMA ) {
 /*if*/
 
 Parser_error( p , _STR("too few values in `%.*s` literal (%d instead of %d)", typ.len, typ.str, i + 1, T ->fields .len) ) ;
 
 }
 ;
 
 Parser_gen( p , tos2(",") ) ;
 
 Parser_next( p ) ;
 
 }
 ;
 
 }
 ;
 
 if ( p ->tok == COMMA ) {
 /*if*/
 
 Parser_next( p ) ;
 
 }
 ;
 
 if ( p ->tok != RCBR ) {
 /*if*/
 
 Parser_error( p , _STR("too many fields initialized: `%.*s` has %d field(s)", typ.len, typ.str, T ->fields .len) ) ;
 
 }
 ;
 
 }
 ;
 
 Parser_gen( p , tos2("}") ) ;
 
 if ( ptr ) {
 /*if*/
 
 Parser_gen( p , tos2(")") ) ;
 
 }
 ;
 
 Parser_check( p , RCBR ) ;
 
 p ->is_struct_init  =  0 ;

 
 return  typ ;
 
 
 }
 string Parser_cast(Parser* p, string typ) {
 
 Parser_next( p ) ;
 
int pos= CGen_add_placeholder( p ->cgen ) ;
 
 if ( p ->tok == RPAR ) {
 /*if*/
 
 p ->ptr_cast  =  1 ;
 
 Parser_next( p ) ;
 
 }
 ;
 
 Parser_check( p , LPAR ) ;
 
string expr_typ= Parser_bool_expression( p ) ;
 
 Parser_check( p , RPAR ) ;
 
 if (string_eq( typ , tos2("string") )  &&  (/*lpar*/string_eq( expr_typ , tos2("byte*") )  || string_eq( expr_typ , tos2("byteptr") ) ) ) {
 /*if*/
 
 CGen_set_placeholder( p ->cgen , pos , tos2("tos2(") ) ;
 
 }
  else  if (string_eq( typ , tos2("string") )  && string_eq( expr_typ , tos2("int") ) ) {
 /*if*/
 
 Parser_error( p , _STR("cannot cast `%.*s` to `%.*s`, use `str()` method instead", expr_typ.len, expr_typ.str, typ.len, typ.str) ) ;
 
 }
  else { 
 /*else if*/
 
 CGen_set_placeholder( p ->cgen , pos , _STR("(%.*s)(", typ.len, typ.str) ) ;
 
 }
 ;
 
 Parser_gen( p , tos2(")") ) ;

 
 return  typ ;
 
 
 }
 string Parser_get_tmp(Parser* p) {
 
 p ->tmp_cnt ++ ;

 
 return  _STR("tmp%d", p ->tmp_cnt) ;
 
 
 }
 int Parser_get_tmp_counter(Parser* p) {
 
 p ->tmp_cnt ++ ;

 
 return  p ->tmp_cnt ;
 
 
 }
 string os_name_to_ifdef(string name) {
 
 if ( string_eq( name,  tos2("windows") )) { /* case */

 
 return  tos2("_WIN32") ;
 
 }
 else  if ( string_eq( name,  tos2("mac") )) { /* case */

 
 return  tos2("__APPLE__") ;
 
 }
 else  if ( string_eq( name,  tos2("linux") )) { /* case */

 
 return  tos2("__linux__") ;
 
 }
 ;
 
 v_panic ( _STR("bad os ifdef name \"%.*s\"", name.len, name.str) ) ;

 
 return  tos2("") ;
 
 
 }
 void Parser_comp_time(Parser* p) {
 
 Parser_next( p ) ;
 
 if ( p ->tok == IF ) {
 /*if*/
 
 Parser_next( p ) ;
 
bool not= p ->tok == NOT ;
 
 if ( not ) {
 /*if*/
 
 Parser_next( p ) ;
 
 }
 ;
 
string name= Parser_check_name( p ) ;
 
 if (_IN(string,  name ,  main__SupportedPlatforms ) ) {
 /*if*/
 
string ifdef_name= os_name_to_ifdef ( name ) ;
 
 if ( not ) {
 /*if*/
 
 Parser_genln( p , _STR("#ifndef %.*s", ifdef_name.len, ifdef_name.str) ) ;
 
 }
  else { 
 /*else if*/
 
 Parser_genln( p , _STR("#ifdef %.*s", ifdef_name.len, ifdef_name.str) ) ;
 
 }
 ;
 
 Parser_check( p , LCBR ) ;
 
 Parser_statements_no_curly_end( p ) ;
 
 if ( ! (/*lpar*/ p ->tok == DOLLAR  &&  Parser_peek( p ) == ELSE ) ) {
 /*if*/
 
 Parser_genln( p , tos2("#endif") ) ;
 
 }
 ;
 
 }
  else { 
 /*else if*/
 
 println ( tos2("Supported platforms:") ) ;
 
 println (array_string_str( main__SupportedPlatforms ) ) ;
 
 Parser_error( p , _STR("unknown platform `%.*s`", name.len, name.str) ) ;
 
 }
 ;
 
 }
  else  if ( p ->tok == FOR ) {
 /*if*/
 
 Parser_next( p ) ;
 
string name= Parser_check_name( p ) ;
 
 if (string_ne( name , tos2("field") ) ) {
 /*if*/
 
 Parser_error( p , tos2("for field only") ) ;
 
 }
 ;
 
 Parser_check( p , IN ) ;
 
 Parser_check_name( p ) ;
 
 Parser_check( p , DOT ) ;
 
 Parser_check_name( p ) ;
 
 Parser_check( p , LCBR ) ;
 
string res_name= Parser_check_name( p ) ;
 
 println ( res_name ) ;
 
 Parser_check( p , DOT ) ;
 
 Parser_check( p , DOLLAR ) ;
 
 Parser_check( p , NAME ) ;
 
 Parser_check( p , ASSIGN ) ;
 
 CGen_start_tmp( p ->cgen ) ;
 
 Parser_bool_expression( p ) ;
 
string val= CGen_end_tmp( p ->cgen ) ;
 
 println ( val ) ;
 
 Parser_check( p , RCBR ) ;
 
 }
  else  if ( p ->tok == ELSE ) {
 /*if*/
 
 Parser_next( p ) ;
 
 Parser_check( p , LCBR ) ;
 
 Parser_genln( p , tos2("#else") ) ;
 
 Parser_statements_no_curly_end( p ) ;
 
 Parser_genln( p , tos2("#endif") ) ;
 
 }
  else { 
 /*else if*/
 
 Parser_error( p , tos2("bad comptime expr") ) ;
 
 }
 ;
 
 
 }
 void Parser_chash(Parser* p) {
 
string hash= string_trim_space( p ->lit ) ;
 
 Parser_next( p ) ;
 
bool is_sig= Parser_is_sig( p ) ;
 
 if ( is_sig ) {
 /*if*/
 
 }
 ;
 
 if (string_eq( hash , tos2("live") ) ) {
 /*if*/
 
 if ( p ->is_so ) {
 /*if*/

 
 return  ;
 
 }
 ;
 
 p ->is_live  =  1 ;

 
 return  ;
 
 }
 ;
 
 if ( string_starts_with( hash , tos2("flag ") ) ) {
 /*if*/
 
string flag= string_right( hash , 5 ) ;
 
 if ( string_contains( hash , tos2("linux") )  &&  p ->os != LINUX ) {
 /*if*/

 
 return  ;
 
 }
  else  if ( string_contains( hash , tos2("darwin") )  &&  p ->os != MAC ) {
 /*if*/

 
 return  ;
 
 }
  else  if ( string_contains( hash , tos2("windows") )  &&  p ->os != WINDOWS ) {
 /*if*/

 
 return  ;
 
 }
 ;
 
 if ( string_contains( flag , tos2("linux") )  ||  string_contains( flag , tos2("darwin") )  ||  string_contains( flag , tos2("windows") ) ) {
 /*if*/
 
int pos= string_index( flag , tos2(" ") ) ;
 
 flag  =  string_right( flag , pos ) ;
 
 }
 ;
 
 flag  =  string_replace( string_trim_space( flag ) , tos2("@VROOT") , p ->vroot ) ;
 
 if ( array_string_contains( p ->table ->flags , flag ) ) {
 /*if*/

 
 return  ;
 
 }
 ;
 
 Parser_log(& /* ? */* p , _STR("adding flag \"%.*s\"", flag.len, flag.str) ) ;
 
_PUSH(& p ->table ->flags , ( flag ), tmp264, string) ;

 
 return  ;
 
 }
 ;
 
 if ( string_starts_with( hash , tos2("include") ) ) {
 /*if*/
 
 if ( Parser_first_run(& /* ? */* p )  &&  ! is_sig ) {
 /*if*/
 
_PUSH(& p ->cgen ->includes , ( _STR("#%.*s", hash.len, hash.str) ), tmp265, string) ;

 
 return  ;
 
 }
 ;
 
 }
  else  if ( string_starts_with( hash , tos2("typedef") ) ) {
 /*if*/
 
 if ( Parser_first_run(& /* ? */* p ) ) {
 /*if*/
 
_PUSH(& p ->cgen ->typedefs , ( _STR("%.*s", hash.len, hash.str) ), tmp266, string) ;
 
 }
 ;
 
 }
  else  if ( string_contains( hash , tos2("embed") ) ) {
 /*if*/
 
int pos= string_index( hash , tos2("embed") ) + 5 ;
 
string file= string_right( hash , pos ) ;
 
 if ( p ->build_mode != DEFAULT_MODE ) {
 /*if*/
 
 Parser_genln( p , _STR("#include %.*s", file.len, file.str) ) ;
 
 }
 ;
 
 }
  else  if ( string_contains( hash , tos2("define") ) ) {
 /*if*/
 
_PUSH(& p ->cgen ->includes , ( _STR("#%.*s", hash.len, hash.str) ), tmp269, string) ;
 
 }
  else { 
 /*else if*/
 
 if ( ! p ->can_chash ) {
 /*if*/
 
 Parser_error( p , tos2("bad token `#` (embedding C code is no longer supported)") ) ;
 
 }
 ;
 
 Parser_genln( p , hash ) ;
 
 }
 ;
 
 
 }
 string Parser_if_st(Parser* p, bool is_expr) {
 
 if ( is_expr ) {
 /*if*/
 
 if ( Parser_fileis(& /* ? */* p , tos2("if_expr") ) ) {
 /*if*/
 
 println ( tos2("IF EXPR") ) ;
 
 }
 ;
 
 p ->inside_if_expr  =  1 ;
 
 Parser_gen( p , tos2("(") ) ;
 
 }
  else { 
 /*else if*/
 
 Parser_gen( p , tos2("if (") ) ;
 
 Parser_fgen( p , tos2("if ") ) ;
 
 }
 ;
 
 Parser_next( p ) ;
 
 Parser_check_types( p , Parser_bool_expression( p ) , tos2("bool") ) ;
 
 if ( is_expr ) {
 /*if*/
 
 Parser_gen( p , tos2(") ? (") ) ;
 
 }
  else { 
 /*else if*/
 
 Parser_genln( p , tos2(") {") ) ;
 
 Parser_fgenln( p , tos2("{") ) ;
 
 Parser_genln( p , tos2("/*if*/") ) ;
 
 }
 ;
 
 Parser_fgen( p , tos2(" ") ) ;
 
 Parser_check( p , LCBR ) ;
 
string typ= tos2("") ;
 
 if ( p ->tok == IF  &&  p ->inside_if_expr ) {
 /*if*/
 
 println ( tos2("AAAWWFAFAF") ) ;
 
 typ  =  Parser_factor( p ) ;
 
 println ( _STR("QWEWQE typ=%.*s", typ.len, typ.str) ) ;
 
 Parser_next( p ) ;
 
 }
  else { 
 /*else if*/
 
 typ  =  Parser_statements( p ) ;
 
 }
 ;
 
 if ( p ->tok == ELSE ) {
 /*if*/
 
 Parser_next( p ) ;
 
 if ( p ->tok == IF ) {
 /*if*/
 
 Parser_gen( p , tos2(" else ") ) ;

 
 return  Parser_if_st( p , is_expr ) ;
 
 }
 ;
 
 if ( is_expr ) {
 /*if*/
 
 Parser_gen( p , tos2(") : (") ) ;
 
 }
  else { 
 /*else if*/
 
 Parser_genln( p , tos2(" else { ") ) ;
 
 Parser_genln( p , tos2("/*else if*/") ) ;
 
 }
 ;
 
 Parser_check( p , LCBR ) ;
 
 typ  =  Parser_statements( p ) ;
 
 p ->inside_if_expr  =  0 ;
 
 if ( is_expr ) {
 /*if*/
 
 Parser_gen( p , tos2(")") ) ;
 
 }
 ;

 
 return  typ ;
 
 }
 ;
 
 p ->inside_if_expr  =  0 ;
 
 if ( Parser_fileis(& /* ? */* p , tos2("test_test") ) ) {
 /*if*/
 
 println ( _STR("if ret typ=\"%.*s\" line=%d", typ.len, typ.str, p ->scanner ->line_nr) ) ;
 
 }
 ;

 
 return  typ ;
 
 
 }
 void Parser_for_st(Parser* p) {
 
 Parser_check( p , FOR ) ;
 
 Parser_fgen( p , tos2(" ") ) ;
 
 p ->for_expr_cnt ++ ;
 
Token next_tok= Parser_peek( p ) ;
 
bool debug= string_contains( p ->scanner ->file_path , tos2("r_draw") ) ;
 
 if ( debug ) {
 /*if*/
 
 println ( tos2("\n\nFOR {") ) ;
 
 }
 ;
 
 Fn_open_scope( p ->cur_fn ) ;
 
 if ( p ->tok == LCBR ) {
 /*if*/
 
 Parser_gen( p , tos2("while (1) {") ) ;
 
 }
  else  if ( p ->tok == MUT ) {
 /*if*/
 
 Parser_error( p , tos2("`mut` is not required in for loops") ) ;
 
 }
  else  if ( next_tok == DECL_ASSIGN  ||  next_tok == ASSIGN  ||  p ->tok == SEMICOLON ) {
 /*if*/
 
 if ( debug ) {
 /*if*/
 
 println ( tos2("for 1") ) ;
 
 }
 ;
 
 Parser_genln( p , tos2("for (") ) ;
 
 if ( next_tok == DECL_ASSIGN ) {
 /*if*/
 
 Parser_var_decl( p ) ;
 
 }
  else  if ( p ->tok != SEMICOLON ) {
 /*if*/
 
 Parser_statement( p , 0 ) ;
 
 }
 ;
 
 if ( debug ) {
 /*if*/
 
 println ( tos2("for 2") ) ;
 
 }
 ;
 
 Parser_check( p , SEMICOLON ) ;
 
 Parser_gen( p , tos2(" ; ") ) ;
 
 Parser_fgen( p , tos2(" ") ) ;
 
 if ( p ->tok != SEMICOLON ) {
 /*if*/
 
 Parser_bool_expression( p ) ;
 
 }
 ;
 
 if ( debug ) {
 /*if*/
 
 println ( tos2("for 3") ) ;
 
 }
 ;
 
 Parser_check( p , SEMICOLON ) ;
 
 Parser_gen( p , tos2(" ; ") ) ;
 
 Parser_fgen( p , tos2(" ") ) ;
 
 if ( p ->tok != LCBR ) {
 /*if*/
 
 Parser_statement( p , 0 ) ;
 
 }
 ;
 
 if ( debug ) {
 /*if*/
 
 println ( tos2("for 4") ) ;
 
 }
 ;
 
 Parser_fgen( p , tos2(" ") ) ;
 
 Parser_genln( p , tos2(") { ") ) ;
 
 }
  else  if ( Parser_peek( p ) == COMMA ) {
 /*if*/
 
string i= Parser_check_name( p ) ;
 
 Parser_check( p , COMMA ) ;
 
string val= Parser_check_name( p ) ;
 
 Parser_fgen( p , tos2(" ") ) ;
 
 Parser_check( p , IN ) ;
 
 Parser_fgen( p , tos2(" ") ) ;
 
string tmp= Parser_get_tmp( p ) ;
 
 CGen_start_tmp( p ->cgen ) ;
 
string typ= Parser_bool_expression( p ) ;
 
string expr= CGen_end_tmp( p ->cgen ) ;
 
 Parser_genln( p , _STR("%.*s %.*s = %.*s ;", typ.len, typ.str, tmp.len, tmp.str, expr.len, expr.str) ) ;
 
string var_typ= string_right( typ , 6 ) ;
 
Var val_var= (Var) { .name =  val , .typ =  var_typ , .ptr =  string_contains( typ , tos2("*") ) , .is_arg = 0 , .is_const = 0 , .is_import_const = 0 , .args = new_array(0, 1, sizeof(Var)) , .attr = tos("", 0) , .is_mut = 0 , .ref = 0 , .parent_fn = tos("", 0) , .pkg = tos("", 0) , .line_nr = 0 , .is_global = 0 , .is_used = 0 , .scope_level = 0 } ;
 
 Parser_register_var( p , val_var ) ;
 
Var i_var= (Var) { .name =  i , .typ =  tos2("int") , .is_mut =  1 , .is_arg = 0 , .is_const = 0 , .is_import_const = 0 , .args = new_array(0, 1, sizeof(Var)) , .attr = tos("", 0) , .ptr = 0 , .ref = 0 , .parent_fn = tos("", 0) , .pkg = tos("", 0) , .line_nr = 0 , .is_global = 0 , .is_used = 0 , .scope_level = 0 } ;
 
 Parser_register_var( p , i_var ) ;
 
 Parser_genln( p , _STR(";\nfor (int %.*s = 0; %.*s < %.*s .len; %.*s ++) {", i.len, i.str, i.len, i.str, tmp.len, tmp.str, i.len, i.str) ) ;
 
 Parser_genln( p , _STR("%.*s %.*s = ((%.*s *) %.*s . data)[%.*s];", var_typ.len, var_typ.str, val.len, val.str, var_typ.len, var_typ.str, tmp.len, tmp.str, i.len, i.str) ) ;
 
 }
  else  if ( Parser_peek( p ) == IN ) {
 /*if*/
 
string val= Parser_check_name( p ) ;
 
 Parser_fgen( p , tos2(" ") ) ;
 
 Parser_check( p , IN ) ;
 
 Parser_fspace( p ) ;
 
string tmp= Parser_get_tmp( p ) ;
 
 CGen_start_tmp( p ->cgen ) ;
 
string typ= Parser_bool_expression( p ) ;
 
string expr= CGen_end_tmp( p ->cgen ) ;
 
bool is_range= p ->tok == DOTDOT ;
 
string range_end= tos2("") ;
 
 if ( is_range ) {
 /*if*/
 
 Parser_check_types( p , typ , tos2("int") ) ;
 
 Parser_check_space( p , DOTDOT ) ;
 
 CGen_start_tmp( p ->cgen ) ;
 
 Parser_check_types( p , Parser_bool_expression( p ) , tos2("int") ) ;
 
 range_end  =  CGen_end_tmp( p ->cgen ) ;
 
 }
 ;
 
bool is_arr= string_contains( typ , tos2("array") ) ;
 
bool is_str=string_eq( typ , tos2("string") ) ;
 
 if ( ! is_arr  &&  ! is_str  &&  ! is_range ) {
 /*if*/
 
 Parser_error( p , _STR("`for in` requires an array or a string but got `%.*s`", typ.len, typ.str) ) ;
 
 }
 ;
 
 Parser_genln( p , _STR("%.*s %.*s = %.*s;", typ.len, typ.str, tmp.len, tmp.str, expr.len, expr.str) ) ;
 
string var_type= tos2("") ;
 
 if ( is_arr ) {
 /*if*/
 
 var_type  =  string_right( typ , 6 ) ;
 
 }
  else  if ( is_str ) {
 /*if*/
 
 var_type  =  tos2("byte") ;
 
 }
  else  if ( is_range ) {
 /*if*/
 
 var_type  =  tos2("int") ;
 
 }
 ;
 
Var val_var= (Var) { .name =  val , .typ =  var_type , .ptr =  string_contains( typ , tos2("*") ) , .is_arg = 0 , .is_const = 0 , .is_import_const = 0 , .args = new_array(0, 1, sizeof(Var)) , .attr = tos("", 0) , .is_mut = 0 , .ref = 0 , .parent_fn = tos("", 0) , .pkg = tos("", 0) , .line_nr = 0 , .is_global = 0 , .is_used = 0 , .scope_level = 0 } ;
 
 Parser_register_var( p , val_var ) ;
 
string i= Parser_get_tmp( p ) ;
 
 if ( is_range ) {
 /*if*/
 
 Parser_genln( p , _STR(";\nfor (int %.*s = %.*s; %.*s < %.*s; %.*s++) {", i.len, i.str, tmp.len, tmp.str, i.len, i.str, range_end.len, range_end.str, i.len, i.str) ) ;
 
 }
  else { 
 /*else if*/
 
 Parser_genln( p , _STR(";\nfor (int %.*s = 0; %.*s < %.*s .len; %.*s ++) {", i.len, i.str, i.len, i.str, tmp.len, tmp.str, i.len, i.str) ) ;
 
 }
 ;
 
 if ( is_arr ) {
 /*if*/
 
 Parser_genln( p , _STR("%.*s %.*s = ((%.*s *) %.*s.data)[%.*s];", var_type.len, var_type.str, val.len, val.str, var_type.len, var_type.str, tmp.len, tmp.str, i.len, i.str) ) ;
 
 }
  else  if ( is_str ) {
 /*if*/
 
 Parser_genln( p , _STR("%.*s %.*s = ((%.*s *) %.*s.str)[%.*s];", var_type.len, var_type.str, val.len, val.str, var_type.len, var_type.str, tmp.len, tmp.str, i.len, i.str) ) ;
 
 }
  else  if ( is_range ) {
 /*if*/
 
 Parser_genln( p , _STR("%.*s %.*s = %.*s;", var_type.len, var_type.str, val.len, val.str, i.len, i.str) ) ;
 
 }
 ;
 
 }
  else { 
 /*else if*/
 
 Parser_gen( p , tos2("while (") ) ;
 
 Parser_check_types( p , Parser_bool_expression( p ) , tos2("bool") ) ;
 
 Parser_genln( p , tos2(") {") ) ;
 
 }
 ;
 
 Parser_check( p , LCBR ) ;
 
 Parser_statements( p ) ;
 
 Fn_close_scope( p ->cur_fn ) ;
 
 p ->for_expr_cnt -- ;
 
 
 }
 void Parser_switch_statement(Parser* p) {
 
 Parser_next( p ) ;
 
 CGen_start_tmp( p ->cgen ) ;
 
string typ= Parser_bool_expression( p ) ;
 
string expr= CGen_end_tmp( p ->cgen ) ;
 
 Parser_check( p , LCBR ) ;
 
int i= 0 ;
 
 while ( p ->tok == CASE  ||  p ->tok == DEFAULT ) {
 
 if ( p ->tok == DEFAULT ) {
 /*if*/
 
 Parser_genln( p , tos2("else  { // default:") ) ;
 
 Parser_next( p ) ;
 
 Parser_check( p , COLON ) ;
 
 Parser_statements( p ) ;
 
 break
 ;
 
 }
 ;
 
 if ( i > 0 ) {
 /*if*/
 
 Parser_gen( p , tos2("else ") ) ;
 
 }
 ;
 
 Parser_gen( p , tos2("if (") ) ;
 
bool got_comma= 0 ;
 
 while (1) { 
 if ( got_comma ) {
 /*if*/
 
 Parser_gen( p , tos2(") ||  ") ) ;
 
 }
 ;
 
 if (string_eq( typ , tos2("string") ) ) {
 /*if*/
 
 Parser_gen( p , _STR("string_eq(%.*s, ", expr.len, expr.str) ) ;
 
 }
  else { 
 /*else if*/
 
 Parser_gen( p , _STR("(%.*s == ", expr.len, expr.str) ) ;
 
 }
 ;
 
 if ( p ->tok == CASE  ||  p ->tok == DEFAULT ) {
 /*if*/
 
 Parser_next( p ) ;
 
 }
 ;
 
 Parser_bool_expression( p ) ;
 
 if ( p ->tok != COMMA ) {
 /*if*/
 
 break
 ;
 
 }
 ;
 
 Parser_check( p , COMMA ) ;
 
 got_comma  =  1 ;
 
 }
 ;
 
 Parser_check( p , COLON ) ;
 
 Parser_gen( p , tos2(")) {") ) ;
 
 Parser_genln( p , tos2("/* case */") ) ;
 
 Parser_statements( p ) ;
 
 i ++ ;
 
 }
 ;
 
 
 }
 void Parser_assert_statement(Parser* p) {
 
 Parser_check( p , ASSERT ) ;
 
 Parser_fspace( p ) ;
 
string tmp= Parser_get_tmp( p ) ;
 
 Parser_gen( p , _STR("bool %.*s = ", tmp.len, tmp.str) ) ;
 
 Parser_check_types( p , Parser_bool_expression( p ) , tos2("bool") ) ;
 
string filename= p ->file_path ;
 
 Parser_genln( p , _STR(";\n \nif (!%.*s) { \n  puts(\"\\x1B[31mFAILED: %.*s() in %.*s:%d\\x1B[0m\");  \ng_test_ok = 0 ; \n	// TODO\n	// Maybe print all vars in a test function if it fails? \n} \nelse { \n  puts(\"\\x1B[32mPASSED: %.*s()\\x1B[0m\");\n}", tmp.len, tmp.str, p ->cur_fn ->name.len, p ->cur_fn ->name.str, filename.len, filename.str, p ->scanner ->line_nr, p ->cur_fn ->name.len, p ->cur_fn ->name.str) ) ;
 
 
 }
 void Parser_return_st(Parser* p) {
 
 CGen_insert_before( p ->cgen , p ->cur_fn ->defer ) ;
 
 Parser_gen( p , tos2("return ") ) ;
 
 if (string_eq( p ->cur_fn ->name , tos2("main") ) ) {
 /*if*/
 
 Parser_gen( p , tos2(" 0") ) ;
 
 }
 ;
 
 Parser_check( p , RETURN ) ;
 
 Parser_fgen( p , tos2(" ") ) ;
 
bool fn_returns=string_ne( p ->cur_fn ->typ , tos2("void") ) ;
 
 if ( fn_returns ) {
 /*if*/
 
 if ( p ->tok == RCBR ) {
 /*if*/
 
 Parser_error( p , _STR("`%.*s` needs to return `%.*s`", p ->cur_fn ->name.len, p ->cur_fn ->name.str, p ->cur_fn ->typ.len, p ->cur_fn ->typ.str) ) ;
 
 }
  else { 
 /*else if*/
 
int ph= CGen_add_placeholder( p ->cgen ) ;
 
string expr_type= Parser_bool_expression( p ) ;
 
 if ( string_ends_with( p ->cur_fn ->typ , expr_type )  &&  string_starts_with( p ->cur_fn ->typ , tos2("Option_") ) ) {
 /*if*/
 
 CGen_set_placeholder( p ->cgen , ph , tos2("opt_ok(& ") ) ;
 
 Parser_gen( p , tos2(")") ) ;
 
 }
 ;
 
 Parser_check_types( p , expr_type , p ->cur_fn ->typ ) ;
 
 }
 ;
 
 }
  else { 
 /*else if*/
 
 if ( 0  &&  p ->tok == NAME  ||  p ->tok == INT ) {
 /*if*/
 
 Parser_error( p , _STR("function `%.*s` does not return a value", p ->cur_fn ->name.len, p ->cur_fn ->name.str) ) ;
 
 }
 ;
 
 }
 ;
 
 p ->returns  =  1 ;
 
 
 }
 string prepend_pkg(string pkg, string name) {

 
 return  _STR("%.*s__%.*s", pkg.len, pkg.str, name.len, name.str) ;
 
 
 }
 string Parser_prepend_pkg(Parser* p, string name) {

 
 return  prepend_pkg ( p ->pkg , name ) ;
 
 
 }
 void Parser_go_statement(Parser* p) {
 
 Parser_check( p , GO ) ;
 
 if ( Parser_peek( p ) == DOT ) {
 /*if*/
 
string var_name= p ->lit ;
 
Var v= Fn_find_var(& /* ? */* p ->cur_fn , var_name ) ;
 
 Fn_mark_var_used(& /* ? */* p ->cur_fn , v ) ;
 
 Parser_next( p ) ;
 
 Parser_check( p , DOT ) ;
 
Type* typ= Table_find_type(& /* ? */* p ->table , v .typ ) ;
 
Fn method= Table_find_method(& /* ? */* p ->table , typ , p ->lit ) ;
 
 Parser_async_fn_call( p , method , 0 , var_name , v .typ ) ;
 
 }
  else { 
 /*else if*/
 
Fn f= Table_find_fn(& /* ? */* p ->table , p ->lit ) ;
 
 if (string_eq( f .name , tos2("println") ) ) {
 /*if*/
 
 Parser_error( p , tos2("`go` cannot be used with `println`") ) ;
 
 }
 ;
 
 Parser_async_fn_call( p , f , 0 , tos2("") , tos2("") ) ;
 
 }
 ;
 
 
 }
 void Parser_register_var(Parser* p, Var v) {
 
 if ( v .line_nr == 0 ) {
 /*if*/
 
 v .line_nr  =  p ->scanner ->line_nr ;
 
 }
 ;
 
 Fn_register_var( p ->cur_fn , v ) ;
 
 
 }
 string Parser_js_decode(Parser* p) {
 
 Parser_check( p , NAME ) ;
 
 Parser_check( p , DOT ) ;
 
string op= Parser_check_name( p ) ;
 
 if (string_eq( op , tos2("decode") ) ) {
 /*if*/
 
 Parser_check( p , LPAR ) ;
 
string typ= Parser_get_type( p ) ;
 
 Parser_check( p , COMMA ) ;
 
 CGen_start_tmp( p ->cgen ) ;
 
 Parser_check_types( p , Parser_bool_expression( p ) , tos2("string") ) ;
 
string expr= CGen_end_tmp( p ->cgen ) ;
 
 Parser_check( p , RPAR ) ;
 
string tmp= Parser_get_tmp( p ) ;
 
string cjson_tmp= Parser_get_tmp( p ) ;
 
string decl= _STR("%.*s %.*s; ", typ.len, typ.str, tmp.len, tmp.str) ;
 
Type* T= Table_find_type(& /* ? */* p ->table , typ ) ;
 
 array_Var tmp313 =  T ->fields;
 ;
for (int tmp314 = 0; tmp314 < tmp313 .len; tmp314 ++) {
 Var field = ((Var *) tmp313.data)[tmp314];
 
string def_val= type_default ( field .typ ) ;
 
 if (string_ne( def_val , tos2("") ) ) {
 /*if*/
 
 decl  = string_add( decl , _STR("%.*s . %.*s = %.*s;\n", tmp.len, tmp.str, field .name.len, field .name.str, def_val.len, def_val.str) ) ;
 
 }
 ;
 
 }
 ;
 
 Parser_gen_json_for_type( p ,* T ) ;
 
 decl  = string_add( decl , _STR("cJSON* %.*s = json__json_parse(%.*s);", cjson_tmp.len, cjson_tmp.str, expr.len, expr.str) ) ;
 
 CGen_insert_before( p ->cgen , decl ) ;
 
 Parser_gen( p , _STR("json__jsdecode_%.*s(%.*s, &%.*s); cJSON_Delete(%.*s);", typ.len, typ.str, cjson_tmp.len, cjson_tmp.str, tmp.len, tmp.str, cjson_tmp.len, cjson_tmp.str) ) ;
 
string opt_type= _STR("Option_%.*s", typ.len, typ.str) ;
 
_PUSH(& p ->cgen ->typedefs , ( _STR("typedef Option %.*s;", opt_type.len, opt_type.str) ), tmp317, string) ;
 
 Table_register_type( p ->table , opt_type ) ;

 
 return  opt_type ;
 
 }
  else  if (string_eq( op , tos2("encode") ) ) {
 /*if*/
 
 Parser_check( p , LPAR ) ;
 
 CGen_start_tmp( p ->cgen ) ;
 
string typ= Parser_bool_expression( p ) ;
 
Type* T= Table_find_type(& /* ? */* p ->table , typ ) ;
 
 Parser_gen_json_for_type( p ,* T ) ;
 
string expr= CGen_end_tmp( p ->cgen ) ;
 
 Parser_check( p , RPAR ) ;
 
 Parser_gen( p , _STR("json__json_print(json__jsencode_%.*s(%.*s))", typ.len, typ.str, expr.len, expr.str) ) ;

 
 return  tos2("string") ;
 
 }
  else { 
 /*else if*/
 
 Parser_error( p , _STR("bad json op \"%.*s\"", op.len, op.str) ) ;
 
 }
 ;

 
 return  tos2("") ;
 
 
 }
 bool is_compile_time_const(string s) {
 
 s  =  string_trim_space( s ) ;
 
 if (string_eq( s , tos2("") ) ) {
 /*if*/

 
 return  0 ;
 
 }
 ;
 
 if ( string_contains( s , tos2("\'") ) ) {
 /*if*/

 
 return  1 ;
 
 }
 ;
 
 string tmp321 =  s;
 ;
for (int tmp322 = 0; tmp322 < tmp321 .len; tmp322 ++) {
 byte c = ((byte *) tmp321.str)[tmp322];
 
 if ( ! (/*lpar*/ (/*lpar*/ c >= '0'  &&  c <= '9' )  ||  c == '.' ) ) {
 /*if*/

 
 return  0 ;
 
 }
 ;
 
 }
 ;

 
 return  1 ;
 
 
 }
 bool Parser_building_v(Parser* p) {
 
string cur_dir= os__getwd ( ) ;

 
 return  string_contains( p ->file_path , tos2("v/compiler") )  ||  string_contains( cur_dir , tos2("v/compiler") ) ;
 
 
 }
 void Scanner_fgen(Scanner* scanner, string s) {
 
 
 }
 void Scanner_fgenln(Scanner* scanner, string s) {
 
 
 }
 void Parser_fgen(Parser* p, string s) {
 
 
 }
 void Parser_fspace(Parser* p) {
 
 
 }
 void Parser_fgenln(Parser* p, string s) {
 
 
 }
 Scanner* new_scanner(string file_path) {
 
 if ( ! os__file_exists ( file_path ) ) {
 /*if*/
 
 v_panic ( _STR("\"%.*s\" doesn\'t exist", file_path.len, file_path.str) ) ;
 
 }
 ;
 
Option_string tmp1 =  os__read_file ( file_path ) ; if (!tmp1 .ok) {
 
 v_panic ( _STR("scanner: failed to open \"%.*s\"", file_path.len, file_path.str) ) ;

 
 return  ALLOC_INIT(Scanner, { .file_path = tos("", 0) , .text = tos("", 0) , .pos = 0 , .line_nr = 0 , .inside_string = 0 , .dollar_start = 0 , .dollar_end = 0 , .debug = 0 , .line_comment = tos("", 0) , .started = 0 , .is_fmt = 0 , .fmt_indent = 0 , .fmt_line_empty = 0 } ) ;
 
 }
 string text = *(string*) tmp1 . data;
 ;
 
Scanner* scanner= ALLOC_INIT(Scanner, { .file_path =  file_path , .text =  text , .fmt_out =  new_string_builder ( 1000 ) , .pos = 0 , .line_nr = 0 , .inside_string = 0 , .dollar_start = 0 , .dollar_end = 0 , .debug = 0 , .line_comment = tos("", 0) , .started = 0 , .is_fmt = 0 , .fmt_indent = 0 , .fmt_line_empty = 0 } ) ;
 
 //println ( _STR("new scanner \"%.*s\" txt.len=%d", file_path.len, file_path.str, scanner ->text .len) ) ;

 
 return  scanner ;
 
 
 }
 ScanRes scan_res(Token tok, string lit) {

 
 return  (ScanRes) { tok , lit } ;
 
 
 }
 bool is_white(byte c) {

 
 return  byte_is_white( c ) ;
 
 
 }
 bool is_nl(byte c) {

 
 return  c == '\r'  ||  c == '\n' ;
 
 
 }
 string Scanner_ident_name(Scanner* s) {
 
int start= s ->pos ;
 
 while (1) { 
 s ->pos ++ ;
 
 if ( s ->pos >= s ->text .len ) {
 /*if*/
 
 break
 ;
 
 }
 ;
 
byte c= string_at( s ->text , s ->pos) ;
 
 if ( ! is_name_char ( c )  &&  ! byte_is_digit( c ) ) {
 /*if*/
 
 break
 ;
 
 }
 ;
 
 }
 ;
 
string name= string_substr( s ->text , start , s ->pos ) ;
 
 s ->pos -- ;

 
 return  name ;
 
 
 }
 string Scanner_ident_number(Scanner* s) {
 
int start= s ->pos ;
 
bool is_hex= s ->pos + 1 < s ->text .len  &&  string_at( s ->text , s ->pos) == '0'  &&  string_at( s ->text , s ->pos + 1) == 'x' ;
 
bool is_oct= ! is_hex  &&  string_at( s ->text , s ->pos) == '0' ;
 
bool is_float= 0 ;
 
 while (1) { 
 s ->pos ++ ;
 
 if ( s ->pos >= s ->text .len ) {
 /*if*/
 
 break
 ;
 
 }
 ;
 
byte c= string_at( s ->text , s ->pos) ;
 
 if ( c == '.' ) {
 /*if*/
 
 is_float  =  1 ;
 
 }
 ;
 
bool is_good_hex= is_hex  &&  (/*lpar*/ c == 'x'  ||  (/*lpar*/ c >= 'a'  &&  c <= 'f' ) ) ;
 
 if ( ! is_hex  &&  c == 'e'  &&  s ->pos + 1 < s ->text .len ) {
 /*if*/
 
byte next= string_at( s ->text , s ->pos + 1) ;
 
 if ( next == '+'  ||  next == '-'  ||  byte_is_digit( next ) ) {
 /*if*/
 
 s ->pos ++ ;
 
 continue
 ;
 
 }
 ;
 
 }
 ;
 
 if ( ! byte_is_digit( c )  &&  c != '.'  &&  ! is_good_hex ) {
 /*if*/
 
 break
 ;
 
 }
 ;
 
 if ( c == '.'  &&  s ->pos + 1 < s ->text .len  &&  string_at( s ->text , s ->pos + 1) == '.' ) {
 /*if*/
 
 break
 ;
 
 }
 ;
 
 if ( is_oct  &&  c >= '8'  &&  ! is_float ) {
 /*if*/
 
 Scanner_error(& /* ? */* s , tos2("malformed octal constant") ) ;
 
 }
 ;
 
 }
 ;
 
string number= string_substr( s ->text , start , s ->pos ) ;
 
 s ->pos -- ;

 
 return  number ;
 
 
 }
 void Scanner_skip_whitespace(Scanner* s) {
 
 while ( s ->pos < s ->text .len  &&  is_white ( string_at( s ->text , s ->pos) ) ) {
 
 if ( is_nl ( string_at( s ->text , s ->pos) ) ) {
 /*if*/
 
 s ->line_nr ++ ;
 
 if ( s ->is_fmt ) {
 /*if*/

 
 return  ;
 
 }
 ;
 
 }
 ;
 
 s ->pos ++ ;
 
 }
 ;
 
 
 }
 string Scanner_get_var_name(Scanner* s, int pos) {
 
int pos_start= pos ;
 
 for (
  ;  pos_start >= 0  &&  string_at( s ->text , pos_start) != '\n'  &&  string_at( s ->text , pos_start) != ';'  ;  pos_start -- ) { 
 
 }
 ;
 
 pos_start ++ ;

 
 return  string_substr( s ->text , pos_start , pos ) ;
 
 
 }
 void Scanner_cao_change(Scanner* s, string operator) {
 
 s ->text  = string_add(string_add(string_add(string_add(string_add(string_add( string_substr( s ->text , 0 , s ->pos - operator .len ) , tos2(" = ") ) , Scanner_get_var_name( s , s ->pos - operator .len ) ) , tos2(" ") ) , operator ) , tos2(" ") ) , string_substr( s ->text , s ->pos + 1 , s ->text .len ) ) ;
 
 
 }
 ScanRes Scanner_scan(Scanner* s) {
 
 if ( s ->pos > 0 ) {
 /*if*/
 
 s ->pos ++ ;
 
 }
 ;
 
 s ->started  =  1 ;
 
 if ( s ->pos >= s ->text .len ) {
 /*if*/

 
 return  scan_res ( EOF , tos2("") ) ;
 
 }
 ;
 
 if ( ! s ->inside_string ) {
 /*if*/
 
 Scanner_skip_whitespace( s ) ;
 
 }
 ;
 
 if ( s ->is_fmt  &&  string_at( s ->text , s ->pos) == '\n' ) {
 /*if*/

 
 return  scan_res ( NL , tos2("") ) ;
 
 }
 ;
 
 if ( ! s ->is_fmt  &&  s ->dollar_end ) {
 /*if*/
 
 if ( string_at( s ->text , s ->pos) == main__SINGLE_QUOTE ) {
 /*if*/
 
 s ->dollar_end  =  0 ;

 
 return  scan_res ( STRING , tos2("") ) ;
 
 }
 ;
 
 s ->dollar_end  =  0 ;

 
 return  scan_res ( STRING , Scanner_ident_string( s ) ) ;
 
 }
 ;
 
 Scanner_skip_whitespace( s ) ;
 
 if ( s ->pos >= s ->text .len ) {
 /*if*/

 
 return  scan_res ( EOF , tos2("") ) ;
 
 }
 ;
 
byte c= string_at( s ->text , s ->pos) ;
 
byte nextc= '\0' ;
 
 if ( s ->pos + 1 < s ->text .len ) {
 /*if*/
 
 nextc  =  string_at( s ->text , s ->pos + 1) ;
 
 }
 ;
 
 if ( is_name_char ( c ) ) {
 /*if*/
 
string name= Scanner_ident_name( s ) ;
 
byte next_char= ( s ->pos + 1 < s ->text .len ) ? ( string_at( s ->text , s ->pos + 1) ) : ( '\0' ) ;
 
 if ( is_key ( name ) ) {
 /*if*/

 
 return  scan_res ( key_to_token ( name ) , tos2("") ) ;
 
 }
 ;
 
 if ( s ->inside_string ) {
 /*if*/
 
 if ( next_char == main__SINGLE_QUOTE ) {
 /*if*/
 
 s ->pos ++ ;
 
 s ->dollar_start  =  0 ;
 
 s ->inside_string  =  0 ;
 
 }
 ;
 
 }
 ;
 
 if ( s ->dollar_start  &&  next_char != '.' ) {
 /*if*/
 
 s ->dollar_end  =  1 ;
 
 s ->dollar_start  =  0 ;
 
 }
 ;
 
 if ( s ->pos == 0  &&  next_char == ' ' ) {
 /*if*/
 
 s ->pos ++ ;
 
 }
 ;

 
 return  scan_res ( NAME , name ) ;
 
 }
  else  if ( byte_is_digit( c )  ||  c == '.'  &&  byte_is_digit( nextc ) ) {
 /*if*/
 
string num= Scanner_ident_number( s ) ;

 
 return  scan_res ( INT , num ) ;
 
 }
 ;
 
 if ( ( c ==  '+' )) { /* case */
 
 if ( nextc == '+' ) {
 /*if*/
 
 s ->pos ++ ;

 
 return  scan_res ( INC , tos2("") ) ;
 
 }
  else  if ( nextc == '=' ) {
 /*if*/
 
 s ->pos ++ ;
 
 Scanner_cao_change( s , tos2("+") ) ;

 
 return  scan_res ( PLUS_ASSIGN , tos2("") ) ;
 
 }
 ;

 
 return  scan_res ( PLUS , tos2("") ) ;
 
 }
 else  if ( ( c ==  '-' )) { /* case */
 
 if ( nextc == '-' ) {
 /*if*/
 
 s ->pos ++ ;

 
 return  scan_res ( DEC , tos2("") ) ;
 
 }
  else  if ( nextc == '=' ) {
 /*if*/
 
 s ->pos ++ ;
 
 Scanner_cao_change( s , tos2("-") ) ;

 
 return  scan_res ( MINUS_ASSIGN , tos2("") ) ;
 
 }
 ;

 
 return  scan_res ( MINUS , tos2("") ) ;
 
 }
 else  if ( ( c ==  '*' )) { /* case */
 
 if ( nextc == '=' ) {
 /*if*/
 
 s ->pos ++ ;
 
 Scanner_cao_change( s , tos2("*") ) ;

 
 return  scan_res ( MULT_ASSIGN , tos2("") ) ;
 
 }
 ;

 
 return  scan_res ( MUL , tos2("") ) ;
 
 }
 else  if ( ( c ==  '^' )) { /* case */
 
 if ( nextc == '=' ) {
 /*if*/
 
 s ->pos ++ ;
 
 Scanner_cao_change( s , tos2("^") ) ;

 
 return  scan_res ( XOR_ASSIGN , tos2("") ) ;
 
 }
 ;

 
 return  scan_res ( XOR , tos2("") ) ;
 
 }
 else  if ( ( c ==  '%' )) { /* case */
 
 if ( nextc == '=' ) {
 /*if*/
 
 s ->pos ++ ;
 
 Scanner_cao_change( s , tos2("%") ) ;

 
 return  scan_res ( MOD_ASSIGN , tos2("") ) ;
 
 }
 ;

 
 return  scan_res ( MOD , tos2("") ) ;
 
 }
 else  if ( ( c ==  '?' )) { /* case */

 
 return  scan_res ( QUESTION , tos2("") ) ;
 
 }
 else  if ( ( c ==  main__SINGLE_QUOTE )) { /* case */

 
 return  scan_res ( STRING , Scanner_ident_string( s ) ) ;
 
 }
 else  if ( ( c ==  '\`' )) { /* case */

 
 return  scan_res ( CHAR , Scanner_ident_char( s ) ) ;
 
 }
 else  if ( ( c ==  '(' )) { /* case */

 
 return  scan_res ( LPAR , tos2("") ) ;
 
 }
 else  if ( ( c ==  ')' )) { /* case */

 
 return  scan_res ( RPAR , tos2("") ) ;
 
 }
 else  if ( ( c ==  '[' )) { /* case */

 
 return  scan_res ( LSBR , tos2("") ) ;
 
 }
 else  if ( ( c ==  ']' )) { /* case */

 
 return  scan_res ( RSBR , tos2("") ) ;
 
 }
 else  if ( ( c ==  '{' )) { /* case */
 
 if ( s ->inside_string ) {
 /*if*/

 
 return  Scanner_scan( s ) ;
 
 }
 ;

 
 return  scan_res ( LCBR , tos2("") ) ;
 
 }
 else  if ( ( c ==  '$' )) { /* case */

 
 return  scan_res ( DOLLAR , tos2("") ) ;
 
 }
 else  if ( ( c ==  '}' )) { /* case */
 
 if ( s ->inside_string ) {
 /*if*/
 
 s ->pos ++ ;
 
 if ( string_at( s ->text , s ->pos) == main__SINGLE_QUOTE ) {
 /*if*/
 
 s ->inside_string  =  0 ;

 
 return  scan_res ( STRING , tos2("") ) ;
 
 }
 ;

 
 return  scan_res ( STRING , Scanner_ident_string( s ) ) ;
 
 }
  else { 
 /*else if*/

 
 return  scan_res ( RCBR , tos2("") ) ;
 
 }
 ;
 
 }
 else  if ( ( c ==  '&' )) { /* case */
 
 if ( nextc == '=' ) {
 /*if*/
 
 s ->pos ++ ;
 
 Scanner_cao_change( s , tos2("&") ) ;

 
 return  scan_res ( AND_ASSIGN , tos2("") ) ;
 
 }
 ;
 
 if ( nextc == '&' ) {
 /*if*/
 
 s ->pos ++ ;

 
 return  scan_res ( AND , tos2("") ) ;
 
 }
 ;

 
 return  scan_res ( AMP , tos2("") ) ;
 
 }
 else  if ( ( c ==  '|' )) { /* case */
 
 if ( nextc == '|' ) {
 /*if*/
 
 s ->pos ++ ;

 
 return  scan_res ( OR , tos2("") ) ;
 
 }
 ;
 
 if ( nextc == '=' ) {
 /*if*/
 
 s ->pos ++ ;
 
 Scanner_cao_change( s , tos2("|") ) ;

 
 return  scan_res ( OR_ASSIGN , tos2("") ) ;
 
 }
 ;

 
 return  scan_res ( PIPE , tos2("") ) ;
 
 }
 else  if ( ( c ==  ',' )) { /* case */

 
 return  scan_res ( COMMA , tos2("") ) ;
 
 }
 else  if ( ( c ==  '\r' )) { /* case */
 
 if ( nextc == '\n' ) {
 /*if*/
 
 s ->pos ++ ;

 
 return  scan_res ( NL , tos2("") ) ;
 
 }
 ;
 
 }
 else  if ( ( c ==  '\n' )) { /* case */

 
 return  scan_res ( NL , tos2("") ) ;
 
 }
 else  if ( ( c ==  '.' )) { /* case */
 
 if ( nextc == '.' ) {
 /*if*/
 
 s ->pos ++ ;

 
 return  scan_res ( DOTDOT , tos2("") ) ;
 
 }
 ;

 
 return  scan_res ( DOT , tos2("") ) ;
 
 }
 else  if ( ( c ==  '#' )) { /* case */
 
int start= s ->pos + 1 ;
 
 while ( s ->pos < s ->text .len  &&  string_at( s ->text , s ->pos) != '\n' ) {
 
 s ->pos ++ ;
 
 }
 ;
 
 s ->line_nr ++ ;
 
string hash= string_substr( s ->text , start , s ->pos ) ;
 
 if ( s ->is_fmt ) {
 /*if*/
 
 s ->pos -- ;
 
 }
 ;

 
 return  scan_res ( HASH , string_trim_space( hash ) ) ;
 
 }
 else  if ( ( c ==  '>' )) { /* case */
 
 if ( nextc == '=' ) {
 /*if*/
 
 s ->pos ++ ;

 
 return  scan_res ( GE , tos2("") ) ;
 
 }
  else  if ( nextc == '>' ) {
 /*if*/
 
 if ( s ->pos + 2 < s ->text .len  &&  string_at( s ->text , s ->pos + 2) == '=' ) {
 /*if*/
 
 s ->pos  =  s ->pos + 2 ;
 
 Scanner_cao_change( s , tos2(">>") ) ;

 
 return  scan_res ( RIGHT_SHIFT_ASSIGN , tos2("") ) ;
 
 }
 ;
 
 s ->pos ++ ;

 
 return  scan_res ( RIGHT_SHIFT , tos2("") ) ;
 
 }
  else { 
 /*else if*/

 
 return  scan_res ( GT , tos2("") ) ;
 
 }
 ;
 
 }
 else  if ( ( c ==  '<' )) { /* case */
 
 if ( nextc == '=' ) {
 /*if*/
 
 s ->pos ++ ;

 
 return  scan_res ( LE , tos2("") ) ;
 
 }
  else  if ( nextc == '<' ) {
 /*if*/
 
 if ( s ->pos + 2 < s ->text .len  &&  string_at( s ->text , s ->pos + 2) == '=' ) {
 /*if*/
 
 s ->pos  =  s ->pos + 2 ;
 
 Scanner_cao_change( s , tos2("<<") ) ;

 
 return  scan_res ( LEFT_SHIFT_ASSIGN , tos2("") ) ;
 
 }
 ;
 
 s ->pos ++ ;

 
 return  scan_res ( LEFT_SHIFT , tos2("") ) ;
 
 }
  else { 
 /*else if*/

 
 return  scan_res ( LT , tos2("") ) ;
 
 }
 ;
 
 }
 else  if ( ( c ==  '=' )) { /* case */
 
 if ( nextc == '=' ) {
 /*if*/
 
 s ->pos ++ ;

 
 return  scan_res ( EQ , tos2("") ) ;
 
 }
  else { 
 /*else if*/

 
 return  scan_res ( ASSIGN , tos2("") ) ;
 
 }
 ;
 
 }
 else  if ( ( c ==  ':' )) { /* case */
 
 if ( nextc == '=' ) {
 /*if*/
 
 s ->pos ++ ;

 
 return  scan_res ( DECL_ASSIGN , tos2("") ) ;
 
 }
  else { 
 /*else if*/

 
 return  scan_res ( COLON , tos2("") ) ;
 
 }
 ;
 
 }
 else  if ( ( c ==  ';' )) { /* case */

 
 return  scan_res ( SEMICOLON , tos2("") ) ;
 
 }
 else  if ( ( c ==  '!' )) { /* case */
 
 if ( nextc == '=' ) {
 /*if*/
 
 s ->pos ++ ;

 
 return  scan_res ( NE , tos2("") ) ;
 
 }
  else { 
 /*else if*/

 
 return  scan_res ( NOT , tos2("") ) ;
 
 }
 ;
 
 }
 else  if ( ( c ==  '~' )) { /* case */

 
 return  scan_res ( BIT_NOT , tos2("") ) ;
 
 }
 else  if ( ( c ==  '/' )) { /* case */
 
 if ( nextc == '=' ) {
 /*if*/
 
 s ->pos ++ ;
 
 Scanner_cao_change( s , tos2("/") ) ;

 
 return  scan_res ( DIV_ASSIGN , tos2("") ) ;
 
 }
 ;
 
 if ( nextc == '/' ) {
 /*if*/
 
int start= s ->pos + 1 ;
 
 while ( s ->pos < s ->text .len  &&  string_at( s ->text , s ->pos) != '\n' ) {
 
 s ->pos ++ ;
 
 }
 ;
 
 s ->line_nr ++ ;
 
 s ->line_comment  =  string_substr( s ->text , start + 1 , s ->pos ) ;
 
 s ->line_comment  =  string_trim_space( s ->line_comment ) ;
 
 Scanner_fgenln( s , _STR("// %.*s", s ->line_comment.len, s ->line_comment.str) ) ;
 
 if ( s ->is_fmt ) {
 /*if*/
 
 s ->pos -- ;
 
 }
  else { 
 /*else if*/

 
 return  Scanner_scan( s ) ;
 
 }
 ;

 
 return  scan_res ( LINE_COM , s ->line_comment ) ;
 
 }
 ;
 
 if ( nextc == '*' ) {
 /*if*/
 
int start= s ->pos ;
 
 while ( ! (/*lpar*/ string_at( s ->text , s ->pos) == '*'  &&  string_at( s ->text , s ->pos + 1) == '/' ) ) {
 
 s ->pos ++ ;
 
 if ( s ->pos >= s ->text .len ) {
 /*if*/
 
 s ->line_nr -- ;
 
 Scanner_error(& /* ? */* s , tos2("comment not terminated") ) ;
 
 }
 ;
 
 if ( string_at( s ->text , s ->pos) == '\n' ) {
 /*if*/
 
 s ->line_nr ++ ;
 
 }
 ;
 
 }
 ;
 
 s ->pos ++ ;
 
int end= s ->pos + 1 ;
 
string comm= string_substr( s ->text , start , end ) ;
 
 Scanner_fgenln( s , comm ) ;
 
 if ( s ->is_fmt ) {
 /*if*/

 
 return  scan_res ( MLINE_COM , comm ) ;
 
 }
 ;

 
 return  Scanner_scan( s ) ;
 
 }
 ;

 
 return  scan_res ( DIV , tos2("") ) ;
 
 }
 ;
 
 if ( c == '\0' ) {
 /*if*/

 
 return  scan_res ( EOF , tos2("") ) ;
 
 }
 ;
 
 println ( _STR("(char code=%d) pos=%d len=%d", c, s ->pos, s ->text .len) ) ;
 
 Scanner_error(& /* ? */* s , _STR("invalid character `%.*s`", byte_str( c ).len, byte_str( c ).str) ) ;

 
 return  scan_res ( EOF , tos2("") ) ;
 
 
 }
 void Scanner_error(Scanner* s, string msg) {
 
string file= string_all_after( s ->file_path , tos2("/") ) ;
 
 println ( _STR("panic: %.*s:%d", file.len, file.str, s ->line_nr + 1) ) ;
 
 println ( msg ) ;
 
 v_exit ( 1 ) ;
 
 
 }
 string Scanner_ident_string(Scanner* s) {
 
bool debug= string_contains( s ->file_path , tos2("test_test") ) ;
 
 if ( debug ) {
 /*if*/
 
 println ( _STR("identStr() %.*s line=%d pos=%d", s ->file_path.len, s ->file_path.str, s ->line_nr, s ->pos) ) ;
 
 }
 ;
 
int start= s ->pos ;
 
 s ->inside_string  =  0 ;
 
byte slash= '\\' ;
 
 while (1) { 
 s ->pos ++ ;
 
 if ( s ->pos >= s ->text .len ) {
 /*if*/
 
 break
 ;
 
 }
 ;
 
byte c= string_at( s ->text , s ->pos) ;
 
 if ( debug ) {
 /*if*/
 
 println ( byte_str( c ) ) ;
 
 }
 ;
 
byte prevc= string_at( s ->text , s ->pos - 1) ;
 
 if ( c == main__SINGLE_QUOTE  &&  (/*lpar*/ prevc != slash  ||  (/*lpar*/ prevc == slash  &&  string_at( s ->text , s ->pos - 2) == slash ) ) ) {
 /*if*/
 
 break
 ;
 
 }
 ;
 
 if ( c == '\n' ) {
 /*if*/
 
 s ->line_nr ++ ;
 
 }
 ;
 
 if ( c == '0'  &&  s ->pos > 2  &&  string_at( s ->text , s ->pos - 1) == '\\' ) {
 /*if*/
 
 Scanner_error(& /* ? */* s , tos2("0 character in a string literal") ) ;
 
 }
 ;
 
 if ( c == '0'  &&  s ->pos > 5  &&  string_at( s ->text , s ->pos - 1) == '0'  &&  string_at( s ->text , s ->pos - 2) == 'x'  &&  string_at( s ->text , s ->pos - 3) == '\\' ) {
 /*if*/
 
 Scanner_error(& /* ? */* s , tos2("0 character in a string literal") ) ;
 
 }
 ;
 
 if ( ! s ->is_fmt  &&  c == '{'  &&  prevc == '$' ) {
 /*if*/
 
 s ->inside_string  =  1 ;
 
 s ->pos  =  s ->pos - 2 ;
 
 break
 ;
 
 }
 ;
 
 if ( ! s ->is_fmt  &&  (/*lpar*/ byte_is_letter( c )  ||  c == '_' )  &&  prevc == '$' ) {
 /*if*/
 
 s ->inside_string  =  1 ;
 
 s ->dollar_start  =  1 ;
 
 s ->pos  =  s ->pos - 2 ;
 
 break
 ;
 
 }
 ;
 
 }
 ;
 
string lit= tos2("") ;
 
 if ( string_at( s ->text , start) == main__SINGLE_QUOTE ) {
 /*if*/
 
 start ++ ;
 
 }
 ;
 
int end= s ->pos ;
 
 if ( s ->inside_string ) {
 /*if*/
 
 end ++ ;
 
 }
 ;
 
 if ( start > s ->pos ) {
 /*if*/
 
 }
  else { 
 /*else if*/
 
 lit  =  string_substr( s ->text , start , end ) ;
 
 }
 ;

 
 return  lit ;
 
 
 }
 string Scanner_ident_char(Scanner* s) {
 
int start= s ->pos ;
 
byte slash= '\\' ;
 
int len= 0 ;
 
 while (1) { 
 s ->pos ++ ;
 
 if ( s ->pos >= s ->text .len ) {
 /*if*/
 
 break
 ;
 
 }
 ;
 
 if ( string_at( s ->text , s ->pos) != slash ) {
 /*if*/
 
 len ++ ;
 
 }
 ;
 
bool double_slash= string_at( s ->text , s ->pos - 1) == slash  &&  string_at( s ->text , s ->pos - 2) == slash ;
 
 if ( string_at( s ->text , s ->pos) == '\`'  &&  (/*lpar*/ string_at( s ->text , s ->pos - 1) != slash  ||  double_slash ) ) {
 /*if*/
 
 if ( double_slash ) {
 /*if*/
 
 len ++ ;
 
 }
 ;
 
 break
 ;
 
 }
 ;
 
 }
 ;
 
 len -- ;
 
string c= string_substr( s ->text , start + 1 , s ->pos ) ;
 
 if ( len != 1 ) {
 /*if*/
 
 Scanner_error(& /* ? */* s , _STR("invalid character literal (more than one character: %d)", len) ) ;
 
 }
 ;

 
 return  c ;
 
 
 }
 Token Parser_peek(Parser* p) {
 
 while (1) { 
Token tok= Scanner_peek( p ->scanner ) ;
 
 if ( tok != NL ) {
 /*if*/

 
 return  tok ;
 
 }
 ;
 
 }
 ;
 
 
 }
 Token Scanner_peek(Scanner* s) {
 
int pos= s ->pos ;
 
int line= s ->line_nr ;
 
bool inside_string= s ->inside_string ;
 
bool dollar_start= s ->dollar_start ;
 
bool dollar_end= s ->dollar_end ;
 
ScanRes res= Scanner_scan( s ) ;
 
Token tok= res .tok ;
 
 s ->pos  =  pos ;
 
 s ->line_nr  =  line ;
 
 s ->inside_string  =  inside_string ;
 
 s ->dollar_start  =  dollar_start ;
 
 s ->dollar_end  =  dollar_end ;

 
 return  tok ;
 
 
 }
 void Scanner_debug_tokens(Scanner* s) {
 
 s ->pos  =  0 ;
 
string fname= string_all_after( s ->file_path , tos2("/") ) ;
 
 println ( _STR("\n===DEBUG TOKENS %.*s ============", fname.len, fname.str) ) ;
 
 s ->debug  =  1 ;
 
 while (1) { 
ScanRes res= Scanner_scan( s ) ;
 
Token tok= res .tok ;
 
string lit= res .lit ;
 
 v_print ( Token_str( tok ) ) ;
 
 if (string_ne( lit , tos2("") ) ) {
 /*if*/
 
 println ( _STR(" `%.*s`", lit.len, lit.str) ) ;
 
 }
  else { 
 /*else if*/
 
 println ( tos2("") ) ;
 
 }
 ;
 
 if ( tok == EOF ) {
 /*if*/
 
 println ( tos2("============ END OF DEBUG TOKENS ==================") ) ;
 
 break
 ;
 
 }
 ;
 
 }
 ;
 
 
 }
 bool is_name_char(byte c) {

 
 return  byte_is_letter( c )  ||  c == '_' ;
 
 
 }
 int Scanner_get_opening_bracket(Scanner* s) {
 
int pos= s ->pos ;
 
int parentheses= 0 ;
 
bool inside_string= 0 ;
 
 while ( pos > 0  &&  string_at( s ->text , pos) != '\n' ) {
 
 if ( string_at( s ->text , pos) == ')'  &&  ! inside_string ) {
 /*if*/
 
 parentheses ++ ;
 
 }
 ;
 
 if ( string_at( s ->text , pos) == '('  &&  ! inside_string ) {
 /*if*/
 
 parentheses -- ;
 
 }
 ;
 
 if ( string_at( s ->text , pos) == '\''  &&  string_at( s ->text , pos - 1) != '\\'  &&  string_at( s ->text , pos - 1) != '\`' ) {
 /*if*/
 
 inside_string  =  ! inside_string ;
 
 }
 ;
 
 if ( parentheses == 0 ) {
 /*if*/
 
 break
 ;
 
 }
 ;
 
 pos -- ;
 
 }
 ;

 
 return  pos ;
 
 
 }
 void Scanner_create_type_string(Scanner* s, Type T, string name) {
 
int line= s ->line_nr ;
 
bool inside_string= s ->inside_string ;
 
string newtext= tos2("\'{ ") ;
 
int start= Scanner_get_opening_bracket( s ) + 1 ;
 
int end= s ->pos ;
 
 array_Var tmp145 =  T .fields ;
 ;
for (int i = 0; i < tmp145 .len; i ++) {
 Var field = ((Var *) tmp145 . data)[i];
 
 if ( i != 0 ) {
 /*if*/
 
 newtext  = string_add( newtext , tos2(", ") ) ;
 
 }
 ;
 
 newtext  = string_add(string_add( newtext , _STR("%.*s: ", field .name.len, field .name.str) ) , _STR("$%.*s.%.*s", name.len, name.str, field .name.len, field .name.str) ) ;
 
 }
 ;
 
 newtext  = string_add( newtext , tos2(" }\'") ) ;
 
 s ->text  = string_add(string_add( string_substr( s ->text , 0 , start ) , newtext ) , string_substr( s ->text , end , s ->text .len ) ) ;
 
 s ->pos  =  start - 2 ;
 
 s ->line_nr  =  line ;
 
 s ->inside_string  =  inside_string ;
 
 
 }
 void Parser_create_type_string(Parser* p, Type T, string name) {
 
 Scanner_create_type_string( p ->scanner , T , name ) ;
 
 
 }
 string Type_str(Type t) {
 
string s= _STR("type \"%.*s\" {", t .name.len, t .name.str) ;
 
 if ( t .fields .len > 0 ) {
 /*if*/
 
 array_Var tmp2 =  t .fields;
 ;
for (int tmp3 = 0; tmp3 < tmp2 .len; tmp3 ++) {
 Var field = ((Var *) tmp2.data)[tmp3];
 
 s  = string_add( s , _STR("\n    %.*s %.*s", field .name.len, field .name.str, field .typ.len, field .typ.str) ) ;
 
 }
 ;
 
 s  = string_add( s , tos2("\n") ) ;
 
 }
 ;
 
 if ( t .methods .len > 0 ) {
 /*if*/
 
 array_Fn tmp4 =  t .methods;
 ;
for (int tmp5 = 0; tmp5 < tmp4 .len; tmp5 ++) {
 Fn method = ((Fn *) tmp4.data)[tmp5];
 
 s  = string_add( s , _STR("\n    %.*s", Fn_str( method ).len, Fn_str( method ).str) ) ;
 
 }
 ;
 
 s  = string_add( s , tos2("\n") ) ;
 
 }
 ;
 
 s  = string_add( s , tos2("}\n") ) ;

 
 return  s ;
 
 
 }
 string Fn_str(Fn f) {
 
Table t= (Table) { .types = new_array(0, 1, sizeof(Type)) , .consts = new_array(0, 1, sizeof(Var)) , .fns = new_array(0, 1, sizeof(Fn)) , .packages = new_array(0, 1, sizeof(string)) , .imports = new_array(0, 1, sizeof(string)) , .flags = new_array(0, 1, sizeof(string)) , .fn_cnt = 0 , .obfuscate = 0 } ;
 
string str_args= Fn_str_args(& /* ? */ f ,& /*11 EXP:"Table*" GOT:"Table" */ t ) ;

 
 return  _STR("%.*s(%.*s) %.*s", f .name.len, f .name.str, str_args.len, str_args.str, f .typ.len, f .typ.str) ;
 
 
 }
 bool is_number_type(string typ) {

 
 return  array_string_contains( main__NUMBER_TYPES , typ ) ;
 
 
 }
 bool is_float_type(string typ) {

 
 return  array_string_contains( main__FLOAT_TYPES , typ ) ;
 
 
 }
 Table* new_table(bool obfuscate) {
 
Table* t= ALLOC_INIT(Table, { .obf_ids =  new_map(1, sizeof(int)) , .obfuscate =  obfuscate , .types = new_array(0, 1, sizeof(Type)) , .consts = new_array(0, 1, sizeof(Var)) , .fns = new_array(0, 1, sizeof(Fn)) , .packages = new_array(0, 1, sizeof(string)) , .imports = new_array(0, 1, sizeof(string)) , .flags = new_array(0, 1, sizeof(string)) , .fn_cnt = 0 , } ) ;
 
 Table_register_type( t , tos2("int") ) ;
 
 Table_register_type( t , tos2("size_t") ) ;
 
 Table_register_type_with_parent( t , tos2("i8") , tos2("int") ) ;
 
 Table_register_type_with_parent( t , tos2("u8") , tos2("int") ) ;
 
 Table_register_type_with_parent( t , tos2("i16") , tos2("int") ) ;
 
 Table_register_type_with_parent( t , tos2("u16") , tos2("int") ) ;
 
 Table_register_type_with_parent( t , tos2("i32") , tos2("int") ) ;
 
 Table_register_type_with_parent( t , tos2("u32") , tos2("int") ) ;
 
 Table_register_type_with_parent( t , tos2("byte") , tos2("int") ) ;
 
 Table_register_type( t , tos2("i64") ) ;
 
 Table_register_type_with_parent( t , tos2("u64") , tos2("int") ) ;
 
 Table_register_type( t , tos2("byteptr") ) ;
 
 Table_register_type( t , tos2("intptr") ) ;
 
 Table_register_type( t , tos2("f32") ) ;
 
 Table_register_type( t , tos2("f64") ) ;
 
 Table_register_type( t , tos2("rune") ) ;
 
 Table_register_type( t , tos2("bool") ) ;
 
 Table_register_type( t , tos2("void") ) ;
 
 Table_register_type( t , tos2("voidptr") ) ;
 
 Table_register_type( t , tos2("va_list") ) ;
 
 Table_register_const( t , tos2("stdin") , tos2("int") , tos2("main") , 0 ) ;
 
 Table_register_const( t , tos2("stdout") , tos2("int") , tos2("main") , 0 ) ;
 
 Table_register_const( t , tos2("stderr") , tos2("int") , tos2("main") , 0 ) ;
 
 Table_register_const( t , tos2("errno") , tos2("int") , tos2("main") , 0 ) ;
 
 Table_register_type_with_parent( t , tos2("map_string") , tos2("map") ) ;
 
 Table_register_type_with_parent( t , tos2("map_int") , tos2("map") ) ;

 
 return  t ;
 
 
 }
 string Table_var_cgen_name(Table* t, string name) {
 
 if ( array_string_contains( main__CReserved , name ) ) {
 /*if*/

 
 return  _STR("v_%.*s", name.len, name.str) ;
 
 }
  else { 
 /*else if*/

 
 return  name ;
 
 }
 ;
 
 
 }
 void Table_register_package(Table* t, string pkg) {
 
 if ( array_string_contains( t ->packages , pkg ) ) {
 /*if*/

 
 return  ;
 
 }
 ;
 
_PUSH(& t ->packages , ( pkg ), tmp9, string) ;
 
 
 }
 bool Table_known_pkg(Table* table, string pkg) {

 
 return _IN(string,  pkg ,  table ->packages ) ;
 
 
 }
 void Table_register_const(Table* t, string name, string typ, string pkg, bool is_imported) {
 
_PUSH(& t ->consts , ( (Var) { .name =  name , .typ =  typ , .is_const =  1 , .is_import_const =  is_imported , .pkg =  pkg , .is_arg = 0 , .args = new_array(0, 1, sizeof(Var)) , .attr = tos("", 0) , .is_mut = 0 , .ptr = 0 , .ref = 0 , .parent_fn = tos("", 0) , .line_nr = 0 , .is_global = 0 , .is_used = 0 , .scope_level = 0 } ), tmp10, Var) ;
 
 
 }
 void Parser_register_global(Parser* p, string name, string typ) {
 
_PUSH(& p ->table ->consts , ( (Var) { .name =  name , .typ =  typ , .is_const =  1 , .is_global =  1 , .pkg =  p ->pkg , .is_arg = 0 , .is_import_const = 0 , .args = new_array(0, 1, sizeof(Var)) , .attr = tos("", 0) , .is_mut = 0 , .ptr = 0 , .ref = 0 , .parent_fn = tos("", 0) , .line_nr = 0 , .is_used = 0 , .scope_level = 0 } ), tmp11, Var) ;
 
 
 }
 void Table_register_fn(Table* t, Fn f) {
 
 array_Fn tmp12 =  t ->fns;
 ;
for (int tmp13 = 0; tmp13 < tmp12 .len; tmp13 ++) {
 Fn ff = ((Fn *) tmp12.data)[tmp13];
 
 if (string_eq( ff .name , f .name ) ) {
 /*if*/

 
 return  ;
 
 }
 ;
 
 }
 ;
 
_PUSH(& t ->fns , ( f ), tmp14, Fn) ;
 
 
 }
 bool Table_known_type(Table* table, string typ) {
 
 if ( string_ends_with( typ , tos2("*") )  &&  ! string_contains( typ , tos2(" ") ) ) {
 /*if*/
 
 typ  =  string_left( typ , typ .len - 1 ) ;
 
 }
 ;
 
 array_Type tmp15 =  table ->types;
 ;
for (int tmp16 = 0; tmp16 < tmp15 .len; tmp16 ++) {
 Type t = ((Type *) tmp15.data)[tmp16];
 
 if (string_eq( t .name , typ )  &&  ! t .is_placeholder ) {
 /*if*/

 
 return  1 ;
 
 }
 ;
 
 }
 ;

 
 return  0 ;
 
 
 }
 Fn Table_find_fn(Table* t, string name) {
 
 array_Fn tmp17 =  t ->fns;
 ;
for (int tmp18 = 0; tmp18 < tmp17 .len; tmp18 ++) {
 Fn f = ((Fn *) tmp17.data)[tmp18];
 
 if (string_eq( f .name , name ) ) {
 /*if*/

 
 return  f ;
 
 }
 ;
 
 }
 ;

 
 return  (Fn) { .pkg = tos("", 0) , .local_vars = new_array(0, 1, sizeof(Var)) , .var_idx = 0 , .args = new_array(0, 1, sizeof(Var)) , .is_interface = 0 , .scope_level = 0 , .typ = tos("", 0) , .name = tos("", 0) , .is_c = 0 , .receiver_typ = tos("", 0) , .is_public = 0 , .is_method = 0 , .returns_error = 0 , .is_decl = 0 , .defer = tos("", 0) } ;
 
 
 }
 bool Table_known_fn(Table* t, string name) {
 
 array_Fn tmp19 =  t ->fns;
 ;
for (int tmp20 = 0; tmp20 < tmp19 .len; tmp20 ++) {
 Fn f = ((Fn *) tmp19.data)[tmp20];
 
 if (string_eq( f .name , name ) ) {
 /*if*/

 
 return  1 ;
 
 }
 ;
 
 }
 ;

 
 return  0 ;
 
 
 }
 bool Table_known_const(Table* t, string name) {
 
Var v= Table_find_const(& /* ? */* t , name ) ;

 
 return  v .name .len > 0 ;
 
 
 }
 void Table_register_type(Table* t, string typ) {
 
 if ( typ .len == 0 ) {
 /*if*/

 
 return  ;
 
 }
 ;
 
 array_Type tmp22 =  t ->types;
 ;
for (int tmp23 = 0; tmp23 < tmp22 .len; tmp23 ++) {
 Type typ2 = ((Type *) tmp22.data)[tmp23];
 
 if (string_eq( typ2 .name , typ ) ) {
 /*if*/

 
 return  ;
 
 }
 ;
 
 }
 ;
 
_PUSH(& t ->types , ( (Type) { .name =  typ , .pkg = tos("", 0) , .fields = new_array(0, 1, sizeof(Var)) , .methods = new_array(0, 1, sizeof(Fn)) , .parent = tos("", 0) , .gen_types = new_array(0, 1, sizeof(string)) , .is_c = 0 , .is_interface = 0 , .is_enum = 0 , .is_placeholder = 0 } ), tmp24, Type) ;
 
 
 }
 void Parser_register_type_with_parent(Parser* p, string strtyp, string parent) {
 
Type typ= (Type) { .name =  strtyp , .parent =  parent , .pkg =  p ->pkg , .fields = new_array(0, 1, sizeof(Var)) , .methods = new_array(0, 1, sizeof(Fn)) , .gen_types = new_array(0, 1, sizeof(string)) , .is_c = 0 , .is_interface = 0 , .is_enum = 0 , .is_placeholder = 0 } ;
 
 Table_register_type2( p ->table , typ ) ;
 
 
 }
 void Table_register_type_with_parent(Table* t, string typ, string parent) {
 
 if ( typ .len == 0 ) {
 /*if*/

 
 return  ;
 
 }
 ;
 
 array_Type tmp26 =  t ->types;
 ;
for (int tmp27 = 0; tmp27 < tmp26 .len; tmp27 ++) {
 Type typ2 = ((Type *) tmp26.data)[tmp27];
 
 if (string_eq( typ2 .name , typ ) ) {
 /*if*/

 
 return  ;
 
 }
 ;
 
 }
 ;
 
Type datyp= (Type) { .name =  typ , .parent =  parent , .pkg = tos("", 0) , .fields = new_array(0, 1, sizeof(Var)) , .methods = new_array(0, 1, sizeof(Fn)) , .gen_types = new_array(0, 1, sizeof(string)) , .is_c = 0 , .is_interface = 0 , .is_enum = 0 , .is_placeholder = 0 } ;
 
_PUSH(& t ->types , ( datyp ), tmp29, Type) ;
 
 
 }
 void Table_register_type2(Table* t, Type typ) {
 
 if ( typ .name .len == 0 ) {
 /*if*/

 
 return  ;
 
 }
 ;
 
 array_Type tmp30 =  t ->types;
 ;
for (int tmp31 = 0; tmp31 < tmp30 .len; tmp31 ++) {
 Type typ2 = ((Type *) tmp30.data)[tmp31];
 
 if (string_eq( typ2 .name , typ .name ) ) {
 /*if*/

 
 return  ;
 
 }
 ;
 
 }
 ;
 
_PUSH(& t ->types , ( typ ), tmp32, Type) ;
 
 
 }
 void Type_add_field(Type* t, string name, string typ, bool is_mut, string attr, AccessMod access_mod) {
 
Var v= (Var) { .name =  name , .typ =  typ , .is_mut =  is_mut , .attr =  attr , .access_mod =  access_mod , .is_arg = 0 , .is_const = 0 , .is_import_const = 0 , .args = new_array(0, 1, sizeof(Var)) , .ptr = 0 , .ref = 0 , .parent_fn = tos("", 0) , .pkg = tos("", 0) , .line_nr = 0 , .is_global = 0 , .is_used = 0 , .scope_level = 0 } ;
 
_PUSH(& t ->fields , ( v ), tmp34, Var) ;
 
 
 }
 bool Type_has_field(Type* t, string name) {
 
Var field= Type_find_field(& /* ? */* t , name ) ;

 
 return  (/*lpar*/string_ne( field .name , tos2("") ) ) ;
 
 
 }
 Var Type_find_field(Type* t, string name) {
 
 array_Var tmp36 =  t ->fields;
 ;
for (int tmp37 = 0; tmp37 < tmp36 .len; tmp37 ++) {
 Var field = ((Var *) tmp36.data)[tmp37];
 
 if (string_eq( field .name , name ) ) {
 /*if*/

 
 return  field ;
 
 }
 ;
 
 }
 ;

 
 return  (Var) { .typ = tos("", 0) , .name = tos("", 0) , .is_arg = 0 , .is_const = 0 , .is_import_const = 0 , .args = new_array(0, 1, sizeof(Var)) , .attr = tos("", 0) , .is_mut = 0 , .ptr = 0 , .ref = 0 , .parent_fn = tos("", 0) , .pkg = tos("", 0) , .line_nr = 0 , .is_global = 0 , .is_used = 0 , .scope_level = 0 } ;
 
 
 }
 bool Table_type_has_field(Table* table, Type* typ, string name) {
 
Var field= Table_find_field(& /* ? */* table , typ , name ) ;

 
 return  (/*lpar*/string_ne( field .name , tos2("") ) ) ;
 
 
 }
 Var Table_find_field(Table* table, Type* typ, string name) {
 
Var field= Type_find_field(& /* ? */* typ , name ) ;
 
 if ( field .name .len == 0  &&  typ ->parent .len > 0 ) {
 /*if*/
 
Type* parent= Table_find_type(& /* ? */* table , typ ->parent ) ;

 
 return  Type_find_field(& /* ? */* parent , name ) ;
 
 }
 ;

 
 return  field ;
 
 
 }
 void Type_add_method(Type* t, Fn f) {
 
_PUSH(& t ->methods , ( f ), tmp41, Fn) ;
 
 
 }
 bool Type_has_method(Type* t, string name) {
 
Fn method= Type_find_method(& /* ? */* t , name ) ;

 
 return  (/*lpar*/string_ne( method .name , tos2("") ) ) ;
 
 
 }
 bool Table_type_has_method(Table* table, Type* typ, string name) {
 
Fn method= Table_find_method(& /* ? */* table , typ , name ) ;

 
 return  (/*lpar*/string_ne( method .name , tos2("") ) ) ;
 
 
 }
 Fn Table_find_method(Table* table, Type* typ, string name) {
 
Fn method= Type_find_method(& /* ? */* typ , name ) ;
 
 if ( method .name .len == 0  &&  typ ->parent .len > 0 ) {
 /*if*/
 
Type* parent= Table_find_type(& /* ? */* table , typ ->parent ) ;

 
 return  Type_find_method(& /* ? */* parent , name ) ;
 
 }
 ;

 
 return  method ;
 
 
 }
 Fn Type_find_method(Type* t, string name) {
 
 array_Fn tmp46 =  t ->methods;
 ;
for (int tmp47 = 0; tmp47 < tmp46 .len; tmp47 ++) {
 Fn method = ((Fn *) tmp46.data)[tmp47];
 
 if (string_eq( method .name , name ) ) {
 /*if*/

 
 return  method ;
 
 }
 ;
 
 }
 ;

 
 return  (Fn) { .pkg = tos("", 0) , .local_vars = new_array(0, 1, sizeof(Var)) , .var_idx = 0 , .args = new_array(0, 1, sizeof(Var)) , .is_interface = 0 , .scope_level = 0 , .typ = tos("", 0) , .name = tos("", 0) , .is_c = 0 , .receiver_typ = tos("", 0) , .is_public = 0 , .is_method = 0 , .returns_error = 0 , .is_decl = 0 , .defer = tos("", 0) } ;
 
 
 }
 void Type_add_gen_type(Type* t, string type_name) {
 
 if ( array_string_contains( t ->gen_types , type_name ) ) {
 /*if*/

 
 return  ;
 
 }
 ;
 
_PUSH(& t ->gen_types , ( type_name ), tmp48, string) ;
 
 
 }
 Type* Parser_find_type(Parser* p, string name) {
 
Type* typ= Table_find_type(& /* ? */* p ->table , name ) ;
 
 if ( typ ->name .len == 0 ) {
 /*if*/

 
 return  Table_find_type(& /* ? */* p ->table , Parser_prepend_pkg(& /* ? */* p , name ) ) ;
 
 }
 ;

 
 return  typ ;
 
 
 }
 Type* Table_find_type(Table* t, string name) {
 
 if ( string_ends_with( name , tos2("*") )  &&  ! string_contains( name , tos2(" ") ) ) {
 /*if*/
 
 name  =  string_left( name , name .len - 1 ) ;
 
 }
 ;
 
 array_Type tmp50 =  t ->types ;
 ;
for (int i = 0; i < tmp50 .len; i ++) {
 Type typ = ((Type *) tmp50 . data)[i];
 
 if (string_eq( typ .name , name ) ) {
 /*if*/

 
 return  & /*vvar*/  ( *(Type*) array__get( t ->types , i) ) ;
 
 }
 ;
 
 }
 ;

 
 return  ALLOC_INIT(Type, { .pkg = tos("", 0) , .name = tos("", 0) , .fields = new_array(0, 1, sizeof(Var)) , .methods = new_array(0, 1, sizeof(Fn)) , .parent = tos("", 0) , .gen_types = new_array(0, 1, sizeof(string)) , .is_c = 0 , .is_interface = 0 , .is_enum = 0 , .is_placeholder = 0 } ) ;
 
 
 }
 bool Parser__check_types(Parser* p, string got, string expected, bool throw) {
 
 Parser_log(& /* ? */* p , _STR("check types got=\"%.*s\" exp=\"%.*s\"  ", got.len, got.str, expected.len, expected.str) ) ;
 
 if ( p ->translated ) {
 /*if*/

 
 return  1 ;
 
 }
 ;
 
 if (string_eq( got , tos2("int") )  && string_eq( expected , tos2("f32") ) ) {
 /*if*/

 
 return  1 ;
 
 }
 ;
 
 if (string_eq( got , tos2("int") )  && string_eq( expected , tos2("f64") ) ) {
 /*if*/

 
 return  1 ;
 
 }
 ;
 
 if (string_eq( got , tos2("f64") )  && string_eq( expected , tos2("f32") ) ) {
 /*if*/

 
 return  1 ;
 
 }
 ;
 
 if (string_eq( got , tos2("f32") )  && string_eq( expected , tos2("f64") ) ) {
 /*if*/

 
 return  1 ;
 
 }
 ;
 
 if (string_eq( got , tos2("int") )  && string_eq( expected , tos2("i64") ) ) {
 /*if*/

 
 return  1 ;
 
 }
 ;
 
 if (string_eq( got , tos2("void*") )  &&  string_starts_with( expected , tos2("fn ") ) ) {
 /*if*/

 
 return  1 ;
 
 }
 ;
 
 if ( string_starts_with( got , tos2("[") )  && string_eq( expected , tos2("byte*") ) ) {
 /*if*/

 
 return  1 ;
 
 }
 ;
 
 if (string_eq( got , tos2("void*") )  || string_eq( expected , tos2("void*") ) ) {
 /*if*/
 
 if ( p ->is_play ) {
 /*if*/

 
 return  0 ;
 
 }
 ;

 
 return  1 ;
 
 }
 ;
 
 if (string_eq( got , tos2("int") )  && string_eq( expected , tos2("byte") ) ) {
 /*if*/

 
 return  1 ;
 
 }
 ;
 
 if (string_eq( got , tos2("byteptr") )  && string_eq( expected , tos2("byte*") ) ) {
 /*if*/

 
 return  1 ;
 
 }
 ;
 
 if (string_eq( got , tos2("int") )  && string_eq( expected , tos2("byte*") ) ) {
 /*if*/

 
 return  1 ;
 
 }
 ;
 
 if (string_eq( got , tos2("int") )  && string_eq( expected , tos2("byteptr") ) ) {
 /*if*/

 
 return  1 ;
 
 }
 ;
 
 if (string_eq( got , tos2("Option") )  &&  string_starts_with( expected , tos2("Option_") ) ) {
 /*if*/

 
 return  1 ;
 
 }
 ;
 
 if (string_eq( got , tos2("array") )  &&  string_starts_with( expected , tos2("array_") ) ) {
 /*if*/

 
 return  1 ;
 
 }
 ;
 
 if ( string_starts_with( expected , tos2("Option_") )  &&  string_ends_with( expected , got ) ) {
 /*if*/

 
 return  1 ;
 
 }
 ;
 
 if ( ! p ->is_play ) {
 /*if*/
 
 if ( string_ends_with( expected , tos2("*") )  && string_eq( got , tos2("int") ) ) {
 /*if*/

 
 return  1 ;
 
 }
 ;
 
 if (string_eq( expected , tos2("void*") )  && string_eq( got , tos2("int") ) ) {
 /*if*/

 
 return  1 ;
 
 }
 ;
 
 }
 ;
 
 expected  =  string_replace( expected , tos2("*") , tos2("") ) ;
 
 got  =  string_replace( got , tos2("*") , tos2("") ) ;
 
 if (string_ne( got , expected ) ) {
 /*if*/
 
 if ( string_ends_with( expected , tos2("er") ) ) {
 /*if*/
 
 if ( Parser_satisfies_interface( p , expected , got , throw ) ) {
 /*if*/

 
 return  1 ;
 
 }
 ;
 
 }
 ;
 
 if ( ! throw ) {
 /*if*/

 
 return  0 ;
 
 }
  else { 
 /*else if*/
 
 Parser_error( p , _STR("expected type `%.*s`, but got `%.*s`", expected.len, expected.str, got.len, got.str) ) ;
 
 }
 ;
 
 }
 ;

 
 return  1 ;
 
 
 }
 bool Parser_check_types(Parser* p, string got, string expected) {

 
 return  Parser__check_types( p , got , expected , 1 ) ;
 
 
 }
 bool Parser_check_types_no_throw(Parser* p, string got, string expected) {

 
 return  Parser__check_types( p , got , expected , 0 ) ;
 
 
 }
 bool Parser_satisfies_interface(Parser* p, string interface_name, string _typ, bool throw) {
 
Type* int_typ= Table_find_type(& /* ? */* p ->table , interface_name ) ;
 
Type* typ= Table_find_type(& /* ? */* p ->table , _typ ) ;
 
 array_Fn tmp55 =  int_typ ->methods;
 ;
for (int tmp56 = 0; tmp56 < tmp55 .len; tmp56 ++) {
 Fn method = ((Fn *) tmp55.data)[tmp56];
 
 if ( ! Type_has_method(& /* ? */* typ , method .name ) ) {
 /*if*/
 
 Parser_error( p , _STR("Type \"%.*s\" doesn\'t satisfy interface \"%.*s\" (method \"%.*s\" is not implemented)", _typ.len, _typ.str, interface_name.len, interface_name.str, method .name.len, method .name.str) ) ;

 
 return  0 ;
 
 }
 ;
 
 }
 ;

 
 return  1 ;
 
 
 }
 string type_default(string typ) {
 
 if ( string_starts_with( typ , tos2("array_") ) ) {
 /*if*/
 
 typ  =  string_right( typ , 6 ) ;

 
 return  _STR("new_array(0, 1, sizeof(%.*s))", typ.len, typ.str) ;
 
 }
 ;
 
 if ( string_ends_with( typ , tos2("*") ) ) {
 /*if*/

 
 return  tos2("0") ;
 
 }
 ;
 
 if ( string_contains( typ , tos2("__") ) ) {
 /*if*/

 
 return  tos2("") ;
 
 }
 ;
 
 if ( string_eq( typ,  tos2("int") )) { /* case */

 
 return  tos2("0") ;
 
 }
 else  if ( string_eq( typ,  tos2("string") )) { /* case */

 
 return  tos2("tos(\"\", 0)") ;
 
 }
 else  if ( string_eq( typ,  tos2("void*") )) { /* case */

 
 return  tos2("0") ;
 
 }
 else  if ( string_eq( typ,  tos2("byte*") )) { /* case */

 
 return  tos2("0") ;
 
 }
 else  if ( string_eq( typ,  tos2("bool") )) { /* case */

 
 return  tos2("0") ;
 
 }
 ;

 
 return  tos2("") ;
 
 
 }
 bool Table_is_interface(Table* t, string name) {
 
 array_Type tmp57 =  t ->types;
 ;
for (int tmp58 = 0; tmp58 < tmp57 .len; tmp58 ++) {
 Type typ = ((Type *) tmp57.data)[tmp58];
 
 if ( typ .is_interface  && string_eq( typ .name , name ) ) {
 /*if*/

 
 return  1 ;
 
 }
 ;
 
 }
 ;

 
 return  0 ;
 
 
 }
 bool Table_main_exists(Table* t) {
 
 array_Fn tmp59 =  t ->fns;
 ;
for (int tmp60 = 0; tmp60 < tmp59 .len; tmp60 ++) {
 Fn f = ((Fn *) tmp59.data)[tmp60];
 
 if (string_eq( f .name , tos2("main") ) ) {
 /*if*/

 
 return  1 ;
 
 }
 ;
 
 }
 ;

 
 return  0 ;
 
 
 }
 Var Table_find_const(Table* t, string name) {
 
 array_Var tmp61 =  t ->consts;
 ;
for (int tmp62 = 0; tmp62 < tmp61 .len; tmp62 ++) {
 Var c = ((Var *) tmp61.data)[tmp62];
 
 if (string_eq( c .name , name ) ) {
 /*if*/

 
 return  c ;
 
 }
 ;
 
 }
 ;

 
 return  (Var) { .typ = tos("", 0) , .name = tos("", 0) , .is_arg = 0 , .is_const = 0 , .is_import_const = 0 , .args = new_array(0, 1, sizeof(Var)) , .attr = tos("", 0) , .is_mut = 0 , .ptr = 0 , .ref = 0 , .parent_fn = tos("", 0) , .pkg = tos("", 0) , .line_nr = 0 , .is_global = 0 , .is_used = 0 , .scope_level = 0 } ;
 
 
 }
 string Table_cgen_name(Table* table, Fn* f) {
 
string name= f ->name ;
 
 if ( f ->is_method ) {
 /*if*/
 
 name  =  _STR("%.*s_%.*s", f ->receiver_typ.len, f ->receiver_typ.str, f ->name.len, f ->name.str) ;
 
 name  =  string_replace( name , tos2(" ") , tos2("") ) ;
 
 name  =  string_replace( name , tos2("*") , tos2("") ) ;
 
 name  =  string_replace( name , tos2("+") , tos2("plus") ) ;
 
 name  =  string_replace( name , tos2("-") , tos2("minus") ) ;
 
 }
 ;
 
 if (string_eq( f ->pkg , tos2("builtin") )  &&  array_string_contains( main__CReserved , f ->name ) ) {
 /*if*/

 
 return  _STR("v_%.*s", name.len, name.str) ;
 
 }
 ;
 
 if ( table ->obfuscate  && string_ne( f ->name , tos2("main") )  && string_ne( f ->name , tos2("WinMain") )  && string_ne( f ->pkg , tos2("builtin") )  &&  ! f ->is_c  && string_ne( f ->pkg , tos2("darwin") )  && string_ne( f ->pkg , tos2("os") )  &&  ! string_contains( f ->name , tos2("window_proc") )  && string_ne( f ->name , tos2("gg__vec2") )  && string_ne( f ->name , tos2("build_token_str") )  && string_ne( f ->name , tos2("build_keys") )  && string_ne( f ->pkg , tos2("json") )  &&  ! string_ends_with( name , tos2("_str") )  &&  ! string_contains( name , tos2("contains") ) ) {
 /*if*/
int tmp64 = 0; bool tmp65 = map_get( table ->obf_ids , name, & tmp64);
 
int idx= tmp64 ;
 
 if ( idx == 0 ) {
 /*if*/
 
 table ->fn_cnt ++ ;
int tmp67 =  table ->fn_cnt;
 
map__set(& table ->obf_ids , name , & tmp67) ;
 
 idx  =  table ->fn_cnt ;
 
 }
 ;
 
string old= name ;
 
 name  =  _STR("f_%d", idx) ;
 
 println ( _STR("%.*s ==> %.*s", old.len, old.str, name.len, name.str) ) ;
 
 }
 ;

 
 return  name ;
 
 
 }
 string Table_cgen_name_type_pair(Table* table, string name, string typ) {
 
 if ( typ .len > 0  &&  string_at( typ , 0) == '[' ) {
 /*if*/
 
string tmp= string_all_after( typ , tos2("]") ) ;
 
string size= string_all_before( typ , tos2("]") ) ;

 
 return  _STR("%.*s %.*s  %.*s ]", tmp.len, tmp.str, name.len, name.str, size.len, size.str) ;
 
 }
  else  if ( string_starts_with( typ , tos2("fn (") ) ) {
 /*if*/
 
Type* T= Table_find_type(& /* ? */* table , typ ) ;
 
 if (string_eq( T ->name , tos2("") ) ) {
 /*if*/
 
 println ( tos2("this should never happen") ) ;
 
 v_exit ( 1 ) ;
 
 }
 ;
 
string str_args= Fn_str_args(& /* ? */ T ->func , table ) ;

 
 return  _STR("%.*s (*%.*s)( %.*s /*FFF*/ )", T ->func .typ.len, T ->func .typ.str, name.len, name.str, str_args.len, str_args.str) ;
 
 }
  else  if (string_eq( typ , tos2("tm") ) ) {
 /*if*/

 
 return  _STR("struct /*TM*/ tm %.*s", name.len, name.str) ;
 
 }
 ;

 
 return  _STR("%.*s %.*s", typ.len, typ.str, name.len, name.str) ;
 
 
 }
 map_int build_keys() {
 
map_int res= new_map(1, sizeof(int)) ;
 
 for (
int t= ((int)( keyword_beg ) ) + 1  ;  t < ((int)( keyword_end ) )  ;  t ++ ) { 
 
string key= ( *(string*) array__get( main__TOKENSTR , t) ) ;
int tmp6 =  ((int)( t ) );
 
map__set(& res , key , & tmp6) ;
 
 }
 ;

 
 return  res ;
 
 
 }
 array_string build_token_str() {
string tmp7 =  tos2("");
 
array_string s= array_repeat(&tmp7,  140 , sizeof(string) ) ;
string tmp9 =  tos2("");
 
array_set(&/*q*/ s , keyword_beg , & tmp9) ;
string tmp10 =  tos2("");
 
array_set(&/*q*/ s , keyword_end , & tmp10) ;
string tmp11 =  tos2("EOF");
 
array_set(&/*q*/ s , EOF , & tmp11) ;
string tmp12 =  tos2("NAME");
 
array_set(&/*q*/ s , NAME , & tmp12) ;
string tmp13 =  tos2("INT");
 
array_set(&/*q*/ s , INT , & tmp13) ;
string tmp14 =  tos2("STR");
 
array_set(&/*q*/ s , STRING , & tmp14) ;
string tmp15 =  tos2("CHAR");
 
array_set(&/*q*/ s , CHAR , & tmp15) ;
string tmp16 =  tos2("+");
 
array_set(&/*q*/ s , PLUS , & tmp16) ;
string tmp17 =  tos2("-");
 
array_set(&/*q*/ s , MINUS , & tmp17) ;
string tmp18 =  tos2("*");
 
array_set(&/*q*/ s , MUL , & tmp18) ;
string tmp19 =  tos2("/");
 
array_set(&/*q*/ s , DIV , & tmp19) ;
string tmp20 =  tos2("%");
 
array_set(&/*q*/ s , MOD , & tmp20) ;
string tmp21 =  tos2("^");
 
array_set(&/*q*/ s , XOR , & tmp21) ;
string tmp22 =  tos2("~");
 
array_set(&/*q*/ s , BIT_NOT , & tmp22) ;
string tmp23 =  tos2("|");
 
array_set(&/*q*/ s , PIPE , & tmp23) ;
string tmp24 =  tos2("#");
 
array_set(&/*q*/ s , HASH , & tmp24) ;
string tmp25 =  tos2("&");
 
array_set(&/*q*/ s , AMP , & tmp25) ;
string tmp26 =  tos2("++");
 
array_set(&/*q*/ s , INC , & tmp26) ;
string tmp27 =  tos2("--");
 
array_set(&/*q*/ s , DEC , & tmp27) ;
string tmp28 =  tos2("&&");
 
array_set(&/*q*/ s , AND , & tmp28) ;
string tmp29 =  tos2("||");
 
array_set(&/*q*/ s , OR , & tmp29) ;
string tmp30 =  tos2("!");
 
array_set(&/*q*/ s , NOT , & tmp30) ;
string tmp31 =  tos2(".");
 
array_set(&/*q*/ s , DOT , & tmp31) ;
string tmp32 =  tos2("..");
 
array_set(&/*q*/ s , DOTDOT , & tmp32) ;
string tmp33 =  tos2(",");
 
array_set(&/*q*/ s , COMMA , & tmp33) ;
string tmp34 =  tos2(";");
 
array_set(&/*q*/ s , SEMICOLON , & tmp34) ;
string tmp35 =  tos2(":");
 
array_set(&/*q*/ s , COLON , & tmp35) ;
string tmp36 =  tos2("=");
 
array_set(&/*q*/ s , ASSIGN , & tmp36) ;
string tmp37 =  tos2(":=");
 
array_set(&/*q*/ s , DECL_ASSIGN , & tmp37) ;
string tmp38 =  tos2("+=");
 
array_set(&/*q*/ s , PLUS_ASSIGN , & tmp38) ;
string tmp39 =  tos2("-=");
 
array_set(&/*q*/ s , MINUS_ASSIGN , & tmp39) ;
string tmp40 =  tos2("*=");
 
array_set(&/*q*/ s , MULT_ASSIGN , & tmp40) ;
string tmp41 =  tos2("/=");
 
array_set(&/*q*/ s , DIV_ASSIGN , & tmp41) ;
string tmp42 =  tos2("^=");
 
array_set(&/*q*/ s , XOR_ASSIGN , & tmp42) ;
string tmp43 =  tos2("%=");
 
array_set(&/*q*/ s , MOD_ASSIGN , & tmp43) ;
string tmp44 =  tos2("|=");
 
array_set(&/*q*/ s , OR_ASSIGN , & tmp44) ;
string tmp45 =  tos2("&=");
 
array_set(&/*q*/ s , AND_ASSIGN , & tmp45) ;
string tmp46 =  tos2(">>=");
 
array_set(&/*q*/ s , RIGHT_SHIFT_ASSIGN , & tmp46) ;
string tmp47 =  tos2("<<=");
 
array_set(&/*q*/ s , LEFT_SHIFT_ASSIGN , & tmp47) ;
string tmp48 =  tos2("{");
 
array_set(&/*q*/ s , LCBR , & tmp48) ;
string tmp49 =  tos2("}");
 
array_set(&/*q*/ s , RCBR , & tmp49) ;
string tmp50 =  tos2("(");
 
array_set(&/*q*/ s , LPAR , & tmp50) ;
string tmp51 =  tos2(")");
 
array_set(&/*q*/ s , RPAR , & tmp51) ;
string tmp52 =  tos2("[");
 
array_set(&/*q*/ s , LSBR , & tmp52) ;
string tmp53 =  tos2("]");
 
array_set(&/*q*/ s , RSBR , & tmp53) ;
string tmp54 =  tos2("==");
 
array_set(&/*q*/ s , EQ , & tmp54) ;
string tmp55 =  tos2("!=");
 
array_set(&/*q*/ s , NE , & tmp55) ;
string tmp56 =  tos2(">");
 
array_set(&/*q*/ s , GT , & tmp56) ;
string tmp57 =  tos2("<");
 
array_set(&/*q*/ s , LT , & tmp57) ;
string tmp58 =  tos2(">=");
 
array_set(&/*q*/ s , GE , & tmp58) ;
string tmp59 =  tos2("<=");
 
array_set(&/*q*/ s , LE , & tmp59) ;
string tmp60 =  tos2("?");
 
array_set(&/*q*/ s , QUESTION , & tmp60) ;
string tmp61 =  tos2("<<");
 
array_set(&/*q*/ s , LEFT_SHIFT , & tmp61) ;
string tmp62 =  tos2(">>");
 
array_set(&/*q*/ s , RIGHT_SHIFT , & tmp62) ;
string tmp63 =  tos2("//");
 
array_set(&/*q*/ s , LINE_COM , & tmp63) ;
string tmp64 =  tos2("NLL");
 
array_set(&/*q*/ s , NL , & tmp64) ;
string tmp65 =  tos2("$");
 
array_set(&/*q*/ s , DOLLAR , & tmp65) ;
string tmp66 =  tos2("assert");
 
array_set(&/*q*/ s , ASSERT , & tmp66) ;
string tmp67 =  tos2("struct");
 
array_set(&/*q*/ s , STRUCT , & tmp67) ;
string tmp68 =  tos2("if");
 
array_set(&/*q*/ s , IF , & tmp68) ;
string tmp69 =  tos2("else");
 
array_set(&/*q*/ s , ELSE , & tmp69) ;
string tmp70 =  tos2("return");
 
array_set(&/*q*/ s , RETURN , & tmp70) ;
string tmp71 =  tos2("module");
 
array_set(&/*q*/ s , PACKAGE , & tmp71) ;
string tmp72 =  tos2("sizeof");
 
array_set(&/*q*/ s , SIZEOF , & tmp72) ;
string tmp73 =  tos2("go");
 
array_set(&/*q*/ s , GO , & tmp73) ;
string tmp74 =  tos2("goto");
 
array_set(&/*q*/ s , GOTO , & tmp74) ;
string tmp75 =  tos2("const");
 
array_set(&/*q*/ s , CONST , & tmp75) ;
string tmp76 =  tos2("mut");
 
array_set(&/*q*/ s , MUT , & tmp76) ;
string tmp77 =  tos2("type");
 
array_set(&/*q*/ s , TIP , & tmp77) ;
string tmp78 =  tos2("for");
 
array_set(&/*q*/ s , FOR , & tmp78) ;
string tmp79 =  tos2("switch");
 
array_set(&/*q*/ s , SWITCH , & tmp79) ;
string tmp80 =  tos2("match");
 
array_set(&/*q*/ s , MATCH , & tmp80) ;
string tmp81 =  tos2("case");
 
array_set(&/*q*/ s , CASE , & tmp81) ;
string tmp82 =  tos2("fn");
 
array_set(&/*q*/ s , FUNC , & tmp82) ;
string tmp83 =  tos2("true");
 
array_set(&/*q*/ s , TRUE , & tmp83) ;
string tmp84 =  tos2("false");
 
array_set(&/*q*/ s , FALSE , & tmp84) ;
string tmp85 =  tos2("continue");
 
array_set(&/*q*/ s , CONTINUE , & tmp85) ;
string tmp86 =  tos2("break");
 
array_set(&/*q*/ s , BREAK , & tmp86) ;
string tmp87 =  tos2("import");
 
array_set(&/*q*/ s , IMPORT , & tmp87) ;
string tmp88 =  tos2("embed");
 
array_set(&/*q*/ s , EMBED , & tmp88) ;
string tmp89 =  tos2("typeof");
 
array_set(&/*q*/ s , TYPEOF , & tmp89) ;
string tmp90 =  tos2("default");
 
array_set(&/*q*/ s , DEFAULT , & tmp90) ;
string tmp91 =  tos2("endif");
 
array_set(&/*q*/ s , ENDIF , & tmp91) ;
string tmp92 =  tos2("enum");
 
array_set(&/*q*/ s , ENUM , & tmp92) ;
string tmp93 =  tos2("interface");
 
array_set(&/*q*/ s , INTERFACE , & tmp93) ;
string tmp94 =  tos2("pub");
 
array_set(&/*q*/ s , PUB , & tmp94) ;
string tmp95 =  tos2("import_const");
 
array_set(&/*q*/ s , IMPORT_CONST , & tmp95) ;
string tmp96 =  tos2("in");
 
array_set(&/*q*/ s , IN , & tmp96) ;
string tmp97 =  tos2("atomic");
 
array_set(&/*q*/ s , ATOMIC , & tmp97) ;
string tmp98 =  tos2("or");
 
array_set(&/*q*/ s , OR_ELSE , & tmp98) ;
string tmp99 =  tos2("__global");
 
array_set(&/*q*/ s , GLOBAL , & tmp99) ;
string tmp100 =  tos2("union");
 
array_set(&/*q*/ s , UNION , & tmp100) ;
string tmp101 =  tos2("static");
 
array_set(&/*q*/ s , STATIC , & tmp101) ;

 
 return  s ;
 
 
 }
 Token key_to_token(string key) {
int tmp102 = 0; bool tmp103 = map_get( main__KEYWORDS , key, & tmp102);
 
Token a= ((Token)( tmp102 ) ) ;

 
 return  a ;
 
 
 }
 bool is_key(string key) {

 
 return  ((int)( key_to_token ( key ) ) ) > 0 ;
 
 
 }
 string Token_str(Token t) {

 
 return  ( *(string*) array__get( main__TOKENSTR , ((int)( t ) )) ) ;
 
 
 }
 bool Token_is_decl(Token t) {

 
 return  t == ENUM  ||  t == INTERFACE  ||  t == FUNC  ||  t == STRUCT  ||  t == TIP  ||  t == CONST  ||  t == IMPORT_CONST  ||  t == PUB  ||  t == EOF ;
 
 
 }
 bool Token_is_assign(Token t) {

 
 return _IN(Token,  t ,  main__AssignTokens ) ;
 
 
 }
 bool array_Token_contains(array_Token t, Token val) {
 
 array_Token tmp107 =  t;
 ;
for (int tmp108 = 0; tmp108 < tmp107 .len; tmp108 ++) {
 Token tt = ((Token *) tmp107.data)[tmp108];
 
 if ( tt == val ) {
 /*if*/

 
 return  1 ;
 
 }
 ;
 
 }
 ;

 
 return  0 ;
 
 
 }
 void init_consts() { g_str_buf=malloc(1000); os__args = new_array_from_c_array(0, 0, sizeof(string), (string[]) {   });
time__Months =  tos2("JanFebMarAprMayJunJulAugSepOctNovDec");
time__Days =  tos2("MonTueWedThuFriSatSun");
main__Version =  tos2("0.1.9");
main__SupportedPlatforms = new_array_from_c_array(3, 3, sizeof(string), (string[]) {  tos2("windows") , tos2("mac") , tos2("linux")  });
main__TmpPath =  vtmp_path ( );
main__HelpText =  tos2("\nUsage: v [options] [file | directory]\n\nOptions:\n  -                 Read from stdin (Default; Interactive mode if in a tty)\n  -h, --help, help  Display this information.\n  -v, version       Display compiler version.\n  -prod             Build an optimized executable.\n  -o <file>         Place output into <file>.\n  -obf              Obfuscate the resulting binary.\n  run               Build and execute a V program.\n                    You can add arguments after file name.\n\nFiles:\n  <file>_test.v     Test file.\n");
main__EmptyFn =  ALLOC_INIT(Fn, { .pkg = tos("", 0) , .local_vars = new_array(0, 1, sizeof(Var)) , .var_idx = 0 , .args = new_array(0, 1, sizeof(Var)) , .is_interface = 0 , .scope_level = 0 , .typ = tos("", 0) , .name = tos("", 0) , .is_c = 0 , .receiver_typ = tos("", 0) , .is_public = 0 , .is_method = 0 , .returns_error = 0 , .is_decl = 0 , .defer = tos("", 0) } );
main__MainFn =  ALLOC_INIT(Fn, { .name =  tos2("main") , .pkg = tos("", 0) , .local_vars = new_array(0, 1, sizeof(Var)) , .var_idx = 0 , .args = new_array(0, 1, sizeof(Var)) , .is_interface = 0 , .scope_level = 0 , .typ = tos("", 0) , .is_c = 0 , .receiver_typ = tos("", 0) , .is_public = 0 , .is_method = 0 , .returns_error = 0 , .is_decl = 0 , .defer = tos("", 0) } );
main__CReserved = new_array_from_c_array(10, 10, sizeof(string), (string[]) {  tos2("exit") , tos2("unix") , tos2("print") , tos2("error") , tos2("malloc") , tos2("calloc") , tos2("char") , tos2("free") , tos2("panic") , tos2("register")  });
main__NUMBER_TYPES = new_array_from_c_array(13, 13, sizeof(string), (string[]) {  tos2("number") , tos2("int") , tos2("i8") , tos2("u8") , tos2("i16") , tos2("u16") , tos2("i32") , tos2("u32") , tos2("byte") , tos2("i64") , tos2("u64") , tos2("f32") , tos2("f64")  });
main__FLOAT_TYPES = new_array_from_c_array(2, 2, sizeof(string), (string[]) {  tos2("f32") , tos2("f64")  });
main__TOKENSTR =  build_token_str ( );
main__KEYWORDS =  build_keys ( );
main__AssignTokens = new_array_from_c_array(11, 11, sizeof(Token), (Token[]) {  ASSIGN , PLUS_ASSIGN , MINUS_ASSIGN , MULT_ASSIGN , DIV_ASSIGN , XOR_ASSIGN , MOD_ASSIGN , OR_ASSIGN , AND_ASSIGN , RIGHT_SHIFT_ASSIGN , LEFT_SHIFT_ASSIGN  }); }
 
string _STR(const char *fmt, ...) {
	va_list argptr;
	va_start(argptr, fmt);
	size_t len = vsnprintf(0, 0, fmt, argptr) + 1;  
	va_end(argptr);
	byte* buf = malloc(len);  
	va_start(argptr, fmt);
	vsprintf(buf, fmt, argptr);
	va_end(argptr);
#ifdef DEBUG_ALLOC 
	puts("_STR:"); 
	puts(buf); 
#endif 
	return tos2(buf);
}

string _STR_TMP(const char *fmt, ...) {
	va_list argptr;
	va_start(argptr, fmt);
	size_t len = vsnprintf(0, 0, fmt, argptr) + 1;  
	va_end(argptr);
	va_start(argptr, fmt);
	vsprintf(g_str_buf, fmt, argptr);
	va_end(argptr);
#ifdef DEBUG_ALLOC 
	//puts("_STR_TMP:"); 
	//puts(g_str_buf); 
#endif 
	return tos2(g_str_buf);
}


