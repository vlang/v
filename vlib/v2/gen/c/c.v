// Copyright (c) 2026 Alexander Medvednikov. All rights reserved.
// Use of this source code is governed by an MIT license
// that can be found in the LICENSE file.

module c

import v2.ssa
import strings

pub struct Gen {
	mod &ssa.Module
mut:
	sb strings.Builder
}

pub fn Gen.new(mod &ssa.Module) &Gen {
	return &Gen{
		mod: mod
		sb:  strings.new_builder(4096)
	}
}

pub fn (mut g Gen) gen() string {
	g.sb.writeln('// Generated by V SSA Compiler')
	g.sb.writeln('#include <stdint.h>')
	g.sb.writeln('#include <stdbool.h>')
	g.sb.writeln('#include <stddef.h>')
	g.sb.writeln('#include <stdio.h>')
	g.sb.writeln('')

	g.gen_struct_decls()
	g.gen_globals()
	g.gen_func_decls()

	for func in g.mod.funcs {
		g.gen_func(func)
	}

	return g.sb.str()
}

fn (mut g Gen) gen_func_decls() {
	// Forward declarations for all functions
	for func in g.mod.funcs {
		ret_type := g.type_name(func.typ)
		mut params := []string{}
		for pid in func.params {
			val := g.mod.values[pid]
			tname := g.type_name(val.typ)
			params << '${tname} ${val.name}'
		}
		param_str := params.join(', ')
		g.sb.writeln('${ret_type} ${func.name}(${param_str});')
	}
	g.sb.writeln('')
}

fn (mut g Gen) gen_struct_decls() {
	for i, t in g.mod.type_store.types {
		if t.kind == .struct_t {
			g.sb.writeln('typedef struct Struct_${i} Struct_${i};')
		}
	}
	g.sb.writeln('')

	for i, t in g.mod.type_store.types {
		if t.kind == .struct_t {
			g.sb.writeln('struct Struct_${i} {')
			for idx, field_id in t.fields {
				type_name := g.type_name(field_id)
				g.sb.writeln('\t${type_name} field_${idx};')
			}
			g.sb.writeln('};')
		}
	}
	g.sb.writeln('')
}

fn (mut g Gen) gen_globals() {
	for gvar in g.mod.globals {
		tname := g.type_name(gvar.typ)
		g.sb.writeln('${tname} ${gvar.name};')
	}
}

fn (mut g Gen) gen_func(func ssa.Function) {
	ret_type := g.type_name(func.typ)

	mut params := []string{}
	for pid in func.params {
		val := g.mod.values[pid]
		tname := g.type_name(val.typ)
		params << '${tname} ${val.name}'
	}
	param_str := params.join(', ')

	g.sb.writeln('${ret_type} ${func.name}(${param_str}) {')

	for blk_id in func.blocks {
		blk := g.mod.blocks[blk_id]
		for instr_val_id in blk.instrs {
			val := g.mod.values[instr_val_id]
			if g.mod.type_store.types[val.typ].kind != .void_t {
				tname := g.type_name(val.typ)
				g.sb.writeln('\t${tname} _v${val.id};')
			}
		}
	}

	for blk_id in func.blocks {
		blk := g.mod.blocks[blk_id]
		g.sb.writeln('${blk.name}:;')

		for instr_val_id in blk.instrs {
			g.gen_instr(instr_val_id)
		}
	}
	g.sb.writeln('}')
	g.sb.writeln('')
}

fn (mut g Gen) gen_instr(val_id int) {
	val := g.mod.values[val_id]
	instr := g.mod.instrs[val.index]

	res := '_v${val.id}'

	match instr.op {
		.add, .sub, .mul, .sdiv, .udiv, .srem, .urem {
			op := g.op_sym(instr.op)
			lhs := g.val_str(instr.operands[0])
			rhs := g.val_str(instr.operands[1])
			g.sb.writeln('\t${res} = ${lhs} ${op} ${rhs};')
		}
		.and_, .or_, .xor {
			op := match instr.op {
				.and_ { '&' }
				.or_ { '|' }
				.xor { '^' }
				else { '?' }
			}
			lhs := g.val_str(instr.operands[0])
			rhs := g.val_str(instr.operands[1])
			g.sb.writeln('\t${res} = ${lhs} ${op} ${rhs};')
		}
		.shl, .lshr, .ashr {
			op := match instr.op {
				.shl { '<<' }
				.lshr { '>>' }
				.ashr { '>>' }
				else { '?' }
			}
			lhs := g.val_str(instr.operands[0])
			rhs := g.val_str(instr.operands[1])
			g.sb.writeln('\t${res} = ${lhs} ${op} ${rhs};')
		}
		.assign {
			// Phi elimination copy: dest = src
			dest_val := instr.operands[0]
			src_val := instr.operands[1]
			dest := '_v${dest_val}'
			src := g.val_str(src_val)
			g.sb.writeln('\t${dest} = ${src};')
		}
		.alloca {
			elem_type := g.type_name(g.mod.type_store.types[val.typ].elem_type)
			g.sb.writeln('\t${elem_type} _stack_${val.id};')
			g.sb.writeln('\t${res} = &_stack_${val.id};')
		}
		.load {
			ptr_id := instr.operands[0]
			ptr := g.val_str(ptr_id)

			// FIX: specific handling for globals (no dereference needed in C)
			if g.mod.values[ptr_id].kind == .global {
				g.sb.writeln('\t${res} = ${ptr};')
			} else {
				g.sb.writeln('\t${res} = *${ptr};')
			}
		}
		.store {
			val_op := g.val_str(instr.operands[0])
			ptr_id := instr.operands[1]
			ptr_op := g.val_str(ptr_id)

			// FIX: specific handling for globals
			if g.mod.values[ptr_id].kind == .global {
				g.sb.writeln('\t${ptr_op} = ${val_op};')
			} else {
				g.sb.writeln('\t*${ptr_op} = ${val_op};')
			}
		}
		.call {
			// Operand 0: Function Name Value
			// Operands 1..N: Arguments
			fn_val_id := instr.operands[0]
			fn_name := g.mod.values[fn_val_id].name

			mut args_str := []string{}
			for i := 1; i < instr.operands.len; i++ {
				args_str << g.val_str(instr.operands[i])
			}
			args_c := args_str.join(', ')

			if g.mod.type_store.types[val.typ].kind != .void_t {
				g.sb.writeln('\t${res} = ${fn_name}(${args_c});')
			} else {
				g.sb.writeln('\t${fn_name}(${args_c});')
			}
		}
		.eq, .ne, .lt, .gt, .le, .ge {
			lhs := g.val_str(instr.operands[0])
			rhs := g.val_str(instr.operands[1])
			op_str := match instr.op {
				.eq { '==' }
				.ne { '!=' }
				.lt { '<' }
				.gt { '>' }
				.le { '<=' }
				.ge { '>=' }
				else { '==' }
			}
			g.sb.writeln('\t${res} = (${lhs} ${op_str} ${rhs});')
		}
		.br {
			cond := g.val_str(instr.operands[0])
			true_blk := g.get_block_name(instr.operands[1])
			false_blk := g.get_block_name(instr.operands[2])
			g.sb.writeln('\tif (${cond}) goto ${true_blk}; else goto ${false_blk};')
		}
		.jmp {
			dest := g.get_block_name(instr.operands[0])
			g.sb.writeln('\tgoto ${dest};')
		}
		.ret {
			if instr.operands.len > 0 {
				v := g.val_str(instr.operands[0])
				g.sb.writeln('\treturn ${v};')
			} else {
				g.sb.writeln('\treturn;')
			}
		}
		.get_element_ptr {
			base := g.val_str(instr.operands[0])
			idx_val := g.mod.values[instr.operands[1]]

			base_val_id := instr.operands[0]
			base_val := g.mod.values[base_val_id]
			base_val_typ := base_val.typ
			elem_type_id := g.mod.type_store.types[base_val_typ].elem_type
			elem_type := g.mod.type_store.types[elem_type_id]

			if elem_type.kind == .struct_t {
				// For globals, the C declaration is not a pointer, so use '.' instead of '->'
				if base_val.kind == .global {
					g.sb.writeln('\t${res} = &${base}.field_${idx_val.name};')
				} else {
					g.sb.writeln('\t${res} = &${base}->field_${idx_val.name};')
				}
			} else {
				idx := g.val_str(instr.operands[1])
				g.sb.writeln('\t${res} = &${base}[${idx}];')
			}
		}
		.switch_ {
			cond := g.val_str(instr.operands[0])
			g.sb.writeln('\tswitch (${cond}) {')
			// Operands: 0=cond, 1=def, 2=val, 3=blk, 4=val, 5=blk...
			for i := 2; i < instr.operands.len; i += 2 {
				val2 := g.val_str(instr.operands[i])
				blk_val_id := instr.operands[i + 1]
				blk_name := g.get_block_name(blk_val_id)
				g.sb.writeln('\tcase ${val2}: goto ${blk_name};')
			}
			def_blk_val_id := instr.operands[1]
			def_name := g.get_block_name(def_blk_val_id)
			g.sb.writeln('\tdefault: goto ${def_name};')
			g.sb.writeln('\t}')
		}
		.phi {
			// Phi node: operands are pairs of (value, block)
			// For C, we emit assignments before jumps in predecessors
			// Here we just declare the variable (already done above)
			// The actual assignments are handled by .assign opcodes
		}
		.select {
			// select cond, true_val, false_val
			cond := g.val_str(instr.operands[0])
			true_val := g.val_str(instr.operands[1])
			false_val := g.val_str(instr.operands[2])
			g.sb.writeln('\t${res} = ${cond} ? ${true_val} : ${false_val};')
		}
		else {
			g.sb.writeln('\t// Unhandled C op: ${instr.op}')
		}
	}
}

// Helpers
fn (g Gen) type_name(id int) string {
	t := g.mod.type_store.types[id]
	match t.kind {
		.void_t { return 'void' }
		.int_t { return 'int${t.width}_t' }
		.float_t { return if t.width == 32 { 'float' } else { 'double' } }
		.ptr_t { return g.type_name(t.elem_type) + '*' }
		.struct_t { return 'Struct_${id}' }
		else { return 'void' }
	}
}

fn (g Gen) val_str(id int) string {
	val := g.mod.values[id]
	if val.kind == .constant {
		return val.name
	} else if val.kind == .argument {
		return val.name
	} else if val.kind == .global {
		return val.name
	}
	return '_v${val.id}'
}

fn (g Gen) get_block_name(val_id int) string {
	// In the block arena value wrapper, we stored block index in .index
	val := g.mod.values[val_id]
	blk := g.mod.blocks[val.index]
	return blk.name
}

fn (g Gen) op_sym(op ssa.OpCode) string {
	return match op {
		.add { '+' }
		.sub { '-' }
		.mul { '*' }
		.sdiv, .udiv { '/' }
		.srem, .urem { '%' }
		else { '?' }
	}
}
