// Copyright (c) 2026 Alexander Medvednikov. All rights reserved.
// Use of this source code is governed by an MIT license
// that can be found in the LICENSE file.

module c

import v2.ssa
import strings

pub struct Gen {
	mod &ssa.Module
mut:
	sb strings.Builder
}

pub fn Gen.new(mod &ssa.Module) &Gen {
	return &Gen{
		mod: mod
		sb:  strings.new_builder(4096)
	}
}

pub fn (mut g Gen) gen() string {
	g.sb.writeln('// Generated by V SSA Compiler')
	g.sb.writeln('#include <stdint.h>')
	g.sb.writeln('#include <stdbool.h>')
	g.sb.writeln('#include <stddef.h>')
	g.sb.writeln('#include <stdio.h>')
	g.sb.writeln('#include <stdlib.h>')
	g.sb.writeln('#include <string.h>')
	g.sb.writeln('')
	// Builtin string type
	g.sb.writeln('typedef struct { int8_t* str; int64_t len; int64_t is_lit; } string;')
	g.sb.writeln('')
	// Minimal builtin stubs for standalone compilation
	g.sb.writeln('// Minimal builtin stubs')
	g.sb.writeln('static inline int64_t println(string s) { printf("%.*s\\n", (int)s.len, (char*)s.str); return 0; }')
	g.sb.writeln('static inline int64_t print(string s) { printf("%.*s", (int)s.len, (char*)s.str); return 0; }')
	g.sb.writeln('static inline int64_t eprintln(string s) { fprintf(stderr, "%.*s\\n", (int)s.len, (char*)s.str); return 0; }')
	g.sb.writeln('static inline void* malloc_noscan(int64_t size) { return malloc(size); }')
	g.sb.writeln('static inline void* v__malloc(int64_t size) { return malloc(size); }')
	g.sb.writeln('static inline void* vcalloc(int64_t size) { return calloc(1, size); }')
	g.sb.writeln('static inline void* vcalloc_noscan(int64_t size) { return calloc(1, size); }')
	g.sb.writeln('static inline int64_t __at_least_one(int64_t n) { return n > 0 ? n : 1; }')
	g.sb.writeln('static inline void* vmemcpy(void* dest, const void* src, int64_t n) { return memcpy(dest, src, n); }')
	g.sb.writeln('static inline void* vmemset(void* dest, int c, int64_t n) { return memset(dest, c, n); }')
	g.sb.writeln('static inline void* vmemmove(void* dest, const void* src, int64_t n) { return memmove(dest, src, n); }')
	g.sb.writeln('static inline int64_t v__puts(int8_t* s) { return puts((char*)s); }')
	g.sb.writeln('#define v__sprintf sprintf')
	g.sb.writeln('')

	g.gen_struct_decls()
	g.gen_globals()
	g.gen_func_decls()

	for func in g.mod.funcs {
		g.gen_func(func)
	}

	return g.sb.str()
}

fn (mut g Gen) gen_func_decls() {
	// Forward declarations for all functions
	for func in g.mod.funcs {
		c_name := g.mangle_fn_name(func.name)
		ret_type := if func.name == 'main' { 'int' } else { g.type_name(func.typ) }
		mut params := []string{}
		for pid in func.params {
			val := g.mod.values[pid]
			tname := g.type_name(val.typ)
			params << '${tname} ${val.name}'
		}
		param_str := params.join(', ')
		g.sb.writeln('${ret_type} ${c_name}(${param_str});')
	}
	g.sb.writeln('')
}

// mangle_fn_name converts V function names to valid C names that don't conflict
fn (g Gen) mangle_fn_name(name string) string {
	// main is special - keep as is for C entry point
	if name == 'main' {
		return 'main'
	}
	// These names conflict with C standard library or keywords
	reserved := ['string', 'free', 'malloc', 'realloc', 'calloc', 'atoi', 'atol', 'atof', 'exit',
		'abort', 'printf', 'sprintf', 'fprintf', 'scanf', 'puts', 'gets', 'strlen', 'strcpy',
		'strcat', 'strcmp', 'memcpy', 'memset', 'memmove', 'memcmp']
	if name in reserved {
		return 'v__${name}'
	}
	return name
}

fn (mut g Gen) gen_struct_decls() {
	for i, t in g.mod.type_store.types {
		if t.kind == .struct_t {
			// Skip builtin string type (already defined)
			if g.is_string_type(i) {
				continue
			}
			g.sb.writeln('typedef struct Struct_${i} Struct_${i};')
		}
	}
	g.sb.writeln('')

	for i, t in g.mod.type_store.types {
		if t.kind == .struct_t {
			// Skip builtin string type (already defined)
			if g.is_string_type(i) {
				continue
			}
			g.sb.writeln('struct Struct_${i} {')
			for idx, field_id in t.fields {
				type_name := g.type_name(field_id)
				// Use named fields if available
				field_name := if idx < t.field_names.len {
					t.field_names[idx]
				} else {
					'field_${idx}'
				}
				g.sb.writeln('\t${type_name} ${field_name};')
			}
			g.sb.writeln('};')
		}
	}
	g.sb.writeln('')
}

fn (g Gen) is_string_type(type_id int) bool {
	t := g.mod.type_store.types[type_id]
	if t.kind == .struct_t && t.field_names.len == 3 {
		return t.field_names[0] == 'str' && t.field_names[1] == 'len'
			&& t.field_names[2] == 'is_lit'
	}
	return false
}

fn (mut g Gen) gen_globals() {
	for gvar in g.mod.globals {
		tname := g.type_name(gvar.typ)
		if gvar.is_constant {
			g.sb.writeln('const ${tname} ${gvar.name} = ${gvar.initial_value};')
		} else {
			g.sb.writeln('${tname} ${gvar.name};')
		}
	}
}

fn (mut g Gen) gen_func(func ssa.Function) {
	c_name := g.mangle_fn_name(func.name)
	ret_type := if func.name == 'main' { 'int' } else { g.type_name(func.typ) }

	mut params := []string{}
	for pid in func.params {
		val := g.mod.values[pid]
		tname := g.type_name(val.typ)
		params << '${tname} ${val.name}'
	}
	param_str := params.join(', ')

	g.sb.writeln('${ret_type} ${c_name}(${param_str}) {')

	for blk_id in func.blocks {
		blk := g.mod.blocks[blk_id]
		for instr_val_id in blk.instrs {
			val := g.mod.values[instr_val_id]
			typ_kind := g.mod.type_store.types[val.typ].kind
			if typ_kind == .void_t {
				// Void-typed values are declared as void* to allow pointer operations
				g.sb.writeln('\tvoid* _v${val.id};')
			} else {
				tname := g.type_name(val.typ)
				g.sb.writeln('\t${tname} _v${val.id};')
			}
		}
	}

	for blk_id in func.blocks {
		blk := g.mod.blocks[blk_id]
		g.sb.writeln('${blk.name}:;')

		for instr_val_id in blk.instrs {
			g.gen_instr(instr_val_id)
		}
	}
	g.sb.writeln('}')
	g.sb.writeln('')
}

fn (mut g Gen) gen_instr(val_id int) {
	val := g.mod.values[val_id]
	instr := g.mod.instrs[val.index]

	res := '_v${val.id}'

	match instr.op {
		.add, .sub, .mul, .sdiv, .udiv, .srem, .urem, .fadd, .fsub, .fmul, .fdiv, .frem {
			op := g.op_sym(instr.op)
			lhs := g.val_str(instr.operands[0])
			rhs := g.val_str(instr.operands[1])
			g.sb.writeln('\t${res} = ${lhs} ${op} ${rhs};')
		}
		.and_, .or_, .xor {
			op := match instr.op {
				.and_ { '&' }
				.or_ { '|' }
				.xor { '^' }
				else { '?' }
			}
			lhs := g.val_str(instr.operands[0])
			rhs := g.val_str(instr.operands[1])
			g.sb.writeln('\t${res} = ${lhs} ${op} ${rhs};')
		}
		.shl, .lshr, .ashr {
			op := match instr.op {
				.shl { '<<' }
				.lshr { '>>' }
				.ashr { '>>' }
				else { '?' }
			}
			lhs := g.val_str(instr.operands[0])
			rhs := g.val_str(instr.operands[1])
			g.sb.writeln('\t${res} = ${lhs} ${op} ${rhs};')
		}
		.assign {
			// Phi elimination copy: dest = src
			dest_val := instr.operands[0]
			src_val := instr.operands[1]
			dest := '_v${dest_val}'
			src := g.val_str(src_val)
			g.sb.writeln('\t${dest} = ${src};')
		}
		.alloca {
			elem_type_id := g.mod.type_store.types[val.typ].elem_type
			elem_type_info := g.mod.type_store.types[elem_type_id]
			// For void type allocations, allocate a small buffer for optional/result handling
			if elem_type_info.kind == .void_t {
				g.sb.writeln('\tint64_t _stack_${val.id};')
				g.sb.writeln('\t${res} = &_stack_${val.id};')
			} else if elem_type_info.kind == .array_t {
				// Array allocation: int64_t arr[N]
				arr_elem_type := g.type_name(elem_type_info.elem_type)
				g.sb.writeln('\t${arr_elem_type} _stack_${val.id}[${elem_type_info.len}];')
				g.sb.writeln('\t${res} = _stack_${val.id};')
			} else {
				// Regular allocation
				elem_type := g.type_name(elem_type_id)
				g.sb.writeln('\t${elem_type} _stack_${val.id};')
				g.sb.writeln('\t${res} = &_stack_${val.id};')
			}
		}
		.load {
			ptr_id := instr.operands[0]
			ptr := g.val_str(ptr_id)

			// Skip loading void type - just assign NULL
			if g.mod.type_store.types[val.typ].kind == .void_t {
				g.sb.writeln('\t${res} = NULL;')
			} else if g.mod.values[ptr_id].kind == .global {
				// FIX: specific handling for globals (no dereference needed in C)
				g.sb.writeln('\t${res} = ${ptr};')
			} else {
				g.sb.writeln('\t${res} = *${ptr};')
			}
		}
		.store {
			src_val_id := instr.operands[0]
			// Skip storing void sentinel (value ID 0)
			if src_val_id == 0 {
				g.sb.writeln('\t// skipped store of void sentinel')
			} else {
				val_op := g.val_str(src_val_id)
				ptr_id := instr.operands[1]
				ptr_op := g.val_str(ptr_id)

				// FIX: specific handling for globals
				if g.mod.values[ptr_id].kind == .global {
					g.sb.writeln('\t${ptr_op} = ${val_op};')
				} else {
					g.sb.writeln('\t*${ptr_op} = ${val_op};')
				}
			}
		}
		.call {
			// Operand 0: Function Name Value
			// Operands 1..N: Arguments
			fn_val_id := instr.operands[0]
			fn_name := g.mangle_fn_name(g.mod.values[fn_val_id].name)

			mut args_str := []string{}
			for i := 1; i < instr.operands.len; i++ {
				args_str << g.val_str(instr.operands[i])
			}
			args_c := args_str.join(', ')

			if g.mod.type_store.types[val.typ].kind != .void_t {
				g.sb.writeln('\t${res} = ${fn_name}(${args_c});')
			} else {
				g.sb.writeln('\t${fn_name}(${args_c});')
			}
		}
		.call_indirect {
			// Indirect call through function pointer
			// Operand 0: Function Pointer Value
			// Operands 1..N: Arguments
			fn_ptr := g.val_str(instr.operands[0])

			mut args_str := []string{}
			for i := 1; i < instr.operands.len; i++ {
				args_str << g.val_str(instr.operands[i])
			}
			args_c := args_str.join(', ')

			if g.mod.type_store.types[val.typ].kind != .void_t {
				g.sb.writeln('\t${res} = ((void*(*)(void*, void*))${fn_ptr})(${args_c});')
			} else {
				g.sb.writeln('\t((void(*)(void*, void*))${fn_ptr})(${args_c});')
			}
		}
		.eq, .ne, .lt, .gt, .le, .ge {
			lhs := g.val_str(instr.operands[0])
			rhs := g.val_str(instr.operands[1])
			op_str := match instr.op {
				.eq { '==' }
				.ne { '!=' }
				.lt { '<' }
				.gt { '>' }
				.le { '<=' }
				.ge { '>=' }
				else { '==' }
			}
			g.sb.writeln('\t${res} = (${lhs} ${op_str} ${rhs});')
		}
		.fptosi {
			// Float to signed integer conversion
			src := g.val_str(instr.operands[0])
			g.sb.writeln('\t${res} = (int64_t)${src};')
		}
		.sitofp {
			// Signed integer to float conversion
			src := g.val_str(instr.operands[0])
			g.sb.writeln('\t${res} = (double)${src};')
		}
		.fptoui {
			// Float to unsigned integer conversion
			src := g.val_str(instr.operands[0])
			g.sb.writeln('\t${res} = (uint64_t)${src};')
		}
		.uitofp {
			// Unsigned integer to float conversion
			src := g.val_str(instr.operands[0])
			g.sb.writeln('\t${res} = (double)${src};')
		}
		.br {
			cond := g.val_str(instr.operands[0])
			true_blk := g.get_block_name(instr.operands[1])
			false_blk := g.get_block_name(instr.operands[2])
			g.sb.writeln('\tif (${cond}) goto ${true_blk}; else goto ${false_blk};')
		}
		.jmp {
			dest := g.get_block_name(instr.operands[0])
			g.sb.writeln('\tgoto ${dest};')
		}
		.ret {
			if instr.operands.len > 0 {
				ret_val_id := instr.operands[0]
				ret_val := g.mod.values[ret_val_id]
				ret_val_typ := g.mod.type_store.types[ret_val.typ]
				v := g.val_str(ret_val_id)

				// Check if we're returning a pointer to a struct but the function returns struct by value
				// This happens when the return value is a pointer and the pointed-to type is a struct
				if ret_val_typ.kind == .ptr_t {
					elem_typ := g.mod.type_store.types[ret_val_typ.elem_type]
					if elem_typ.kind == .struct_t {
						// Dereference the pointer to return struct by value
						g.sb.writeln('\treturn *${v};')
					} else {
						g.sb.writeln('\treturn ${v};')
					}
				} else {
					g.sb.writeln('\treturn ${v};')
				}
			} else {
				g.sb.writeln('\treturn;')
			}
		}
		.get_element_ptr {
			base := g.val_str(instr.operands[0])
			idx_val := g.mod.values[instr.operands[1]]

			base_val_id := instr.operands[0]
			base_val := g.mod.values[base_val_id]
			base_val_typ := base_val.typ
			elem_type_id := g.mod.type_store.types[base_val_typ].elem_type
			elem_type := g.mod.type_store.types[elem_type_id]

			if elem_type.kind == .struct_t {
				// Get field name - use named field if available, otherwise fall back to field_N
				idx := idx_val.name.int()
				field_name := if idx < elem_type.field_names.len {
					elem_type.field_names[idx]
				} else {
					'field_${idx_val.name}'
				}
				// For globals, the C declaration is not a pointer, so use '.' instead of '->'
				if base_val.kind == .global {
					g.sb.writeln('\t${res} = &${base}.${field_name};')
				} else {
					g.sb.writeln('\t${res} = &${base}->${field_name};')
				}
			} else {
				idx := g.val_str(instr.operands[1])
				g.sb.writeln('\t${res} = &${base}[${idx}];')
			}
		}
		.switch_ {
			cond := g.val_str(instr.operands[0])
			g.sb.writeln('\tswitch (${cond}) {')
			// Operands: 0=cond, 1=def, 2=val, 3=blk, 4=val, 5=blk...
			for i := 2; i < instr.operands.len; i += 2 {
				val2 := g.val_str(instr.operands[i])
				blk_val_id := instr.operands[i + 1]
				blk_name := g.get_block_name(blk_val_id)
				g.sb.writeln('\tcase ${val2}: goto ${blk_name};')
			}
			def_blk_val_id := instr.operands[1]
			def_name := g.get_block_name(def_blk_val_id)
			g.sb.writeln('\tdefault: goto ${def_name};')
			g.sb.writeln('\t}')
		}
		.phi {
			// Phi node: operands are pairs of (value, block)
			// For C, we emit assignments before jumps in predecessors
			// Here we just declare the variable (already done above)
			// The actual assignments are handled by .assign opcodes
		}
		.select {
			// select cond, true_val, false_val
			cond := g.val_str(instr.operands[0])
			true_val := g.val_str(instr.operands[1])
			false_val := g.val_str(instr.operands[2])
			g.sb.writeln('\t${res} = ${cond} ? ${true_val} : ${false_val};')
		}
		.unreachable {
			// Unreachable code - typically after abort/exit
			g.sb.writeln('\t__builtin_unreachable();')
		}
		.inline_string_init {
			// Create string struct by value: (string){str, len, is_lit}
			str_ptr := g.val_str(instr.operands[0])
			len_val := g.val_str(instr.operands[1])
			is_lit := g.val_str(instr.operands[2])
			g.sb.writeln('\t${res} = (string){(int8_t*)${str_ptr}, ${len_val}, ${is_lit}};')
		}
		else {
			g.sb.writeln('\t// Unhandled C op: ${instr.op}')
		}
	}
}

// Helpers
fn (g Gen) type_name(id int) string {
	t := g.mod.type_store.types[id]
	match t.kind {
		.void_t {
			return 'void'
		}
		.int_t {
			return 'int${t.width}_t'
		}
		.float_t {
			return if t.width == 32 { 'float' } else { 'double' }
		}
		.ptr_t {
			// Check if pointing to an array - if so, just use pointer to element type
			elem_t := g.mod.type_store.types[t.elem_type]
			if elem_t.kind == .array_t {
				return g.type_name(elem_t.elem_type) + '*'
			}
			// Check if pointing to string struct
			if g.is_string_type(t.elem_type) {
				return 'string*'
			}
			return g.type_name(t.elem_type) + '*'
		}
		.array_t {
			return g.type_name(t.elem_type) + '*'
		} // Arrays decay to pointers
		.struct_t {
			// Check for builtin string type
			if g.is_string_type(id) {
				return 'string'
			}
			return 'Struct_${id}'
		}
		else {
			return 'void'
		}
	}
}

fn (g Gen) val_str(id int) string {
	val := g.mod.values[id]
	if val.kind == .constant {
		return val.name
	} else if val.kind == .argument {
		return val.name
	} else if val.kind == .global {
		return val.name
	} else if val.kind == .string_literal {
		// String literal: generate inline struct literal
		// val.name contains the string content, val.index contains length
		return '(string){"${val.name}", ${val.index}, 1}'
	}
	return '_v${val.id}'
}

fn (g Gen) get_block_name(val_id int) string {
	// In the block arena value wrapper, we stored block index in .index
	val := g.mod.values[val_id]
	blk := g.mod.blocks[val.index]
	return blk.name
}

fn (g Gen) op_sym(op ssa.OpCode) string {
	return match op {
		.add, .fadd { '+' }
		.sub, .fsub { '-' }
		.mul, .fmul { '*' }
		.sdiv, .udiv, .fdiv { '/' }
		.srem, .urem { '%' }
		.frem { '%' } // Note: C uses fmod() for float modulo, but % works for simple cases
		else { '?' }
	}
}
