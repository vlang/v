// Copyright (c) 2026 Alexander Medvednikov. All rights reserved.
// Use of this source code is governed by an MIT license
// that can be found in the LICENSE file.

module c

import v2.ssa
import strings

pub struct Gen {
	mod &ssa.Module
mut:
	sb                    strings.Builder
	current_fn_name       string
	current_fn_ret        int
	current_fn_idx        int
	global_c_names        []string
	edge_zero_inits       map[string][]int
	assign_dests          map[int]bool
	nonconst_assign_dests map[int]bool
	block_assign_dests    map[int][]int
	fn_lookup             map[string]int
	fn_exact_lookup       map[string][]int
	fn_suffix_lookup      map[string][]int
	fn_mangled_names      []string
	signature_params_map  map[int][]ssa.ValueID
	effective_params_map  map[int][]ssa.ValueID
}

pub fn Gen.new(mod &ssa.Module) &Gen {
	return &Gen{
		mod:                   mod
		sb:                    strings.new_builder(4096)
		edge_zero_inits:       map[string][]int{}
		assign_dests:          map[int]bool{}
		nonconst_assign_dests: map[int]bool{}
		block_assign_dests:    map[int][]int{}
		fn_lookup:             map[string]int{}
		fn_exact_lookup:       map[string][]int{}
		fn_suffix_lookup:      map[string][]int{}
		fn_mangled_names:      []string{}
		signature_params_map:  map[int][]ssa.ValueID{}
		effective_params_map:  map[int][]ssa.ValueID{}
	}
}

pub fn (mut g Gen) gen() string {
	g.sb.writeln('// Generated by V SSA Compiler')
	g.sb.writeln('#include <stdint.h>')
	g.sb.writeln('#include <stdbool.h>')
	g.sb.writeln('#include <stddef.h>')
	g.sb.writeln('#include <stdio.h>')
	g.sb.writeln('#include <stdlib.h>')
	g.sb.writeln('#include <string.h>')
	g.sb.writeln('#include <unistd.h>')
	g.sb.writeln('#include <fcntl.h>')
	g.sb.writeln('#include <dirent.h>')
	g.sb.writeln('#include <errno.h>')
	g.sb.writeln('#include <time.h>')
	g.sb.writeln('#include <sys/types.h>')
	g.sb.writeln('#include <sys/stat.h>')
	g.sb.writeln('#include <sys/wait.h>')
	g.sb.writeln('#include <math.h>')
	g.sb.writeln('#ifndef _WIN32')
	g.sb.writeln('#include <pthread.h>')
	g.sb.writeln('#endif')
	g.sb.writeln('#ifdef __APPLE__')
	g.sb.writeln('#include <mach/mach_time.h>')
	g.sb.writeln('#include <libproc.h>')
	g.sb.writeln('#endif')
	g.sb.writeln('')
	g.init_global_names()
	g.init_function_lookups()
	// Builtin string type
	g.sb.writeln('typedef struct { int8_t* str; int64_t len; int64_t is_lit; } string;')
	g.sb.writeln('')
	g.gen_runtime_stubs()

	g.gen_struct_decls()
	g.gen_globals()
	g.gen_func_decls()

	for i, func in g.mod.funcs {
		g.current_fn_idx = i
		g.gen_func(func)
	}

	return g.sb.str()
}

fn (mut g Gen) gen_func_decls() {
	// Forward declarations for all functions
	for func in g.mod.funcs {
		if func.name == 'main' {
			g.sb.writeln('int main(int argc, char** argv);')
			continue
		}
		effective_params := g.signature_params(func)
		c_name := g.mangle_fn_name(func.name)
		ret_type := g.type_name(func.typ)
		mut params := []string{}
		for pid in effective_params {
			val := g.mod.values[pid]
			mut tname := g.type_name(val.typ)
			if tname == 'void' {
				tname = 'void*'
			}
			params << '${tname} ${g.arg_name(val)}'
		}
		param_str := params.join(', ')
		g.sb.writeln('${ret_type} ${c_name}(${param_str});')
	}
	g.sb.writeln('')
}

// mangle_fn_name converts V function names to valid C names that don't conflict
fn (g Gen) mangle_fn_name(name string) string {
	// main is special - keep as is for C entry point
	if name == 'main' {
		return 'main'
	}
	safe_name := sanitize_c_ident(name, 'fn')
	// These names conflict with C standard library or keywords.
	if is_reserved_c_fn_name(safe_name) {
		return 'v__${safe_name}'
	}
	return safe_name
}

fn is_reserved_c_fn_name(name string) bool {
	return match name {
		'string', 'free', 'malloc', 'realloc', 'calloc', 'atoi', 'atol', 'atof', 'exit', 'abort',
		'printf', 'sprintf', 'fprintf', 'scanf', 'puts', 'gets', 'strlen', 'strcpy', 'strcat',
		'strcmp', 'memcpy', 'memset', 'memmove', 'memcmp' {
			true
		}
		else {
			false
		}
	}
}

fn (mut g Gen) gen_struct_decls() {
	mut struct_ids := []int{}
	for i, t in g.mod.type_store.types {
		if t.kind == .struct_t {
			// Skip builtin string type (already defined)
			if g.is_string_type(i) {
				continue
			}
			struct_ids << i
			g.sb.writeln('typedef struct Struct_${i} Struct_${i};')
		}
	}
	g.sb.writeln('')

	mut struct_state := []u8{len: g.mod.type_store.types.len, init: 0}
	mut ordered_struct_ids := []int{}
	for struct_id in struct_ids {
		g.order_struct_decl(struct_id, mut struct_state, mut ordered_struct_ids)
	}

	for struct_id in ordered_struct_ids {
		t := g.mod.type_store.types[struct_id]
		g.sb.writeln('struct Struct_${struct_id} {')
		for idx, field_id in t.fields {
			mut type_name := g.type_name(field_id)
			if type_name == 'void' {
				// C does not allow fields of type `void`.
				type_name = 'uint8_t'
			}
			field_name := g.struct_field_name(t, idx)
			g.sb.writeln('\t${type_name} ${field_name};')
		}
		g.sb.writeln('};')
	}
	g.sb.writeln('')
}

fn (mut g Gen) order_struct_decl(type_id int, mut state []u8, mut ordered []int) {
	if type_id <= 0 || type_id >= g.mod.type_store.types.len {
		return
	}
	if g.mod.type_store.types[type_id].kind != .struct_t || g.is_string_type(type_id) {
		return
	}
	if state[type_id] == 2 {
		return
	}
	if state[type_id] == 1 {
		// Cycles through by-value fields are invalid in C; keep current order.
		return
	}
	state[type_id] = 1
	t := g.mod.type_store.types[type_id]
	for field_id in t.fields {
		g.order_struct_value_dependency(field_id, mut state, mut ordered)
	}
	state[type_id] = 2
	ordered << type_id
}

fn (mut g Gen) order_struct_value_dependency(type_id int, mut state []u8, mut ordered []int) {
	if type_id <= 0 || type_id >= g.mod.type_store.types.len {
		return
	}
	t := g.mod.type_store.types[type_id]
	match t.kind {
		.struct_t {
			g.order_struct_decl(type_id, mut state, mut ordered)
		}
		.array_t {
			// Fixed-size array fields embed their element type by value.
			g.order_struct_value_dependency(t.elem_type, mut state, mut ordered)
		}
		else {}
	}
}

fn (g Gen) is_string_type(type_id int) bool {
	t := g.mod.type_store.types[type_id]
	if t.kind == .struct_t && t.field_names.len == 3 {
		return t.field_names[0] == 'str' && t.field_names[1] == 'len'
			&& t.field_names[2] == 'is_lit'
	}
	return false
}

fn (mut g Gen) gen_globals() {
	for i, gvar in g.mod.globals {
		if gvar.linkage == .external {
			continue
		}
		tname := g.type_name(gvar.typ)
		gname := g.global_c_names[i]
		if gvar.is_constant || gvar.initial_value != 0 {
			g.sb.writeln('${tname} ${gname} = ${g.global_init_expr(gvar)};')
		} else {
			g.sb.writeln('${tname} ${gname};')
		}
	}
}

fn (g Gen) global_init_expr(gvar ssa.GlobalVar) string {
	if gvar.typ <= 0 || gvar.typ >= g.mod.type_store.types.len {
		return '${gvar.initial_value}'
	}
	t := g.mod.type_store.types[gvar.typ]
	return match t.kind {
		.int_t { '${gvar.initial_value}' }
		.float_t { '${gvar.initial_value}.0' }
		.ptr_t, .array_t { '(${g.type_name(gvar.typ)})(uintptr_t)(${gvar.initial_value})' }
		else { g.zero_value_expr(gvar.typ) }
	}
}

fn (mut g Gen) gen_func(func ssa.Function) {
	g.current_fn_name = func.name
	g.current_fn_ret = func.typ
	g.init_assign_lookups(func)
	g.edge_zero_inits = g.collect_edge_zero_inits(func)
	effective_params := g.signature_params(func)
	c_name := g.mangle_fn_name(func.name)
	ret_type := if func.name == 'main' { 'int' } else { g.type_name(func.typ) }

	mut params := []string{}
	for pid in effective_params {
		val := g.mod.values[pid]
		mut tname := g.type_name(val.typ)
		if tname == 'void' {
			tname = 'void*'
		}
		params << '${tname} ${g.arg_name(val)}'
	}
	mut param_str := params.join(', ')
	if func.name == 'main' {
		param_str = 'int argc, char** argv'
	}

	g.sb.writeln('${ret_type} ${c_name}(${param_str}) {')
	if func.name == 'main' {
		if argc_gname := g.global_name_by_source('g_main_argc') {
			g.sb.writeln('\t${argc_gname} = (int64_t)(argc);')
		}
		if argv_gname := g.global_name_by_source('g_main_argv') {
			g.sb.writeln('\t${argv_gname} = (int64_t)(uintptr_t)(argv);')
		}
		if _ := g.find_function('__v2_global_init') {
			g.sb.writeln('\t__v2_global_init();')
		}
	}

	for blk_id in func.blocks {
		blk := g.mod.blocks[blk_id]
		for instr_val_id in blk.instrs {
			val := g.mod.values[instr_val_id]
			typ_kind := g.mod.type_store.types[val.typ].kind
			if typ_kind == .void_t {
				// Void-typed values are declared as void* to allow pointer operations
				g.sb.writeln('\tvoid* _v${val.id} = NULL;')
			} else {
				tname := g.type_name(val.typ)
				g.sb.writeln('\t${tname} _v${val.id} = ${g.zero_value_expr(val.typ)};')
			}
		}
	}

	for blk_id in func.blocks {
		blk := g.mod.blocks[blk_id]
		g.sb.writeln('${blk.name}:;')

		for instr_val_id in blk.instrs {
			g.gen_instr(instr_val_id)
		}
	}
	g.sb.writeln('}')
	g.sb.writeln('')
}

fn (mut g Gen) gen_instr(val_id int) {
	val := g.mod.values[val_id]
	instr := g.mod.instrs[val.index]

	res := '_v${val.id}'

	match instr.op {
		.add, .sub, .mul, .sdiv, .udiv, .srem, .urem {
			op := g.op_sym(instr.op)
			lhs := g.int_op_operand_str(instr.operands[0])
			rhs := g.int_op_operand_str(instr.operands[1])
			expr := '${lhs} ${op} ${rhs}'
			g.sb.writeln('\t${res} = ${g.cast_int_expr_to_type(expr, val.typ)};')
		}
		.fadd, .fsub, .fmul, .fdiv {
			op := g.op_sym(instr.op)
			lhs := g.val_str(instr.operands[0])
			rhs := g.val_str(instr.operands[1])
			g.sb.writeln('\t${res} = (${g.type_name(val.typ)})(${lhs} ${op} ${rhs});')
		}
		.frem {
			lhs := g.val_str(instr.operands[0])
			rhs := g.val_str(instr.operands[1])
			g.sb.writeln('\t${res} = fmod(${lhs}, ${rhs});')
		}
		.and_, .or_, .xor {
			op := match instr.op {
				.and_ { '&' }
				.or_ { '|' }
				.xor { '^' }
				else { '?' }
			}
			lhs := g.int_op_operand_str(instr.operands[0])
			rhs := g.int_op_operand_str(instr.operands[1])
			expr := '${lhs} ${op} ${rhs}'
			g.sb.writeln('\t${res} = ${g.cast_int_expr_to_type(expr, val.typ)};')
		}
		.shl, .lshr, .ashr {
			op := match instr.op {
				.shl { '<<' }
				.lshr { '>>' }
				.ashr { '>>' }
				else { '?' }
			}
			lhs := g.int_op_operand_str(instr.operands[0])
			rhs := g.int_op_operand_str(instr.operands[1])
			expr := '${lhs} ${op} ${rhs}'
			g.sb.writeln('\t${res} = ${g.cast_int_expr_to_type(expr, val.typ)};')
		}
		.assign {
			// Phi elimination copy: dest = src
			dest_val := instr.operands[0]
			src_val := instr.operands[1]
			dest := '_v${dest_val}'
			src := g.val_str(src_val)
			dest_typ_id := g.value_type_id(dest_val)
			src_typ_id := g.value_type_id(src_val)
			if dest_typ_id > 0 {
				coerced := g.coerce_expr_to_type(src, src_typ_id, dest_typ_id)
				skip := g.should_skip_loop_header_zero_assign(instr.block, dest_val, coerced,
					dest_typ_id)
				if skip {
					return
				}
				g.sb.writeln('\t${dest} = ${coerced};')
			} else {
				g.sb.writeln('\t${dest} = ${src};')
			}
		}
		.alloca {
			elem_type_id := g.mod.type_store.types[val.typ].elem_type
			elem_type_info := g.mod.type_store.types[elem_type_id]
			// For void type allocations, allocate a small buffer for optional/result handling
			if elem_type_info.kind == .void_t {
				g.sb.writeln('\tint64_t _stack_${val.id};')
				g.sb.writeln('\t${res} = &_stack_${val.id};')
			} else if elem_type_info.kind == .array_t {
				// Array allocation: int64_t arr[N]
				arr_elem_type := g.type_name(elem_type_info.elem_type)
				g.sb.writeln('\t${arr_elem_type} _stack_${val.id}[${elem_type_info.len}];')
				g.sb.writeln('\t${res} = _stack_${val.id};')
			} else {
				// Regular allocation
				elem_type := g.type_name(elem_type_id)
				g.sb.writeln('\t${elem_type} _stack_${val.id};')
				g.sb.writeln('\t${res} = &_stack_${val.id};')
			}
		}
		.load {
			ptr_id := instr.operands[0]
			ptr := g.val_str(ptr_id)

			if g.mod.type_store.types[val.typ].kind == .void_t {
				if ptr_id <= 0 || ptr_id >= g.mod.values.len {
					g.sb.writeln('\t${res} = NULL;')
				} else if g.mod.values[ptr_id].kind == .global {
					g.sb.writeln('\t${res} = (void*)(uintptr_t)(${ptr});')
				} else {
					g.sb.writeln('\t${res} = *((void**)(${ptr}));')
				}
			} else if ptr_id <= 0 || ptr_id >= g.mod.values.len {
				if g.has_assign_to_dest(val.id) {
					g.sb.writeln('\t// skipped load from invalid pointer for carried value')
				} else {
					g.sb.writeln('\t${res} = ${g.zero_value_expr(val.typ)};')
				}
			} else if g.mod.values[ptr_id].kind == .global {
				// Globals are emitted as plain values in C, even though SSA models them as pointers.
				src_typ_id := g.value_type_id(ptr_id)
				mut actual_src_typ := src_typ_id
				if src_typ_id > 0 && src_typ_id < g.mod.type_store.types.len {
					src_typ := g.mod.type_store.types[src_typ_id]
					if src_typ.kind == .ptr_t && src_typ.elem_type > 0 {
						actual_src_typ = src_typ.elem_type
					}
				}
				coerced := g.coerce_expr_to_type(ptr, actual_src_typ, val.typ)
				g.sb.writeln('\t${res} = ${coerced};')
			} else {
				ptr_typ_id := g.value_type_id(ptr_id)
				if ptr_typ_id > 0 && ptr_typ_id < g.mod.type_store.types.len {
					ptr_typ := g.mod.type_store.types[ptr_typ_id]
					if ptr_typ.kind == .ptr_t && ptr_typ.elem_type > 0 && val.typ > 0
						&& val.typ < g.mod.type_store.types.len {
						src_typ_id := ptr_typ.elem_type
						src_kind := g.mod.type_store.types[src_typ_id].kind
						dst_kind := g.mod.type_store.types[val.typ].kind
						if dst_kind in [.int_t, .float_t] && src_kind in [.int_t, .float_t] {
							src_t := g.type_name(src_typ_id)
							load_expr := '*((${src_t}*)(${ptr}))'
							coerced := g.coerce_expr_to_type(load_expr, src_typ_id, val.typ)
							g.sb.writeln('\t${res} = ${coerced};')
							return
						}
					}
				}
				want_t := g.type_name(val.typ)
				g.sb.writeln('\t${res} = *((${want_t}*)(${ptr}));')
			}
		}
		.store {
			src_val_id := instr.operands[0]
			// Skip storing void sentinel (value ID 0)
			if src_val_id == 0 {
				g.sb.writeln('\t// skipped store of void sentinel')
			} else {
				src_typ_id := g.value_type_id(src_val_id)
				mut val_op := g.val_str(src_val_id)
				ptr_id := instr.operands[1]
				ptr_op := g.val_str(ptr_id)
				if ptr_id <= 0 || ptr_id >= g.mod.values.len {
					g.sb.writeln('\t// skipped store to invalid pointer')
					return
				}
				ptr_typ_id := g.value_type_id(ptr_id)
				if ptr_typ_id == 0 {
					g.sb.writeln('\t${ptr_op} = ${val_op};')
					return
				}
				if ptr_typ_id > 0 && ptr_typ_id < g.mod.type_store.types.len {
					ptr_typ := g.mod.type_store.types[ptr_typ_id]
					if ptr_typ.kind == .ptr_t {
						if ptr_typ.elem_type == 0 {
							// Cannot dereference void* directly in C; treat the slot as uintptr_t.
							g.sb.writeln('\t*((uintptr_t*)(${ptr_op})) = (uintptr_t)(${val_op});')
							return
						}
						mut store_typ_id := ptr_typ.elem_type
						if store_typ_id > 0 && store_typ_id < g.mod.type_store.types.len {
							store_typ := g.mod.type_store.types[store_typ_id]
							if store_typ.kind == .array_t && g.mod.values[ptr_id].kind != .global {
								store_typ_id = store_typ.elem_type
							}
						}
						val_op = g.coerce_expr_to_type(val_op, src_typ_id, store_typ_id)
					} else if ptr_typ.kind == .array_t {
						val_op = g.coerce_expr_to_type(val_op, src_typ_id, ptr_typ.elem_type)
					}
				}

				// FIX: specific handling for globals
				if g.mod.values[ptr_id].kind == .global {
					g.sb.writeln('\t${ptr_op} = ${val_op};')
				} else {
					g.sb.writeln('\t*${ptr_op} = ${val_op};')
				}
			}
		}
		.call {
			// Operand 0: Function Name Value
			// Operands 1..N: Arguments
			fn_val_id := instr.operands[0]
			fn_raw_name := g.mod.values[fn_val_id].name
			mut resolved_fn_name := fn_raw_name
			raw_c_name := sanitize_c_ident(fn_raw_name, 'fn')
			mut fn_name := g.mangle_fn_name(resolved_fn_name)
			known_raw_c_symbol := g.is_known_c_symbol(raw_c_name)
			known_mangled_symbol := g.is_known_c_symbol(fn_name)
			known_c_symbol := known_raw_c_symbol || known_mangled_symbol
			prefer_raw_c_symbol := known_raw_c_symbol
				&& fn_raw_name in ['getenv', 'setenv', 'unsetenv']
			mut expected_param_types := []ssa.TypeID{}
			mut has_impl := false
			mut callee_ret_typ_id := ssa.TypeID(0)
			mut has_callee_ret_typ := false
			mut prepend_implicit_first_arg := false
			call_arg_ids := if instr.operands.len > 1 {
				instr.operands[1..]
			} else {
				[]ssa.ValueID{}
			}
			if !prefer_raw_c_symbol {
				if f := g.resolve_function(fn_raw_name, call_arg_ids, val.typ) {
					has_impl = true
					resolved_fn_name = f.name
					fn_name = g.mangle_fn_name(resolved_fn_name)
					callee_ret_typ_id = f.typ
					has_callee_ret_typ = true
					for pid in g.signature_params(f) {
						expected_param_types << g.mod.values[pid].typ
					}
					prepend_implicit_first_arg = g.uses_implicit_constructor_receiver_arg(f,
						call_arg_ids.len)
				}
			}
			if !has_impl && !known_c_symbol {
				mut unresolved_hint := ' (args=${call_arg_ids.len}, idx=none)'
				if idx := g.function_index(fn_raw_name) {
					func := g.mod.funcs[idx]
					unresolved_hint = ' (args=${call_arg_ids.len}, idx=${idx}, sig=${g.signature_params(func).len}, eff=${g.effective_params(func).len})'
				}
				unresolved_hint += ' [raw=${raw_c_name}, mangled=${fn_name}, known_raw=${known_raw_c_symbol}, known_mangled=${known_mangled_symbol}]'
				if g.mod.type_store.types[val.typ].kind != .void_t {
					g.sb.writeln('\t// unresolved call ${fn_raw_name}${unresolved_hint} lowered to zero')
					g.sb.writeln('\t${res} = ${g.zero_value_expr(val.typ)};')
				} else {
					g.sb.writeln('\t// skipped unresolved call ${fn_name}${unresolved_hint}')
				}
				return
			}
			if has_impl && g.should_skip_sync_lock_call(resolved_fn_name, instr.operands) {
				g.sb.writeln('\t// skipped lock call on non-mutex shared storage')
				if !g.is_void_type(val.typ) && g.value_is_used(val.id) {
					g.sb.writeln('\t${res} = ${g.zero_value_expr(val.typ)};')
				}
				return
			}
			// Keep calls to libc symbols unmangled when there is no local implementation.
			// Also avoid self-recursion in wrappers like malloc/free/exit that forward to libc.
			mut emit_name := fn_name
			if !has_impl && known_raw_c_symbol {
				emit_name = raw_c_name
			} else if has_impl && known_raw_c_symbol && g.current_fn_name == fn_raw_name {
				emit_name = raw_c_name
			}

			mut args_str := []string{}
			if has_impl && prepend_implicit_first_arg && expected_param_types.len > 0 {
				args_str << g.zero_value_expr(expected_param_types[0])
			}
			expected_param_offset := if prepend_implicit_first_arg { 1 } else { 0 }
			for i := 1; i < instr.operands.len; i++ {
				param_idx := i - 1 + expected_param_offset
				if has_impl && param_idx >= expected_param_types.len {
					break
				}
				arg_id := instr.operands[i]
				mut arg_expr := g.val_str(arg_id)
				if param_idx < expected_param_types.len {
					actual_typ_id := if arg_id > 0 && arg_id < g.mod.values.len {
						g.mod.values[arg_id].typ
					} else {
						0
					}
					expected_typ_id := expected_param_types[param_idx]
					if g.should_pass_call_arg_by_ref(resolved_fn_name, param_idx, actual_typ_id,
						expected_typ_id)
					{
						arg_expr = g.ref_call_arg_expr(arg_expr, actual_typ_id)
						if expected_typ_id > 0 && expected_typ_id < g.mod.type_store.types.len {
							expected := g.mod.type_store.types[expected_typ_id]
							if expected.kind == .ptr_t {
								arg_expr = '(${g.type_name(expected_typ_id)})(${arg_expr})'
							}
						}
					} else {
						arg_expr = g.coerce_call_arg(arg_expr, actual_typ_id, expected_typ_id)
					}
				} else if !has_impl && known_c_symbol {
					arg_expr = g.coerce_known_c_symbol_arg(emit_name, i - 1, arg_expr)
				}
				args_str << arg_expr
			}
			if has_impl && args_str.len < expected_param_types.len {
				for i := args_str.len; i < expected_param_types.len; i++ {
					args_str << g.zero_value_expr(expected_param_types[i])
				}
			}
			if emit_name == 'mach_timebase_info' && args_str.len > 0 {
				mut arg0 := args_str[0]
				if !arg0.starts_with('&') {
					arg0 = '&(${arg0})'
				}
				args_str[0] = '(mach_timebase_info_t)(uintptr_t)(${arg0})'
			}
			args_c := args_str.join(', ')
			result_is_void := g.is_void_type(val.typ)
			needs_result := !result_is_void && g.value_is_used(val.id)
			mut callee_returns_void := false
			if has_callee_ret_typ {
				callee_returns_void = g.is_void_type(callee_ret_typ_id)
			} else {
				callee_returns_void = g.known_c_symbol_returns_void(emit_name)
			}
			if !has_impl && emit_name == 'pthread_self' {
				if needs_result {
					g.sb.writeln('\t${res} = (int64_t)(uintptr_t)${emit_name}(${args_c});')
				} else {
					g.sb.writeln('\t${emit_name}(${args_c});')
				}
				return
			}

			if callee_returns_void {
				g.sb.writeln('\t${emit_name}(${args_c});')
				if needs_result {
					g.sb.writeln('\t${res} = ${g.zero_value_expr(val.typ)};')
				}
			} else if needs_result {
				mut call_expr := '${emit_name}(${args_c})'
				if has_callee_ret_typ {
					call_expr = g.coerce_expr_to_type(call_expr, callee_ret_typ_id, val.typ)
				}
				g.sb.writeln('\t${res} = ${call_expr};')
			} else {
				g.sb.writeln('\t${emit_name}(${args_c});')
			}
		}
		.call_indirect {
			// Indirect call through function pointer
			// Operand 0: Function Pointer Value
			// Operands 1..N: Arguments
			fn_ptr := g.val_str(instr.operands[0])

			mut args_str := []string{}
			mut arg_types := []string{}
			for i := 1; i < instr.operands.len; i++ {
				arg_id := instr.operands[i]
				arg_typ_id := g.value_type_id(arg_id)
				mut arg_expr := g.val_str(arg_id)
				if arg_typ_id > 0 {
					arg_expr = g.coerce_expr_to_type(arg_expr, arg_typ_id, arg_typ_id)
					arg_types << g.type_name(arg_typ_id)
				} else {
					arg_expr = '(void*)(uintptr_t)(${arg_expr})'
					arg_types << 'void*'
				}
				args_str << arg_expr
			}
			args_c := args_str.join(', ')
			args_sig := if arg_types.len > 0 { arg_types.join(', ') } else { 'void' }
			ret_t := g.type_name(val.typ)

			if g.mod.type_store.types[val.typ].kind != .void_t {
				g.sb.writeln('\t${res} = ((${ret_t}(*)(${args_sig}))${fn_ptr})(${args_c});')
			} else {
				g.sb.writeln('\t((void(*)(${args_sig}))${fn_ptr})(${args_c});')
			}
		}
		.eq, .ne, .lt, .gt, .le, .ge {
			lhs_id := instr.operands[0]
			rhs_id := instr.operands[1]
			mut lhs := g.val_str(lhs_id)
			mut rhs := g.val_str(rhs_id)
			mut lhs_typ_id := g.value_type_id(lhs_id)
			mut rhs_typ_id := g.value_type_id(rhs_id)
			mut lhs_typ := if lhs_typ_id > 0 && lhs_typ_id < g.mod.type_store.types.len {
				g.mod.type_store.types[lhs_typ_id]
			} else {
				ssa.Type{
					kind: .void_t
				}
			}
			mut rhs_typ := if rhs_typ_id > 0 && rhs_typ_id < g.mod.type_store.types.len {
				g.mod.type_store.types[rhs_typ_id]
			} else {
				ssa.Type{
					kind: .void_t
				}
			}
			if lhs_typ.kind == .void_t {
				lhs = '0'
			}
			if rhs_typ.kind == .void_t {
				rhs = '0'
			}
			if lhs_typ.kind != .struct_t {
				if lhs_val_id := temp_value_id_from_expr(lhs) {
					alt_typ_id := g.value_type_id(lhs_val_id)
					if alt_typ_id > 0 && alt_typ_id < g.mod.type_store.types.len {
						alt_typ := g.mod.type_store.types[alt_typ_id]
						if alt_typ.kind == .struct_t {
							lhs_typ_id = alt_typ_id
							lhs_typ = alt_typ
						}
					}
				}
			}
			if rhs_typ.kind != .struct_t {
				if rhs_val_id := temp_value_id_from_expr(rhs) {
					alt_typ_id := g.value_type_id(rhs_val_id)
					if alt_typ_id > 0 && alt_typ_id < g.mod.type_store.types.len {
						alt_typ := g.mod.type_store.types[alt_typ_id]
						if alt_typ.kind == .struct_t {
							rhs_typ_id = alt_typ_id
							rhs_typ = alt_typ
						}
					}
				}
			}
			if lhs_typ.kind == .struct_t && rhs_typ.kind != .struct_t && rhs_typ_id > 0 {
				lhs = g.coerce_expr_to_type(lhs, lhs_typ_id, rhs_typ_id)
				lhs_typ_id = rhs_typ_id
				lhs_typ = rhs_typ
			}
			if rhs_typ.kind == .struct_t && lhs_typ.kind != .struct_t && lhs_typ_id > 0 {
				rhs = g.coerce_expr_to_type(rhs, rhs_typ_id, lhs_typ_id)
				rhs_typ_id = lhs_typ_id
				rhs_typ = lhs_typ
			}
			if instr.op in [.eq, .ne] && rhs == '0' {
				if lhs_val_id := temp_value_id_from_expr(lhs) {
					alt_typ_id := g.value_type_id(lhs_val_id)
					if alt_typ_id > 0 && alt_typ_id < g.mod.type_store.types.len {
						alt_typ := g.mod.type_store.types[alt_typ_id]
						if alt_typ.kind == .struct_t {
							lhs = g.struct_to_int_expr(lhs, alt_typ_id, false)
						}
					}
				}
			}
			if instr.op in [.eq, .ne] && lhs == '0' {
				if rhs_val_id := temp_value_id_from_expr(rhs) {
					alt_typ_id := g.value_type_id(rhs_val_id)
					if alt_typ_id > 0 && alt_typ_id < g.mod.type_store.types.len {
						alt_typ := g.mod.type_store.types[alt_typ_id]
						if alt_typ.kind == .struct_t {
							rhs = g.struct_to_int_expr(rhs, alt_typ_id, false)
						}
					}
				}
			}
			op_str := match instr.op {
				.eq { '==' }
				.ne { '!=' }
				.lt { '<' }
				.gt { '>' }
				.le { '<=' }
				.ge { '>=' }
				else { '==' }
			}
			if instr.op in [.eq, .ne] {
				if lhs_typ.kind == .struct_t && g.is_zero_like_value(rhs_id) {
					if g.is_string_type(lhs_typ_id) {
						g.sb.writeln('\t${res} = (${lhs}.str ${op_str} 0);')
					} else {
						g.sb.writeln('\t${res} = ${if instr.op == .eq { '0' } else { '1' }};')
					}
					return
				}
				if rhs_typ.kind == .struct_t && g.is_zero_like_value(lhs_id) {
					if g.is_string_type(rhs_typ_id) {
						g.sb.writeln('\t${res} = (${rhs}.str ${op_str} 0);')
					} else {
						g.sb.writeln('\t${res} = ${if instr.op == .eq { '0' } else { '1' }};')
					}
					return
				}
				if lhs_typ.kind == .struct_t && rhs_typ.kind == .struct_t {
					if g.is_string_type(lhs_typ_id) && g.is_string_type(rhs_typ_id) {
						if instr.op == .eq {
							g.sb.writeln('\t${res} = string__eq(&(${lhs}), &(${rhs}));')
						} else {
							g.sb.writeln('\t${res} = !string__eq(&(${lhs}), &(${rhs}));')
						}
					} else {
						g.sb.writeln('\t${res} = ${if instr.op == .eq { '0' } else { '1' }};')
					}
					return
				}
			}
			g.sb.writeln('\t${res} = (${lhs} ${op_str} ${rhs});')
		}
		.fptosi {
			// Float to signed integer conversion
			src := g.val_str(instr.operands[0])
			g.sb.writeln('\t${res} = (int64_t)${src};')
		}
		.trunc, .zext, .sext {
			if instr.operands.len == 0 {
				if g.should_skip_loop_header_zero_def(instr.block, val.id) {
					g.sb.writeln('\t// skipped zero default for carried value')
				} else {
					g.sb.writeln('\t${res} = ${g.zero_value_expr(val.typ)};')
				}
			} else {
				src := g.val_str(instr.operands[0])
				dst_t := g.type_name(val.typ)
				g.sb.writeln('\t${res} = (${dst_t})(${src});')
			}
		}
		.sitofp {
			// Signed integer to float conversion
			src := g.val_str(instr.operands[0])
			g.sb.writeln('\t${res} = (double)${src};')
		}
		.fptoui {
			// Float to unsigned integer conversion
			src := g.val_str(instr.operands[0])
			g.sb.writeln('\t${res} = (uint64_t)${src};')
		}
		.uitofp {
			// Unsigned integer to float conversion
			src := g.val_str(instr.operands[0])
			g.sb.writeln('\t${res} = (double)${src};')
		}
		.bitcast {
			if instr.operands.len == 0 {
				if g.should_skip_loop_header_zero_def(instr.block, val.id) {
					g.sb.writeln('\t// skipped zero bitcast for carried value')
				} else {
					g.sb.writeln('\t${res} = ${g.zero_value_expr(val.typ)};')
				}
			} else {
				src_id := instr.operands[0]
				src := g.val_str(src_id)
				src_typ := g.mod.values[src_id].typ
				g.sb.writeln('\t${res} = ${g.bitcast_expr(src, src_typ, val.typ)};')
			}
		}
		.br {
			cond_id := instr.operands[0]
			mut cond := g.val_str(cond_id)
			cond_typ_id := g.value_type_id(cond_id)
			if cond_typ_id > 0 && cond_typ_id < g.mod.type_store.types.len {
				cond_typ := g.mod.type_store.types[cond_typ_id]
				if cond_typ.kind == .struct_t {
					cond = g.struct_to_int_expr(cond, cond_typ_id, true)
				}
			}
			true_blk := g.get_block_name(instr.operands[1])
			false_blk := g.get_block_name(instr.operands[2])
			pred_blk_id := instr.block
			true_blk_id := g.block_id_from_block_value(instr.operands[1])
			false_blk_id := g.block_id_from_block_value(instr.operands[2])
			true_has_inits := g.edge_has_zero_inits(pred_blk_id, true_blk_id)
			false_has_inits := g.edge_has_zero_inits(pred_blk_id, false_blk_id)
			if !true_has_inits && !false_has_inits {
				g.sb.writeln('\tif (${cond}) goto ${true_blk}; else goto ${false_blk};')
			} else {
				g.sb.writeln('\tif (${cond}) {')
				g.emit_edge_zero_inits(pred_blk_id, true_blk_id)
				g.sb.writeln('\t\tgoto ${true_blk};')
				g.sb.writeln('\t} else {')
				g.emit_edge_zero_inits(pred_blk_id, false_blk_id)
				g.sb.writeln('\t\tgoto ${false_blk};')
				g.sb.writeln('\t}')
			}
		}
		.jmp {
			dest := g.get_block_name(instr.operands[0])
			pred_blk_id := instr.block
			dest_blk_id := g.block_id_from_block_value(instr.operands[0])
			g.emit_edge_zero_inits(pred_blk_id, dest_blk_id)
			g.sb.writeln('\tgoto ${dest};')
		}
		.ret {
			if instr.operands.len > 0 {
				if g.current_fn_ret == 0 {
					// Some SSA paths carry a value even for void-return functions.
					if g.current_fn_name == 'main' {
						g.sb.writeln('\treturn 0;')
					} else {
						g.sb.writeln('\treturn;')
					}
					return
				}
				ret_val_id := instr.operands[0]
				ret_val := g.mod.values[ret_val_id]
				ret_val_typ := g.mod.type_store.types[ret_val.typ]
				v := g.val_str(ret_val_id)
				current_ret_typ := g.mod.type_store.types[g.current_fn_ret]
				if g.current_fn_ret != 0 && current_ret_typ.kind == .struct_t {
					is_struct_ptr := ret_val_typ.kind == .ptr_t && ret_val_typ.elem_type > 0
						&& ret_val_typ.elem_type < g.mod.type_store.types.len
						&& g.mod.type_store.types[ret_val_typ.elem_type].kind == .struct_t
					if v == '0' || (ret_val.kind == .constant && ret_val.name == '0')
						|| (ret_val_typ.kind != .struct_t && !is_struct_ptr) {
						if fallback := g.fallback_struct_return_expr() {
							g.sb.writeln('\treturn ${fallback};')
						} else {
							g.sb.writeln('\treturn ${g.zero_value_expr(g.current_fn_ret)};')
						}
						return
					}
				}
				if ret_val_typ.kind == .void_t && g.current_fn_ret != 0 {
					g.sb.writeln('\treturn ${g.zero_value_expr(g.current_fn_ret)};')
					return
				}
				if g.current_fn_ret != 0 && ret_val.typ != g.current_fn_ret {
					if current_ret_typ.kind == .struct_t && ret_val_typ.kind == .ptr_t
						&& ret_val_typ.elem_type == g.current_fn_ret {
						if v == '0' || v == 'NULL' {
							g.sb.writeln('\treturn ${g.zero_value_expr(g.current_fn_ret)};')
						} else {
							g.sb.writeln('\treturn *${v};')
						}
						return
					}
					if current_ret_typ.kind == .struct_t || ret_val_typ.kind == .struct_t {
						if current_ret_typ.kind == .struct_t {
							if fallback := g.fallback_struct_return_expr() {
								g.sb.writeln('\treturn ${fallback};')
							} else {
								g.sb.writeln('\treturn ${g.zero_value_expr(g.current_fn_ret)};')
							}
						} else {
							g.sb.writeln('\treturn ${g.zero_value_expr(g.current_fn_ret)};')
						}
					} else {
						g.sb.writeln('\treturn (${g.type_name(g.current_fn_ret)})(${v});')
					}
					return
				}

				// Check if we're returning a pointer to a struct but the function returns struct by value
				// This happens when the return value is a pointer and the pointed-to type is a struct
				if ret_val_typ.kind == .ptr_t {
					elem_typ := g.mod.type_store.types[ret_val_typ.elem_type]
					if elem_typ.kind == .struct_t && current_ret_typ.kind == .struct_t {
						// Dereference the pointer to return struct by value
						if v == '0' || v == 'NULL' {
							g.sb.writeln('\treturn ${g.zero_value_expr(g.current_fn_ret)};')
						} else {
							g.sb.writeln('\treturn *${v};')
						}
					} else {
						g.sb.writeln('\treturn ${v};')
					}
				} else {
					g.sb.writeln('\treturn ${v};')
				}
			} else {
				if g.current_fn_name == 'main' {
					g.sb.writeln('\treturn 0;')
				} else if g.current_fn_ret != 0 {
					g.sb.writeln('\treturn ${g.zero_value_expr(g.current_fn_ret)};')
				} else {
					g.sb.writeln('\treturn;')
				}
			}
		}
		.get_element_ptr {
			base_val_id := instr.operands[0]
			if base_val_id <= 0 || base_val_id >= g.mod.values.len {
				g.sb.writeln('\t${res} = NULL;')
				return
			}
			if g.is_zero_like_value(base_val_id) {
				g.sb.writeln('\t${res} = NULL;')
				return
			}
			base := g.val_str(base_val_id)
			base_val := g.mod.values[base_val_id]
			base_val_typ := base_val.typ
			elem_type_id := g.mod.type_store.types[base_val_typ].elem_type
			elem_type := g.mod.type_store.types[elem_type_id]

			if elem_type.kind == .struct_t {
				// Get field name - use named field if available, otherwise fall back to field_N
				idx := g.extract_index(instr.operands[1])
				field_name := g.struct_field_name(elem_type, idx)
				// For globals, the C declaration is not a pointer, so use '.' instead of '->'
				if base_val.kind == .global {
					g.sb.writeln('\t${res} = &${base}.${field_name};')
				} else {
					g.sb.writeln('\t${res} = &(${base})->${field_name};')
				}
			} else {
				idx_id := instr.operands[1]
				mut idx := g.val_str(idx_id)
				mut base_expr := base
				idx_typ_id := g.value_type_id(idx_id)
				if idx_typ_id > 0 && idx_typ_id < g.mod.type_store.types.len {
					idx_typ := g.mod.type_store.types[idx_typ_id]
					if idx_typ.kind in [.ptr_t, .array_t] {
						idx = '(int64_t)(uintptr_t)(${idx})'
					} else if idx_typ.kind == .struct_t {
						idx = '0'
					}
				}
				if base_val_typ > 0 && base_val_typ < g.mod.type_store.types.len {
					base_typ := g.mod.type_store.types[base_val_typ]
					if base_val.kind == .global {
						base_expr = '((uint8_t*)(&${base}))'
					} else if base_typ.kind == .struct_t {
						if g.is_string_type(base_val_typ) {
							base_expr = '((uint8_t*)(${base}.str))'
						} else if base_typ.fields.len > 0 && base_typ.fields[0] > 0
							&& base_typ.fields[0] < g.mod.type_store.types.len
							&& g.mod.type_store.types[base_typ.fields[0]].kind == .ptr_t {
							data_field := g.struct_field_name(base_typ, 0)
							base_expr = '((uint8_t*)(${base}.${data_field}))'
						} else {
							base_expr = '((uint8_t*)(&(${base})))'
						}
					} else if base_typ.kind !in [.ptr_t, .array_t] {
						base_expr = '((uint8_t*)(uintptr_t)(${base}))'
					}
				}
				gep_expr := '&${base_expr}[${idx}]'
				g.sb.writeln('\t${res} = ${g.coerce_expr_to_type(gep_expr, 0, val.typ)};')
			}
		}
		.switch_ {
			cond := g.val_str(instr.operands[0])
			g.sb.writeln('\tswitch (${cond}) {')
			// Operands: 0=cond, 1=def, 2=val, 3=blk, 4=val, 5=blk...
			for i := 2; i < instr.operands.len; i += 2 {
				val2 := g.val_str(instr.operands[i])
				blk_val_id := instr.operands[i + 1]
				blk_name := g.get_block_name(blk_val_id)
				g.sb.writeln('\tcase ${val2}: goto ${blk_name};')
			}
			def_blk_val_id := instr.operands[1]
			def_name := g.get_block_name(def_blk_val_id)
			g.sb.writeln('\tdefault: goto ${def_name};')
			g.sb.writeln('\t}')
		}
		.phi {
			// Phi node: operands are pairs of (value, block)
			// For C, we emit assignments before jumps in predecessors
			// Here we just declare the variable (already done above)
			// The actual assignments are handled by .assign opcodes
		}
		.select {
			// select cond, true_val, false_val
			cond := g.val_str(instr.operands[0])
			true_val := g.val_str(instr.operands[1])
			false_val := g.val_str(instr.operands[2])
			g.sb.writeln('\t${res} = ${cond} ? ${true_val} : ${false_val};')
		}
		.unreachable {
			// Unreachable code - typically after abort/exit
			g.sb.writeln('\t__builtin_unreachable();')
		}
		.inline_string_init {
			// Create string struct by value: (string){str, len, is_lit}
			str_ptr := g.val_str(instr.operands[0])
			len_val := g.val_str(instr.operands[1])
			is_lit := g.val_str(instr.operands[2])
			val_typ := g.mod.type_store.types[val.typ]
			if val_typ.kind == .ptr_t && g.is_string_type(val_typ.elem_type) {
				g.sb.writeln('\t${res} = &((string){(int8_t*)${str_ptr}, ${len_val}, ${is_lit}});')
			} else {
				g.sb.writeln('\t${res} = (string){(int8_t*)${str_ptr}, ${len_val}, ${is_lit}};')
			}
		}
		.extractvalue {
			if g.mod.type_store.types[val.typ].kind == .void_t {
				g.sb.writeln('\t${res} = NULL;')
				return
			}
			if instr.operands.len < 2 {
				g.sb.writeln('\t${res} = ${g.zero_value_expr(val.typ)};')
			} else {
				base_id := instr.operands[0]
				base := g.val_str(base_id)
				idx := g.extract_index(instr.operands[1])
				base_typ_id := g.mod.values[base_id].typ
				base_typ := g.mod.type_store.types[base_typ_id]
				if base_typ.kind == .ptr_t {
					elem_typ := g.mod.type_store.types[base_typ.elem_type]
					if elem_typ.kind == .array_t {
						field_typ_id := elem_typ.elem_type
						elem_expr := '((${g.type_name(field_typ_id)}*)(${base}))[${idx}]'
						g.sb.writeln('\t${res} = ${g.coerce_expr_to_type(elem_expr, field_typ_id,
							val.typ)};')
					} else {
						field_name := g.struct_field_name(elem_typ, idx)
						field_typ_id := if idx >= 0 && idx < elem_typ.fields.len {
							elem_typ.fields[idx]
						} else {
							0
						}
						field_expr := '${base}->${field_name}'
						g.sb.writeln('\t${res} = ${g.coerce_expr_to_type(field_expr, field_typ_id,
							val.typ)};')
					}
				} else if base_typ.kind == .array_t {
					field_typ_id := base_typ.elem_type
					elem_expr := '${base}[${idx}]'
					g.sb.writeln('\t${res} = ${g.coerce_expr_to_type(elem_expr, field_typ_id,
						val.typ)};')
				} else if base_typ.kind == .struct_t {
					field_name := g.struct_field_name(base_typ, idx)
					field_typ_id := if idx >= 0 && idx < base_typ.fields.len {
						base_typ.fields[idx]
					} else {
						0
					}
					field_expr := '${base}.${field_name}'
					g.sb.writeln('\t${res} = ${g.coerce_expr_to_type(field_expr, field_typ_id,
						val.typ)};')
				} else {
					g.sb.writeln('\t${res} = ${g.zero_value_expr(val.typ)};')
				}
			}
		}
		.insertvalue {
			if instr.operands.len < 3 {
				g.sb.writeln('\t${res} = ${g.zero_value_expr(val.typ)};')
			} else {
				agg_id := instr.operands[0]
				insert_id := instr.operands[1]
				agg := g.val_str(agg_id)
				mut insert_val := g.val_str(insert_id)
				insert_typ_id := g.value_type_id(insert_id)
				idx := g.extract_index(instr.operands[2])
				agg_typ_id := g.mod.values[agg_id].typ
				agg_typ := g.mod.type_store.types[agg_typ_id]
				if agg_typ.kind == .ptr_t {
					elem_typ := g.mod.type_store.types[agg_typ.elem_type]
					if elem_typ.kind == .array_t {
						elem_typ_name := g.type_name(elem_typ.elem_type)
						insert_val = g.coerce_expr_to_type(insert_val, insert_typ_id,
							elem_typ.elem_type)
						g.sb.writeln('\t${res} = *${agg};')
						g.sb.writeln('\t((${elem_typ_name}*)(&(${res})))[${idx}] = ${insert_val};')
					} else {
						field_name := g.struct_field_name(elem_typ, idx)
						field_typ_id := if idx >= 0 && idx < elem_typ.fields.len {
							elem_typ.fields[idx]
						} else {
							0
						}
						insert_val = g.coerce_expr_to_type(insert_val, insert_typ_id,
							field_typ_id)
						g.sb.writeln('\t${res} = *${agg};')
						g.sb.writeln('\t${res}.${field_name} = ${insert_val};')
					}
				} else if agg_typ.kind == .array_t {
					elem_typ_name := g.type_name(agg_typ.elem_type)
					insert_val = g.coerce_expr_to_type(insert_val, insert_typ_id, agg_typ.elem_type)
					g.sb.writeln('\t${res} = ${agg};')
					g.sb.writeln('\t((${elem_typ_name}*)(&(${res})))[${idx}] = ${insert_val};')
				} else {
					field_name := g.struct_field_name(agg_typ, idx)
					field_typ_id := if idx >= 0 && idx < agg_typ.fields.len {
						agg_typ.fields[idx]
					} else {
						0
					}
					insert_val = g.coerce_expr_to_type(insert_val, insert_typ_id, field_typ_id)
					g.sb.writeln('\t${res} = ${agg};')
					g.sb.writeln('\t${res}.${field_name} = ${insert_val};')
				}
			}
		}
		else {
			g.sb.writeln('\t// Unhandled C op: ${instr.op}')
		}
	}
}

// Helpers
fn (g Gen) type_name(id int) string {
	t := g.mod.type_store.types[id]
	match t.kind {
		.void_t {
			return 'void'
		}
		.int_t {
			if t.width == 1 {
				return 'bool'
			}
			return 'int${t.width}_t'
		}
		.float_t {
			return if t.width == 32 { 'float' } else { 'double' }
		}
		.ptr_t {
			// Check if pointing to an array - if so, just use pointer to element type
			elem_t := g.mod.type_store.types[t.elem_type]
			if elem_t.kind == .array_t {
				return g.type_name(elem_t.elem_type) + '*'
			}
			// Check if pointing to string struct
			if g.is_string_type(t.elem_type) {
				return 'string*'
			}
			return g.type_name(t.elem_type) + '*'
		}
		.array_t {
			return g.type_name(t.elem_type) + '*'
		} // Arrays decay to pointers
		.struct_t {
			// Check for builtin string type
			if g.is_string_type(id) {
				return 'string'
			}
			return 'Struct_${id}'
		}
		else {
			return 'void'
		}
	}
}

fn (mut g Gen) val_str(id int) string {
	if id <= 0 || id >= g.mod.values.len {
		return '0'
	}
	val := g.mod.values[id]
	if val.kind == .constant {
		if val.name == 'undef' {
			return g.zero_value_expr(val.typ)
		}
		if is_wrapped_c_string_literal(val.name) {
			return normalize_c_string_literal(val.name)
		}
		if looks_like_numeric_literal(val.name) {
			return normalize_numeric_literal(val.name)
		}
		return val.name
	} else if val.kind == .argument {
		return g.arg_name(val)
	} else if val.kind == .global {
		if val.index >= 0 && val.index < g.global_c_names.len {
			return g.global_c_names[val.index]
		}
		return sanitize_c_ident(val.name, 'g_${val.id}')
	} else if val.kind == .func_ref {
		if _ := g.find_function(val.name) {
			return g.mangle_fn_name(val.name)
		}
		raw_c_name := sanitize_c_ident(val.name, 'fn')
		if g.is_known_c_symbol(raw_c_name) {
			return raw_c_name
		}
		mangled := g.mangle_fn_name(val.name)
		if g.is_known_c_symbol(mangled) {
			return mangled
		}
		return mangled
	} else if val.kind == .string_literal {
		// String literal: val.name contains text, val.index contains length.
		escaped := escape_c_string_literal(val.name)
		typ := g.mod.type_store.types[val.typ]
		if typ.kind == .ptr_t && g.is_string_type(typ.elem_type) {
			return '&((string){"${escaped}", ${val.index}, 1})'
		}
		return '(string){"${escaped}", ${val.index}, 1}'
	}
	return '_v${val.id}'
}

fn is_wrapped_c_string_literal(s string) bool {
	return s.len >= 2 && s[0] == `"` && s[s.len - 1] == `"`
}

fn normalize_c_string_literal(s string) string {
	if !is_wrapped_c_string_literal(s) {
		return s
	}
	inner := s[1..s.len - 1]
	return '"${escape_c_string_literal(inner)}"'
}

fn normalize_numeric_literal(s string) string {
	lit := s.replace('_', '')
	if lit.len == 0 {
		return lit
	}
	mut sign := ''
	mut body := lit
	if body[0] in [`+`, `-`] {
		sign = body[..1]
		body = body[1..]
	}
	if body.starts_with('0o') || body.starts_with('0O') {
		if body.len > 2 {
			return sign + '0' + body[2..]
		}
		return sign + '0'
	}
	return sign + body
}

fn looks_like_numeric_literal(s string) bool {
	if s.len == 0 {
		return false
	}
	mut i := 0
	if s[0] == `+` || s[0] == `-` {
		if s.len == 1 {
			return false
		}
		i = 1
	}
	if i >= s.len {
		return false
	}
	first := s[i]
	mut has_digit := first >= `0` && first <= `9`
	if !has_digit && first != `.` {
		return false
	}
	for ch in s.bytes()[i..] {
		if (ch >= `0` && ch <= `9`) || (ch >= `a` && ch <= `f`)
			|| (ch >= `A` && ch <= `F`)
			|| ch in [`_`, `.`, `x`, `X`, `o`, `O`, `b`, `B`, `p`, `P`, `e`, `E`, `+`, `-`] {
			if ch >= `0` && ch <= `9` {
				has_digit = true
			}
			continue
		}
		return false
	}
	return has_digit
}

fn (g Gen) get_block_name(val_id int) string {
	// In the block arena value wrapper, we stored block index in .index
	val := g.mod.values[val_id]
	blk := g.mod.blocks[val.index]
	return blk.name
}

fn (g Gen) op_sym(op ssa.OpCode) string {
	return match op {
		.add, .fadd { '+' }
		.sub, .fsub { '-' }
		.mul, .fmul { '*' }
		.sdiv, .udiv, .fdiv { '/' }
		.srem, .urem { '%' }
		else { '?' }
	}
}

fn (g Gen) value_type_id(id int) int {
	if id <= 0 || id >= g.mod.values.len {
		return 0
	}
	return g.mod.values[id].typ
}

fn temp_value_id_from_expr(expr string) ?int {
	if !expr.starts_with('_v') {
		return none
	}
	digits := expr[2..]
	if digits.len == 0 {
		return none
	}
	for ch in digits.bytes() {
		if ch < `0` || ch > `9` {
			return none
		}
	}
	return digits.int()
}

fn (g Gen) is_zero_like_value(id int) bool {
	if id <= 0 || id >= g.mod.values.len {
		return true
	}
	val := g.mod.values[id]
	return val.kind == .constant && (val.name == '0' || val.name == 'NULL')
}

fn (mut g Gen) int_op_operand_str(id int) string {
	expr := g.val_str(id)
	typ_id := g.value_type_id(id)
	if typ_id <= 0 || typ_id >= g.mod.type_store.types.len {
		return '0'
	}
	typ := g.mod.type_store.types[typ_id]
	match typ.kind {
		.void_t {
			return '0'
		}
		.ptr_t, .array_t {
			return '(uintptr_t)(${expr})'
		}
		.float_t {
			return '(int64_t)(${expr})'
		}
		.struct_t {
			return '0'
		}
		else {
			return expr
		}
	}
}

fn (g Gen) cast_int_expr_to_type(expr string, typ_id int) string {
	if typ_id == 0 {
		return '(void*)(uintptr_t)(${expr})'
	}
	if typ_id < 0 || typ_id >= g.mod.type_store.types.len {
		return expr
	}
	typ := g.mod.type_store.types[typ_id]
	match typ.kind {
		.ptr_t, .array_t {
			return '(${g.type_name(typ_id)})(uintptr_t)(${expr})'
		}
		.struct_t {
			return g.zero_value_expr(typ_id)
		}
		else {
			return '(${g.type_name(typ_id)})(${expr})'
		}
	}
}

fn (mut g Gen) init_global_names() {
	mut used := map[string]bool{}
	g.global_c_names = []string{len: g.mod.globals.len}
	for i, gvar in g.mod.globals {
		safe := sanitize_c_ident(gvar.name, 'global_${i}')
		base := if gvar.linkage == .external { safe } else { 'v_g_${safe}' }
		mut name := base
		mut suffix := 1
		for {
			if name !in used {
				break
			}
			name = '${base}_${suffix}'
			suffix++
		}
		used[name] = true
		g.global_c_names[i] = name
	}
}

fn (g Gen) global_name_by_source(raw_name string) ?string {
	for i, gvar in g.mod.globals {
		if gvar.name == raw_name {
			return g.global_c_names[i]
		}
	}
	return none
}

fn (mut g Gen) gen_runtime_stubs() {
	// Minimal builtin stubs for standalone/small programs.
	g.sb.writeln('// Minimal builtin stubs')
	if !g.has_function('println') {
		g.sb.writeln('static inline int64_t println(string s) { printf("%.*s\\n", (int)s.len, (char*)s.str); return 0; }')
	}
	if !g.has_function('print') {
		g.sb.writeln('static inline int64_t print(string s) { printf("%.*s", (int)s.len, (char*)s.str); return 0; }')
	}
	if !g.has_function('eprintln') {
		g.sb.writeln('static inline int64_t eprintln(string s) { fprintf(stderr, "%.*s\\n", (int)s.len, (char*)s.str); return 0; }')
	}
	if !g.has_function('malloc_noscan') {
		g.sb.writeln('static inline void* malloc_noscan(int64_t size) { return malloc(size); }')
	}
	if !g.has_function('v__malloc') {
		g.sb.writeln('static inline void* v__malloc(int64_t size) { return malloc(size); }')
	}
	if !g.has_function('vcalloc') {
		g.sb.writeln('static inline void* vcalloc(int64_t size) { return calloc(1, size); }')
	}
	if !g.has_function('vcalloc_noscan') {
		g.sb.writeln('static inline void* vcalloc_noscan(int64_t size) { return calloc(1, size); }')
	}
	if !g.has_function('v_realloc') {
		g.sb.writeln('static inline int64_t v_realloc(void* old_data, int64_t new_size) { return (int64_t)(uintptr_t)realloc(old_data, new_size); }')
	}
	if !g.has_function('realloc_data') {
		g.sb.writeln('static inline int64_t realloc_data(void* old_data, int64_t old_size, int64_t new_size) { (void)old_size; return (int64_t)(uintptr_t)realloc(old_data, new_size); }')
	}
	if !g.has_function('__at_least_one') {
		g.sb.writeln('static inline int64_t __at_least_one(int64_t n) { return n > 0 ? n : 1; }')
	}
	if !g.has_function('vmemcpy') {
		g.sb.writeln('static inline void* vmemcpy(void* dest, const void* src, int64_t n) { return memcpy(dest, src, n); }')
	}
	if !g.has_function('vmemset') {
		g.sb.writeln('static inline void* vmemset(void* dest, int c, int64_t n) { return memset(dest, c, n); }')
	}
	if !g.has_function('vmemmove') {
		g.sb.writeln('static inline void* vmemmove(void* dest, const void* src, int64_t n) { return memmove(dest, src, n); }')
	}
	if !g.has_function('v__puts') {
		g.sb.writeln('static inline int64_t v__puts(int8_t* s) { return puts((char*)s); }')
	}
	if !g.has_function('v__sprintf') {
		g.sb.writeln('#define v__sprintf sprintf')
	}
	g.sb.writeln('')
}

fn (mut g Gen) has_function(name string) bool {
	if _ := g.function_index(name) {
		return true
	}
	return false
}

fn (g Gen) is_known_c_symbol(name string) bool {
	return match name {
		'malloc', 'calloc', 'realloc', 'free', 'strlen', 'strcmp', 'strncmp', 'strcpy', 'strncpy',
		'strcat', 'memcpy', 'memset', 'memmove', 'memcmp', 'puts', 'putchar', 'printf', 'fprintf',
		'sprintf', 'snprintf', 'asprintf', 'fwrite', 'fflush', 'write', 'read', 'open', 'close',
		'fopen', 'fclose', 'fseek', 'ftell', 'feof', 'ferror', 'rewind', 'getline', 'remove',
		'popen', 'pclose', 'ftruncate', 'getcwd', 'getenv', 'setenv', 'unsetenv', 'realpath',
		'access', 'stat', 'lstat', 'opendir', 'readdir', 'closedir', 'getpid', 'wait', 'isatty',
		'clock_gettime', 'localtime_r', 'timegm', 'strerror', 'proc_pidpath', 'atexit',
		'WIFEXITED', 'WEXITSTATUS', 'WIFSIGNALED', 'WTERMSIG', 'mach_absolute_time',
		'mach_timebase_info', 'pthread_self', 'exit', 'abort', 'fmod', 'fabs', 'floor', 'ceil',
		'sqrt', 'println', 'print', 'eprintln', 'malloc_noscan', 'v__malloc', 'vcalloc',
		'vcalloc_noscan', '__at_least_one', 'vmemcpy', 'vmemset', 'vmemmove', 'v__puts',
		'v__sprintf', 'v_realloc', 'realloc_data' {
			true
		}
		else {
			false
		}
	}
}

fn (g Gen) known_c_symbol_returns_void(name string) bool {
	return match name {
		'exit', 'abort' { true }
		else { false }
	}
}

fn (g Gen) coerce_known_c_symbol_arg(name string, arg_index int, arg_expr string) string {
	return match name {
		'fseek' {
			if arg_index == 2 {
				'(int)(${arg_expr})'
			} else {
				arg_expr
			}
		}
		'strerror' {
			if arg_index == 0 {
				'(int)(${arg_expr})'
			} else {
				arg_expr
			}
		}
		'clock_gettime' {
			if arg_index == 0 {
				'(clockid_t)(${arg_expr})'
			} else {
				arg_expr
			}
		}
		'open' {
			if arg_index == 1 || arg_index == 2 {
				'(int)(${arg_expr})'
			} else {
				arg_expr
			}
		}
		else {
			arg_expr
		}
	}
}

fn (g Gen) should_skip_sync_lock_call(fn_name string, operands []ssa.ValueID) bool {
	if !(fn_name.ends_with('RwMutex_rlock') || fn_name.ends_with('RwMutex_runlock')
		|| fn_name.ends_with('RwMutex_lock') || fn_name.ends_with('RwMutex_unlock')) {
		return false
	}
	if operands.len < 2 {
		return false
	}
	arg_id := operands[1]
	if arg_id <= 0 || arg_id >= g.mod.values.len {
		return false
	}
	arg_typ_id := g.mod.values[arg_id].typ
	if arg_typ_id <= 0 || arg_typ_id >= g.mod.type_store.types.len {
		return false
	}
	arg_typ := g.mod.type_store.types[arg_typ_id]
	if arg_typ.kind != .ptr_t || arg_typ.elem_type <= 0
		|| arg_typ.elem_type >= g.mod.type_store.types.len {
		return false
	}
	elem := g.mod.type_store.types[arg_typ.elem_type]
	// Shared values are currently lowered as direct struct storage in SSA C.
	// Calling sync RwMutex APIs on them corrupts the value memory.
	return elem.kind == .struct_t
}

fn (mut g Gen) find_function(name string) ?ssa.Function {
	if idx := g.function_index(name) {
		return g.mod.funcs[idx]
	}
	return none
}

fn (mut g Gen) resolve_function(name string, arg_ids []ssa.ValueID, expected_ret_typ_id int) ?ssa.Function {
	arg_count := arg_ids.len
	mut match_idxs := []int{cap: 4}
	g.add_call_candidates_by_name(mut match_idxs, name, arg_count)
	if !name.starts_with('builtin__') {
		g.add_call_candidates_by_name(mut match_idxs, 'builtin__${name}', arg_count)
	}
	// Fast path: when we already have direct matches, avoid broad suffix scans.
	// Suffix matching is only needed for unresolved/raw method names like `msg`.
	if match_idxs.len == 1 {
		return g.mod.funcs[match_idxs[0]]
	}
	if match_idxs.len > 1 {
		if best_idx := g.best_function_match_idx(match_idxs, arg_ids, name, expected_ret_typ_id) {
			return g.mod.funcs[best_idx]
		}
	}
	// When a call was already lowered to `Type__method`, also consider all
	// `*__method` candidates and pick by receiver argument type compatibility.
	suffix_name := if name.contains('__') { name.all_after_last('__') } else { name }
	if suffix_name in g.fn_suffix_lookup {
		for idx in g.fn_suffix_lookup[suffix_name] {
			if g.has_matching_call_arity(idx, arg_count) {
				g.add_unique_call_candidate_idx(mut match_idxs, idx)
			}
		}
	}
	if match_idxs.len == 0 {
		return none
	}
	if best_idx := g.best_function_match_idx(match_idxs, arg_ids, name, expected_ret_typ_id) {
		return g.mod.funcs[best_idx]
	}
	return none
}

fn (mut g Gen) function_index(name string) ?int {
	if name in g.fn_lookup {
		idx := g.fn_lookup[name]
		if idx >= 0 && idx < g.mod.funcs.len {
			return idx
		}
		return none
	}
	// Fallback for uncached aliases, then memoize miss/hit to avoid repeated scans.
	for i, f in g.mod.funcs {
		mangled := if i >= 0 && i < g.fn_mangled_names.len {
			g.fn_mangled_names[i]
		} else {
			g.mangle_fn_name(f.name)
		}
		if f.name == name || mangled == name {
			g.fn_lookup[name] = i
			return i
		}
	}
	g.fn_lookup[name] = -1
	return none
}

fn (g Gen) has_constructor_receiver_shape(func ssa.Function) bool {
	if !func.name.contains('__new') {
		return false
	}
	params := g.signature_params(func)
	if params.len == 0 {
		return false
	}
	first_param := params[0]
	if first_param <= 0 || first_param >= g.mod.values.len {
		return false
	}
	first_typ_id := g.mod.values[first_param].typ
	if first_typ_id <= 0 || first_typ_id >= g.mod.type_store.types.len {
		return false
	}
	first_typ := g.mod.type_store.types[first_typ_id]
	if first_typ.kind != .ptr_t || first_typ.elem_type <= 0
		|| first_typ.elem_type >= g.mod.type_store.types.len {
		return false
	}
	ret_typ_id := func.typ
	if ret_typ_id <= 0 || ret_typ_id >= g.mod.type_store.types.len {
		return false
	}
	ret_typ := g.mod.type_store.types[ret_typ_id]
	if ret_typ.kind == .ptr_t {
		return ret_typ.elem_type == first_typ.elem_type
	}
	return ret_typ.kind == .struct_t && ret_typ_id == first_typ.elem_type
}

fn (g Gen) uses_implicit_constructor_receiver_arg(func ssa.Function, arg_count int) bool {
	params := g.signature_params(func)
	return params.len == arg_count + 1 && g.has_constructor_receiver_shape(func)
}

fn (g Gen) has_matching_call_arity(func_idx int, arg_count int) bool {
	if func_idx < 0 || func_idx >= g.mod.funcs.len {
		return false
	}
	func := g.mod.funcs[func_idx]
	param_len := g.signature_params(func).len
	if param_len == arg_count {
		return true
	}
	return g.uses_implicit_constructor_receiver_arg(func, arg_count)
}

fn (g Gen) add_unique_call_candidate_idx(mut candidate_idxs []int, idx int) {
	for existing in candidate_idxs {
		if existing == idx {
			return
		}
	}
	candidate_idxs << idx
}

fn (mut g Gen) add_call_candidate_idx(mut candidate_idxs []int, name string, arg_count int) {
	if idx := g.function_index(name) {
		if g.has_matching_call_arity(idx, arg_count) {
			g.add_unique_call_candidate_idx(mut candidate_idxs, idx)
		}
	}
}

fn (mut g Gen) add_call_candidates_by_name(mut candidate_idxs []int, name string, arg_count int) {
	if name in g.fn_exact_lookup {
		for idx in g.fn_exact_lookup[name] {
			if g.has_matching_call_arity(idx, arg_count) {
				g.add_unique_call_candidate_idx(mut candidate_idxs, idx)
			}
		}
		return
	}
	g.add_call_candidate_idx(mut candidate_idxs, name, arg_count)
}

fn (g Gen) best_function_match_idx(candidate_idxs []int, arg_ids []ssa.ValueID, preferred_name string, expected_ret_typ_id int) ?int {
	if candidate_idxs.len == 0 {
		return none
	}
	mut best_func_idx := -1
	mut best_score := -1_000_000
	mut tie := false
	for func_idx in candidate_idxs {
		score := g.function_match_score(func_idx, arg_ids, preferred_name, expected_ret_typ_id)
		if score > best_score {
			best_score = score
			best_func_idx = func_idx
			tie = false
			continue
		}
		if score == best_score {
			if best_func_idx >= 0 && !g.mod.funcs[best_func_idx].name.starts_with('builtin__')
				&& g.mod.funcs[func_idx].name.starts_with('builtin__') {
				best_func_idx = func_idx
				tie = false
			} else {
				tie = true
			}
		}
	}
	if best_func_idx < 0 {
		return none
	}
	if !tie {
		return best_func_idx
	}
	for func_idx in candidate_idxs {
		if g.mod.funcs[func_idx].name.starts_with('builtin__') {
			return func_idx
		}
	}
	return best_func_idx
}

fn (g Gen) function_match_score(func_idx int, arg_ids []ssa.ValueID, preferred_name string, expected_ret_typ_id int) int {
	if func_idx < 0 || func_idx >= g.mod.funcs.len {
		return -1_000_000
	}
	func := g.mod.funcs[func_idx]
	params := g.signature_params(func)
	implicit_first_arg := g.uses_implicit_constructor_receiver_arg(func, arg_ids.len)
	param_offset := if implicit_first_arg { 1 } else { 0 }
	usable_param_len := if params.len > param_offset { params.len - param_offset } else { 0 }
	max_len := if usable_param_len < arg_ids.len { usable_param_len } else { arg_ids.len }
	mut score := 0
	for i in 0 .. max_len {
		param_id := params[i + param_offset]
		arg_id := arg_ids[i]
		if param_id <= 0 || param_id >= g.mod.values.len || arg_id <= 0
			|| arg_id >= g.mod.values.len {
			continue
		}
		expected_typ_id := g.mod.values[param_id].typ
		actual_typ_id := g.mod.values[arg_id].typ
		mut arg_score := g.call_arg_type_match_score(actual_typ_id, expected_typ_id)
		// Receiver type is the strongest signal for unresolved method names.
		if i == 0 {
			arg_score *= 4
		}
		score += arg_score
	}
	if expected_ret_typ_id > 0 {
		ret_score := g.call_arg_type_match_score(func.typ, expected_ret_typ_id)
		score += ret_score * 5
	}
	if implicit_first_arg {
		score += 20
	}
	if func.name.starts_with('builtin__') {
		score += 1
	}
	mangled_name := if func_idx >= 0 && func_idx < g.fn_mangled_names.len {
		g.fn_mangled_names[func_idx]
	} else {
		g.mangle_fn_name(func.name)
	}
	if func.name == preferred_name || mangled_name == preferred_name {
		score += 200
	}
	return score
}

fn (g Gen) call_arg_type_match_score(actual_typ_id int, expected_typ_id int) int {
	if actual_typ_id == expected_typ_id && actual_typ_id > 0 {
		return 100
	}
	if actual_typ_id <= 0 || expected_typ_id <= 0 || actual_typ_id >= g.mod.type_store.types.len
		|| expected_typ_id >= g.mod.type_store.types.len {
		return 0
	}
	actual := g.mod.type_store.types[actual_typ_id]
	expected := g.mod.type_store.types[expected_typ_id]
	if expected.kind == .ptr_t {
		if actual.kind == .ptr_t {
			if expected.elem_type > 0 && actual.elem_type == expected.elem_type {
				return 95
			}
			if expected.elem_type == 0 {
				return 40
			}
			return 20
		}
		if expected.elem_type > 0 && actual_typ_id == expected.elem_type {
			return 90
		}
		return 5
	}
	if actual.kind == .ptr_t {
		if actual.elem_type > 0 && actual.elem_type == expected_typ_id {
			return 80
		}
		return 5
	}
	if actual.kind == expected.kind {
		return 40
	}
	if actual.kind == .int_t && expected.kind == .float_t {
		return 10
	}
	if actual.kind == .float_t && expected.kind == .int_t {
		return 10
	}
	return 0
}

fn (g Gen) effective_params(func ssa.Function) []ssa.ValueID {
	if func.id in g.effective_params_map {
		return g.effective_params_map[func.id]
	}
	// Fallback for partially initialized generators.
	return g.compute_effective_params(func)
}

fn (g Gen) compute_effective_params(func ssa.Function) []ssa.ValueID {
	mut params := []ssa.ValueID{}
	mut seen := map[int]bool{}
	for pid in func.params {
		if pid <= 0 || pid >= g.mod.values.len {
			continue
		}
		if pid !in seen {
			seen[pid] = true
			params << pid
		}
	}
	for blk_id in func.blocks {
		blk := g.mod.blocks[blk_id]
		for instr_val_id in blk.instrs {
			if instr_val_id <= 0 || instr_val_id >= g.mod.values.len {
				continue
			}
			instr_val := g.mod.values[instr_val_id]
			if instr_val.kind != .instruction || instr_val.index < 0
				|| instr_val.index >= g.mod.instrs.len {
				continue
			}
			instr := g.mod.instrs[instr_val.index]
			for op_id in instr.operands {
				if op_id <= 0 || op_id >= g.mod.values.len {
					continue
				}
				op_val := g.mod.values[op_id]
				if op_val.kind == .argument && op_id !in seen {
					seen[op_id] = true
					params << op_id
				}
			}
		}
	}
	return params
}

fn (g Gen) signature_params(func ssa.Function) []ssa.ValueID {
	if func.id in g.signature_params_map {
		return g.signature_params_map[func.id]
	}
	return g.effective_params(func)
}

fn (mut g Gen) init_function_lookups() {
	g.fn_lookup.clear()
	g.fn_exact_lookup.clear()
	g.fn_suffix_lookup.clear()
	g.fn_mangled_names = []string{len: g.mod.funcs.len}
	g.signature_params_map.clear()
	g.effective_params_map.clear()
	for i, func in g.mod.funcs {
		mangled := g.mangle_fn_name(func.name)
		g.fn_mangled_names[i] = mangled
		if func.name !in g.fn_lookup {
			g.fn_lookup[func.name] = i
		}
		if func.name !in g.fn_exact_lookup {
			g.fn_exact_lookup[func.name] = []int{}
		}
		g.fn_exact_lookup[func.name] << i
		if mangled !in g.fn_lookup {
			g.fn_lookup[mangled] = i
		}
		if mangled !in g.fn_exact_lookup {
			g.fn_exact_lookup[mangled] = []int{}
		}
		g.fn_exact_lookup[mangled] << i
		suffix_name := if func.name.contains('__') {
			func.name.all_after_last('__')
		} else {
			func.name
		}
		if suffix_name !in g.fn_suffix_lookup {
			g.fn_suffix_lookup[suffix_name] = []int{}
		}
		g.fn_suffix_lookup[suffix_name] << i
		mut sig_params := []ssa.ValueID{}
		mut sig_seen := map[int]bool{}
		for pid in func.params {
			if pid <= 0 || pid >= g.mod.values.len {
				continue
			}
			if pid !in sig_seen {
				sig_seen[pid] = true
				sig_params << pid
			}
		}
		if sig_params.len == 0 {
			sig_params = g.compute_effective_params(func)
		}
		g.signature_params_map[func.id] = sig_params
		g.effective_params_map[func.id] = g.compute_effective_params(func)
	}
}

fn (g Gen) is_void_type(type_id int) bool {
	if type_id < 0 || type_id >= g.mod.type_store.types.len {
		return false
	}
	return g.mod.type_store.types[type_id].kind == .void_t
}

fn (g Gen) value_is_used(val_id int) bool {
	if val_id <= 0 || val_id >= g.mod.values.len {
		return false
	}
	return g.mod.values[val_id].uses.len > 0
}

fn (g Gen) should_skip_loop_header_zero_assign(block_id int, dest_val int, assigned_expr string, dest_typ_id int) bool {
	_ = block_id
	zero_expr := if dest_typ_id > 0 { g.zero_value_expr(dest_typ_id) } else { '0' }
	if assigned_expr != zero_expr {
		return false
	}
	return g.has_nonconstant_assign_to_dest(dest_val)
}

fn (mut g Gen) init_assign_lookups(func ssa.Function) {
	g.assign_dests.clear()
	g.nonconst_assign_dests.clear()
	g.block_assign_dests.clear()
	for blk_id in func.blocks {
		if blk_id < 0 || blk_id >= g.mod.blocks.len {
			continue
		}
		blk := g.mod.blocks[blk_id]
		mut blk_dests := []int{}
		for instr_val in blk.instrs {
			if instr_val <= 0 || instr_val >= g.mod.values.len {
				continue
			}
			val := g.mod.values[instr_val]
			if val.kind != .instruction || val.index < 0 || val.index >= g.mod.instrs.len {
				continue
			}
			instr := g.mod.instrs[val.index]
			if instr.op != .assign || instr.operands.len < 1 {
				continue
			}
			dest_val := instr.operands[0]
			g.assign_dests[dest_val] = true
			append_unique_int(mut blk_dests, dest_val)
			if instr.operands.len < 2 {
				continue
			}
			src_val := instr.operands[1]
			if src_val <= 0 || src_val >= g.mod.values.len {
				continue
			}
			if g.mod.values[src_val].kind != .constant {
				g.nonconst_assign_dests[dest_val] = true
			}
		}
		if blk_dests.len > 0 {
			g.block_assign_dests[blk_id] = blk_dests
		}
	}
}

fn (g Gen) has_nonconstant_assign_to_dest(dest_val int) bool {
	return dest_val in g.nonconst_assign_dests
}

fn (g Gen) has_assign_to_dest(dest_val int) bool {
	return dest_val in g.assign_dests
}

fn (g Gen) should_skip_loop_header_zero_def(block_id int, val_id int) bool {
	_ = block_id
	return g.has_assign_to_dest(val_id)
}

fn (g Gen) block_id_from_block_value(val_id int) int {
	if val_id <= 0 || val_id >= g.mod.values.len {
		return -1
	}
	return g.mod.values[val_id].index
}

fn edge_key(pred_blk_id int, dest_blk_id int) string {
	return '${pred_blk_id}->${dest_blk_id}'
}

fn (g Gen) edge_has_zero_inits(pred_blk_id int, dest_blk_id int) bool {
	if pred_blk_id < 0 || dest_blk_id < 0 {
		return false
	}
	key := edge_key(pred_blk_id, dest_blk_id)
	vals := g.edge_zero_inits[key] or { return false }
	return vals.len > 0
}

fn (mut g Gen) emit_edge_zero_inits(pred_blk_id int, dest_blk_id int) {
	if pred_blk_id < 0 || dest_blk_id < 0 {
		return
	}
	key := edge_key(pred_blk_id, dest_blk_id)
	vals := g.edge_zero_inits[key] or { return }
	for val_id in vals {
		if val_id <= 0 || val_id >= g.mod.values.len {
			continue
		}
		typ_id := g.mod.values[val_id].typ
		g.sb.writeln('\t\t_v${val_id} = ${g.zero_value_expr(typ_id)};')
	}
}

fn (g Gen) block_has_assign_to_dest(block_id int, dest_val int) bool {
	blk_dests := g.block_assign_dests[block_id] or { return false }
	for blk_dest in blk_dests {
		if blk_dest == dest_val {
			return true
		}
	}
	return false
}

fn append_unique_int(mut arr []int, v int) {
	for existing in arr {
		if existing == v {
			return
		}
	}
	arr << v
}

fn (mut g Gen) collect_edge_zero_inits(func ssa.Function) map[string][]int {
	mut out := map[string][]int{}
	for blk_id in func.blocks {
		if blk_id < 0 || blk_id >= g.mod.blocks.len {
			continue
		}
		blk := g.mod.blocks[blk_id]
		for instr_val in blk.instrs {
			if instr_val <= 0 || instr_val >= g.mod.values.len {
				continue
			}
			val := g.mod.values[instr_val]
			if val.kind != .instruction {
				continue
			}
			if val.index < 0 || val.index >= g.mod.instrs.len {
				continue
			}
			instr := g.mod.instrs[val.index]
			if instr.op !in [.bitcast, .trunc, .zext, .sext] || instr.operands.len != 0 {
				continue
			}
			if !g.should_skip_loop_header_zero_def(blk_id, val.id) {
				continue
			}
			for pred_blk_id in blk.preds {
				// Treat backward edges as loop-carried updates; they should keep
				// the current value unless explicitly assigned in the predecessor.
				if pred_blk_id >= blk_id {
					continue
				}
				if g.block_has_assign_to_dest(pred_blk_id, val.id) {
					continue
				}
				key := edge_key(pred_blk_id, blk_id)
				mut vals := out[key] or { []int{} }
				append_unique_int(mut vals, val.id)
				out[key] = vals
			}
		}
	}
	for blk_id in func.blocks {
		if blk_id < 0 || blk_id >= g.mod.blocks.len {
			continue
		}
		blk := g.mod.blocks[blk_id]
		for instr_val in blk.instrs {
			if instr_val <= 0 || instr_val >= g.mod.values.len {
				continue
			}
			val := g.mod.values[instr_val]
			if val.kind != .instruction {
				continue
			}
			if val.index < 0 || val.index >= g.mod.instrs.len {
				continue
			}
			instr := g.mod.instrs[val.index]
			if instr.op != .assign || instr.operands.len < 2 {
				continue
			}
			dest_val := instr.operands[0]
			src_val := instr.operands[1]
			dest_typ_id := g.value_type_id(dest_val)
			src_typ_id := g.value_type_id(src_val)
			if dest_typ_id <= 0 || dest_typ_id >= g.mod.type_store.types.len {
				continue
			}
			src_expr := g.val_str(src_val)
			coerced := g.coerce_expr_to_type(src_expr, src_typ_id, dest_typ_id)
			if !g.should_skip_loop_header_zero_assign(blk_id, dest_val, coerced, dest_typ_id) {
				continue
			}
			for pred_blk_id in blk.preds {
				// Treat backward edges as loop-carried updates; they should keep
				// the current value unless explicitly assigned in the predecessor.
				if pred_blk_id >= blk_id {
					continue
				}
				if g.block_has_assign_to_dest(pred_blk_id, dest_val) {
					continue
				}
				key := edge_key(pred_blk_id, blk_id)
				mut vals := out[key] or { []int{} }
				append_unique_int(mut vals, dest_val)
				out[key] = vals
			}
		}
	}
	return out
}

fn (g Gen) coerce_expr_to_type(expr string, actual_typ_id int, expected_typ_id int) string {
	if expected_typ_id <= 0 || expected_typ_id >= g.mod.type_store.types.len {
		return expr
	}
	if actual_typ_id <= 0 || actual_typ_id >= g.mod.type_store.types.len {
		expected := g.mod.type_store.types[expected_typ_id]
		if expected.kind == .struct_t {
			return g.zero_value_expr(expected_typ_id)
		}
		if expected.kind == .ptr_t || expected.kind == .array_t {
			return '(${g.type_name(expected_typ_id)})(uintptr_t)(${expr})'
		}
		return '(${g.type_name(expected_typ_id)})(${expr})'
	}
	actual := g.mod.type_store.types[actual_typ_id]
	expected := g.mod.type_store.types[expected_typ_id]
	if expected.kind == .struct_t {
		if actual.kind == .ptr_t && actual.elem_type == expected_typ_id {
			return '*${expr}'
		}
		if actual.kind == .struct_t {
			if actual_typ_id != expected_typ_id {
				expected_name := g.type_name(expected_typ_id)
				return '*(${expected_name}*)(&(${expr}))'
			}
			return expr
		}
		if actual.kind != .struct_t {
			return g.zero_value_expr(expected_typ_id)
		}
	}
	if actual.kind == .struct_t && expected.kind != .struct_t {
		if expected.kind == .ptr_t && expected.elem_type == actual_typ_id {
			return '&(${expr})'
		}
		if expected.kind == .ptr_t {
			return g.struct_to_ptr_expr(expr, actual_typ_id, expected_typ_id)
		}
		if expected.kind == .int_t {
			return g.struct_to_int_expr(expr, actual_typ_id, false)
		}
		return g.zero_value_expr(expected_typ_id)
	}
	if expected.kind == .ptr_t && actual.kind == .struct_t && expected.elem_type == actual_typ_id {
		return '&(${expr})'
	}
	if expected.kind == .ptr_t && g.is_string_type(expected.elem_type)
		&& g.is_string_type(actual_typ_id) {
		return '&(${expr})'
	}
	if expected.kind == .ptr_t && actual.kind != .ptr_t {
		return '(${g.type_name(expected_typ_id)})(uintptr_t)(${expr})'
	}
	if expected.kind != .ptr_t && actual.kind == .ptr_t {
		return '(${g.type_name(expected_typ_id)})(uintptr_t)(${expr})'
	}
	if expected_typ_id != actual_typ_id {
		return '(${g.type_name(expected_typ_id)})(${expr})'
	}
	return expr
}

fn (g Gen) coerce_call_arg(expr string, actual_typ_id int, expected_typ_id int) string {
	return g.coerce_expr_to_type(expr, actual_typ_id, expected_typ_id)
}

fn (g Gen) is_map_value_ptr_call(fn_name string, param_idx int) bool {
	return (fn_name.ends_with('map__set') && (param_idx == 1 || param_idx == 2))
		|| (fn_name.ends_with('map__get') && (param_idx == 1 || param_idx == 2))
		|| (fn_name.ends_with('map__get_check') && param_idx == 1)
		|| (fn_name.ends_with('map__exists') && param_idx == 1)
		|| (fn_name.ends_with('map__delete') && param_idx == 1)
		|| (fn_name.ends_with('map__get_and_set') && (param_idx == 1 || param_idx == 2))
}

fn (g Gen) should_pass_call_arg_by_ref(fn_name string, param_idx int, actual_typ_id int, expected_typ_id int) bool {
	if !g.is_map_value_ptr_call(fn_name, param_idx) {
		return false
	}
	if actual_typ_id <= 0 || actual_typ_id >= g.mod.type_store.types.len || expected_typ_id <= 0
		|| expected_typ_id >= g.mod.type_store.types.len {
		return false
	}
	expected := g.mod.type_store.types[expected_typ_id]
	if expected.kind != .ptr_t {
		return false
	}
	actual := g.mod.type_store.types[actual_typ_id]
	// map__get/set/delete-style APIs expect a pointer to key/value bytes.
	// Pass addresses for non-pointer values.
	// Pointer arguments are already addressable byte buffers in current SSA lowering.
	if actual.kind == .ptr_t {
		return false
	}
	return true
}

fn (g Gen) ref_call_arg_expr(expr string, actual_typ_id int) string {
	if actual_typ_id <= 0 || actual_typ_id >= g.mod.type_store.types.len {
		return '&(${expr})'
	}
	t := g.mod.type_store.types[actual_typ_id]
	if t.kind == .struct_t || t.kind == .array_t {
		return '&(${expr})'
	}
	elem_name := g.type_name(actual_typ_id)
	return '&((${elem_name}){${expr}})'
}

fn (g Gen) fallback_struct_return_expr() ?string {
	if g.current_fn_idx < 0 || g.current_fn_idx >= g.mod.funcs.len {
		return none
	}
	if g.current_fn_ret <= 0 || g.current_fn_ret >= g.mod.type_store.types.len {
		return none
	}
	ret_typ := g.mod.type_store.types[g.current_fn_ret]
	if ret_typ.kind != .struct_t {
		return none
	}
	func := g.mod.funcs[g.current_fn_idx]
	mut candidate := ''
	for blk_id in func.blocks {
		blk := g.mod.blocks[blk_id]
		for instr_val_id in blk.instrs {
			if instr_val_id <= 0 || instr_val_id >= g.mod.values.len {
				continue
			}
			ival := g.mod.values[instr_val_id]
			if ival.kind != .instruction || ival.index < 0 || ival.index >= g.mod.instrs.len {
				continue
			}
			if ival.typ <= 0 || ival.typ >= g.mod.type_store.types.len {
				continue
			}
			ival_typ := g.mod.type_store.types[ival.typ]
			if ival_typ.kind != .ptr_t || ival_typ.elem_type != g.current_fn_ret {
				continue
			}
			instr := g.mod.instrs[ival.index]
			if instr.op == .alloca {
				candidate = '*_v${ival.id}'
			}
		}
	}
	if candidate.len == 0 {
		return none
	}
	return candidate
}

fn (g Gen) arg_name(val ssa.Value) string {
	safe := sanitize_c_ident(val.name, 'arg')
	return 'arg_${val.id}_${safe}'
}

fn (g Gen) struct_field_name(t ssa.Type, idx int) string {
	mut field_idx := idx
	if t.field_names.len > 0 {
		if field_idx < 0 {
			field_idx = 0
		} else if field_idx >= t.field_names.len {
			field_idx = t.field_names.len - 1
		}
	}
	raw := if field_idx >= 0 && field_idx < t.field_names.len {
		t.field_names[field_idx]
	} else {
		'field_${idx}'
	}
	if t.kind == .struct_t && t.field_names.len == 3 && t.field_names[0] == 'str'
		&& t.field_names[1] == 'len' && t.field_names[2] == 'is_lit' {
		return sanitize_c_ident(raw, 'field')
	}
	safe := sanitize_c_ident(raw, 'field')
	return 'f_${field_idx}_${safe}'
}

fn (g Gen) extract_index(val_id int) int {
	if val_id < 0 || val_id >= g.mod.values.len {
		return 0
	}
	return g.mod.values[val_id].name.int()
}

fn (g Gen) struct_field_index(t ssa.Type, name string) int {
	for i, field_name in t.field_names {
		if field_name == name {
			return i
		}
	}
	return -1
}

fn (g Gen) struct_to_int_expr(expr string, struct_typ_id int, for_cond bool) string {
	if struct_typ_id <= 0 || struct_typ_id >= g.mod.type_store.types.len {
		return if for_cond { '0' } else { '0' }
	}
	t := g.mod.type_store.types[struct_typ_id]
	if t.kind != .struct_t {
		return if for_cond { '0' } else { '0' }
	}
	state_idx := g.struct_field_index(t, 'state')
	mut data_idx := g.struct_field_index(t, 'data')
	if state_idx >= 0 && data_idx >= 0 {
		if for_cond {
			state_field := g.struct_field_name(t, state_idx)
			return '((${expr}.${state_field}) == 0)'
		}
		data_field := g.struct_field_name(t, data_idx)
		data_expr := '${expr}.${data_field}'
		data_typ_id := if data_idx >= 0 && data_idx < t.fields.len { t.fields[data_idx] } else { 0 }
		return g.value_to_int_expr(data_expr, data_typ_id, false)
	}
	tag_idx := g.struct_field_index(t, '_tag')
	if tag_idx >= 0 {
		tag_field := g.struct_field_name(t, tag_idx)
		if for_cond {
			return '((${expr}.${tag_field}) != 0)'
		}
		return '(int64_t)(${expr}.${tag_field})'
	}
	if t.fields.len > 0 {
		field0 := g.struct_field_name(t, 0)
		field0_expr := '${expr}.${field0}'
		field0_typ_id := t.fields[0]
		return g.value_to_int_expr(field0_expr, field0_typ_id, for_cond)
	}
	return if for_cond { '0' } else { '0' }
}

fn (g Gen) struct_to_ptr_expr(expr string, struct_typ_id int, dst_ptr_typ_id int) string {
	dst_name := g.type_name(dst_ptr_typ_id)
	if struct_typ_id <= 0 || struct_typ_id >= g.mod.type_store.types.len {
		return '(${dst_name})(uintptr_t)(${expr})'
	}
	t := g.mod.type_store.types[struct_typ_id]
	if t.kind != .struct_t {
		return '(${dst_name})(uintptr_t)(${expr})'
	}
	mut data_idx := g.struct_field_index(t, 'data')
	if data_idx < 0 {
		data_idx = g.struct_field_index(t, '_data')
	}
	if data_idx >= 0 {
		data_field := g.struct_field_name(t, data_idx)
		data_expr := '${expr}.${data_field}'
		data_typ_id := if data_idx >= 0 && data_idx < t.fields.len { t.fields[data_idx] } else { 0 }
		return g.value_to_ptr_expr(data_expr, data_typ_id, dst_ptr_typ_id)
	}
	if t.fields.len > 0 && t.fields[0] > 0 && t.fields[0] < g.mod.type_store.types.len {
		first_field_type := g.mod.type_store.types[t.fields[0]]
		if first_field_type.kind == .ptr_t {
			field0 := g.struct_field_name(t, 0)
			return '(${dst_name})(uintptr_t)(${expr}.${field0})'
		}
	}
	return '(${dst_name})(uintptr_t)(&(${expr}))'
}

fn (g Gen) value_to_int_expr(expr string, typ_id int, for_cond bool) string {
	if typ_id <= 0 || typ_id >= g.mod.type_store.types.len {
		return if for_cond { '((${expr}) != 0)' } else { '(int64_t)(uintptr_t)(${expr})' }
	}
	t := g.mod.type_store.types[typ_id]
	return match t.kind {
		.int_t {
			if for_cond {
				'((${expr}) != 0)'
			} else {
				'(int64_t)(${expr})'
			}
		}
		.ptr_t {
			if for_cond {
				'((${expr}) != 0)'
			} else {
				'(int64_t)(uintptr_t)(${expr})'
			}
		}
		.struct_t {
			if g.is_string_type(typ_id) {
				if for_cond {
					'((${expr}.str) != 0)'
				} else {
					'(int64_t)(uintptr_t)(${expr}.str)'
				}
			} else {
				g.struct_to_int_expr(expr, typ_id, for_cond)
			}
		}
		else {
			if for_cond {
				'((${expr}) != 0)'
			} else {
				'(int64_t)(uintptr_t)(${expr})'
			}
		}
	}
}

fn (g Gen) value_to_ptr_expr(expr string, typ_id int, dst_ptr_typ_id int) string {
	dst_name := g.type_name(dst_ptr_typ_id)
	if typ_id <= 0 || typ_id >= g.mod.type_store.types.len {
		return '(${dst_name})(uintptr_t)(${expr})'
	}
	t := g.mod.type_store.types[typ_id]
	return match t.kind {
		.ptr_t, .int_t {
			'(${dst_name})(uintptr_t)(${expr})'
		}
		.struct_t {
			if g.is_string_type(typ_id) {
				'(${dst_name})(uintptr_t)(${expr}.str)'
			} else {
				mut data_idx := g.struct_field_index(t, 'data')
				if data_idx < 0 {
					data_idx = g.struct_field_index(t, '_data')
				}
				if data_idx >= 0 && data_idx < t.fields.len {
					data_field := g.struct_field_name(t, data_idx)
					'(${dst_name})(uintptr_t)(${expr}.${data_field})'
				} else {
					'(${dst_name})(uintptr_t)(&(${expr}))'
				}
			}
		}
		else {
			'(${dst_name})(uintptr_t)(${expr})'
		}
	}
}

fn (g Gen) bitcast_expr(src string, src_typ_id int, dst_typ_id int) string {
	src_typ := g.mod.type_store.types[src_typ_id]
	dst_typ := g.mod.type_store.types[dst_typ_id]
	dst_name := g.type_name(dst_typ_id)
	if dst_typ.kind == .struct_t && src_typ.kind == .ptr_t {
		return '*(${dst_name}*)(${src})'
	}
	if src_typ.kind == .struct_t && dst_typ.kind == .int_t {
		return g.struct_to_int_expr(src, src_typ_id, false)
	}
	if src_typ.kind == .struct_t && dst_typ.kind == .ptr_t {
		return g.struct_to_ptr_expr(src, src_typ_id, dst_typ_id)
	}
	if dst_typ.kind == .ptr_t && src_typ.kind != .ptr_t {
		return '(${dst_name})(uintptr_t)(${src})'
	}
	if dst_typ.kind != .ptr_t && src_typ.kind == .ptr_t {
		return '(${dst_name})(uintptr_t)(${src})'
	}
	return '(${dst_name})(${src})'
}

fn (g Gen) zero_value_expr(type_id int) string {
	if type_id < 0 || type_id >= g.mod.type_store.types.len {
		return '0'
	}
	t := g.mod.type_store.types[type_id]
	match t.kind {
		.void_t {
			return '0'
		}
		.ptr_t, .array_t {
			return 'NULL'
		}
		.struct_t {
			return '(${g.type_name(type_id)}){0}'
		}
		else {
			return '0'
		}
	}
}

fn sanitize_c_ident(name string, fallback string) string {
	mut out := strings.new_builder(name.len + 8)
	for i, ch in name.bytes() {
		is_alpha := (ch >= `a` && ch <= `z`) || (ch >= `A` && ch <= `Z`)
		is_digit := ch >= `0` && ch <= `9`
		if is_alpha || ch == `_` || (i > 0 && is_digit) {
			out.write_u8(ch)
		} else if i == 0 && is_digit {
			out.write_u8(`_`)
			out.write_u8(ch)
		} else {
			out.write_u8(`_`)
		}
	}
	mut ident := out.str()
	if ident.len == 0 {
		ident = fallback
	}
	c_keywords := ['auto', 'break', 'case', 'char', 'const', 'continue', 'default', 'do', 'double',
		'else', 'enum', 'extern', 'float', 'for', 'goto', 'if', 'inline', 'int', 'long', 'register',
		'restrict', 'return', 'short', 'signed', 'sizeof', 'static', 'struct', 'switch', 'typedef',
		'union', 'unsigned', 'void', 'volatile', 'while', '_Alignas', '_Alignof', '_Atomic', '_Bool',
		'_Complex', '_Generic', '_Imaginary', '_Noreturn', '_Static_assert', '_Thread_local']
	if ident in c_keywords {
		ident = 'v_${ident}'
	}
	return ident
}

fn escape_c_string_literal(value string) string {
	mut out := strings.new_builder(value.len + 8)
	for ch in value.bytes() {
		match ch {
			`\\` { out.write_string('\\\\') }
			`"` { out.write_string('\\"') }
			`\n` { out.write_string('\\n') }
			`\r` { out.write_string('\\r') }
			`\t` { out.write_string('\\t') }
			`\0` { out.write_string('\\0') }
			else { out.write_u8(ch) }
		}
	}
	return out.str()
}
