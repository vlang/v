// Copyright (c) 2026 Alexander Medvednikov. All rights reserved.
// Use of this source code is governed by an MIT license
// that can be found in the LICENSE file.

module cleanc

import v2.ast

const preamble_includes_minimal = r'// Generated by V Clean C Backend
#include <stdio.h>
#include <stdlib.h>
#include <stdbool.h>
#include <stdint.h>
#include <stddef.h>
#include <string.h>
#include <dirent.h>
#ifdef __APPLE__
#include <mach/mach_time.h>
#endif
#include <pthread.h>
'

const preamble_includes_full = r'// Generated by V Clean C Backend
#include <stdio.h>
#include <stdlib.h>
#include <stdbool.h>
#include <stdint.h>
#include <stddef.h>
#include <string.h>
#include <float.h>
#include <unistd.h>
#include <fcntl.h>
#include <sys/stat.h>
#include <errno.h>
#include <signal.h>
#include <dirent.h>
#include <sys/types.h>
#include <sys/select.h>
#include <sys/wait.h>
#ifdef __APPLE__
#include <sys/syslimits.h>
#include <mach/mach_time.h>
#include <execinfo.h>
#endif
#include <termios.h>
#include <sys/ioctl.h>
#include <pthread.h>
#include <time.h>
#include <sys/time.h>
#include <sys/statvfs.h>
#include <utime.h>
#include <sys/utsname.h>
#ifdef __APPLE__
#include <sys/ptrace.h>
#include <libproc.h>
#endif
extern char** environ;
#define signal(v_sig, v_handler) signal((v_sig), ((void (*)(int))(v_handler)))
'

fn (mut g Gen) write_preamble() {
	minimal_preamble := g.use_minimal_preamble()
	g.sb.write_string(if minimal_preamble {
		preamble_includes_minimal
	} else {
		preamble_includes_full
	})
	g.sb.writeln('')

	// V primitive type aliases
	g.sb.writeln('// V primitive types')
	g.sb.writeln('typedef int8_t i8;')
	g.sb.writeln('typedef int16_t i16;')
	g.sb.writeln('typedef int32_t i32;')
	g.sb.writeln('typedef int64_t i64;')
	g.sb.writeln('typedef uint8_t u8;')
	g.sb.writeln('typedef uint16_t u16;')
	g.sb.writeln('typedef uint32_t u32;')
	g.sb.writeln('typedef uint64_t u64;')
	g.sb.writeln('typedef float f32;')
	g.sb.writeln('typedef double f64;')
	g.sb.writeln('typedef u8 byte;')
	g.sb.writeln('typedef size_t usize;')
	g.sb.writeln('typedef ptrdiff_t isize;')
	g.sb.writeln('typedef u32 rune;')
	g.sb.writeln('typedef char* byteptr;')
	g.sb.writeln('typedef char* charptr;')
	g.sb.writeln('typedef void* voidptr;')
	g.sb.writeln('typedef void* chan;')
	g.sb.writeln('typedef double float_literal;')
	g.sb.writeln('typedef int64_t int_literal;')
	g.sb.writeln('extern int g_main_argc;')
	g.sb.writeln('extern void* g_main_argv;')
	if minimal_preamble {
		g.sb.writeln('typedef struct sync__RwMutex { pthread_rwlock_t mutex; } sync__RwMutex;')
		g.sb.writeln('static inline void sync__RwMutex_rlock(sync__RwMutex* m) { pthread_rwlock_rdlock(&m->mutex); }')
		g.sb.writeln('static inline void sync__RwMutex_runlock(sync__RwMutex* m) { pthread_rwlock_unlock(&m->mutex); }')
		g.sb.writeln('static inline void sync__RwMutex_lock(sync__RwMutex* m) { pthread_rwlock_wrlock(&m->mutex); }')
		g.sb.writeln('static inline void sync__RwMutex_unlock(sync__RwMutex* m) { pthread_rwlock_unlock(&m->mutex); }')
		g.sb.writeln('')
		return
	}
	// wyhash implementation used by builtin/map and hash modules.
	g.sb.writeln('#ifndef wyhash_final_version_4_2')
	g.sb.writeln('#define wyhash_final_version_4_2')
	g.sb.writeln('#define WYHASH_CONDOM 1')
	g.sb.writeln('#define WYHASH_32BIT_MUM 0')
	g.sb.writeln('#if defined(__GNUC__) || defined(__INTEL_COMPILER) || defined(__clang__)')
	g.sb.writeln('  #define _likely_(x) __builtin_expect(x,1)')
	g.sb.writeln('  #define _unlikely_(x) __builtin_expect(x,0)')
	g.sb.writeln('#else')
	g.sb.writeln('  #define _likely_(x) (x)')
	g.sb.writeln('  #define _unlikely_(x) (x)')
	g.sb.writeln('#endif')
	g.sb.writeln('static inline uint64_t _wyrot(uint64_t x) { return (x>>32)|(x<<32); }')
	g.sb.writeln('static inline void _wymum(uint64_t *A, uint64_t *B){')
	g.sb.writeln('#if defined(__SIZEOF_INT128__)')
	g.sb.writeln('  __uint128_t r=*A; r*=*B; *A=(uint64_t)r; *B=(uint64_t)(r>>64);')
	g.sb.writeln('#elif defined(_MSC_VER) && defined(_M_X64)')
	g.sb.writeln('  *A=_umul128(*A,*B,B);')
	g.sb.writeln('#else')
	g.sb.writeln('  uint64_t ha=*A>>32, hb=*B>>32, la=(uint32_t)*A, lb=(uint32_t)*B, hi, lo;')
	g.sb.writeln('  uint64_t rh=ha*hb, rm0=ha*lb, rm1=hb*la, rl=la*lb, t=rl+(rm0<<32), c=t<rl;')
	g.sb.writeln('  lo=t+(rm1<<32); c+=lo<t; hi=rh+(rm0>>32)+(rm1>>32)+c;')
	g.sb.writeln('  *A=lo; *B=hi;')
	g.sb.writeln('#endif')
	g.sb.writeln('}')
	g.sb.writeln('static inline uint64_t _wymix(uint64_t A, uint64_t B){ _wymum(&A,&B); return A^B; }')
	g.sb.writeln('#ifndef WYHASH_LITTLE_ENDIAN')
	g.sb.writeln('  #ifdef TARGET_ORDER_IS_LITTLE')
	g.sb.writeln('    #define WYHASH_LITTLE_ENDIAN 1')
	g.sb.writeln('  #else')
	g.sb.writeln('    #define WYHASH_LITTLE_ENDIAN 0')
	g.sb.writeln('  #endif')
	g.sb.writeln('#endif')
	g.sb.writeln('#if (WYHASH_LITTLE_ENDIAN)')
	g.sb.writeln('  static inline uint64_t _wyr8(const uint8_t *p) { uint64_t v; memcpy(&v, p, 8); return v;}')
	g.sb.writeln('  static inline uint64_t _wyr4(const uint8_t *p) { uint32_t v; memcpy(&v, p, 4); return v;}')
	g.sb.writeln('#elif defined(__GNUC__) || defined(__INTEL_COMPILER) || defined(__clang__)')
	g.sb.writeln('  static inline uint64_t _wyr8(const uint8_t *p) { uint64_t v; memcpy(&v, p, 8); return __builtin_bswap64(v);}')
	g.sb.writeln('  static inline uint64_t _wyr4(const uint8_t *p) { uint32_t v; memcpy(&v, p, 4); return __builtin_bswap32(v);}')
	g.sb.writeln('#else')
	g.sb.writeln('  static inline uint64_t _wyr8(const uint8_t *p) {')
	g.sb.writeln('    uint64_t v; memcpy(&v, p, 8);')
	g.sb.writeln('    return (((v >> 56) & 0xff)| ((v >> 40) & 0xff00)| ((v >> 24) & 0xff0000)| ((v >>  8) & 0xff000000)| ((v <<  8) & 0xff00000000)| ((v << 24) & 0xff0000000000)| ((v << 40) & 0xff000000000000)| ((v << 56) & 0xff00000000000000));')
	g.sb.writeln('  }')
	g.sb.writeln('  static inline uint64_t _wyr4(const uint8_t *p) {')
	g.sb.writeln('    uint32_t v; memcpy(&v, p, 4);')
	g.sb.writeln('    return (((v >> 24) & 0xff)| ((v >>  8) & 0xff00)| ((v <<  8) & 0xff0000)| ((v << 24) & 0xff000000));')
	g.sb.writeln('  }')
	g.sb.writeln('#endif')
	g.sb.writeln('static inline uint64_t _wyr3(const uint8_t *p, size_t k) { return (((uint64_t)p[0])<<16)|(((uint64_t)p[k>>1])<<8)|p[k-1];}')
	g.sb.writeln('static inline uint64_t wyhash(const void *key, size_t len, uint64_t seed, const uint64_t *secret){')
	g.sb.writeln('  const uint8_t *p=(const uint8_t *)key; seed^=_wymix(seed^secret[0],secret[1]); uint64_t a, b;')
	g.sb.writeln('  if(_likely_(len<=16)){')
	g.sb.writeln('    if(_likely_(len>=4)){ a=(_wyr4(p)<<32)|_wyr4(p+((len>>3)<<2)); b=(_wyr4(p+len-4)<<32)|_wyr4(p+len-4-((len>>3)<<2)); }')
	g.sb.writeln('    else if(_likely_(len>0)){ a=_wyr3(p,len); b=0; }')
	g.sb.writeln('    else a=b=0;')
	g.sb.writeln('  } else {')
	g.sb.writeln('    size_t i=len;')
	g.sb.writeln('    if(_unlikely_(i>=48)){')
	g.sb.writeln('      uint64_t see1=seed, see2=seed;')
	g.sb.writeln('      do{')
	g.sb.writeln('        seed=_wymix(_wyr8(p)^secret[1],_wyr8(p+8)^seed);')
	g.sb.writeln('        see1=_wymix(_wyr8(p+16)^secret[2],_wyr8(p+24)^see1);')
	g.sb.writeln('        see2=_wymix(_wyr8(p+32)^secret[3],_wyr8(p+40)^see2);')
	g.sb.writeln('        p+=48; i-=48;')
	g.sb.writeln('      }while(_likely_(i>=48));')
	g.sb.writeln('      seed^=see1^see2;')
	g.sb.writeln('    }')
	g.sb.writeln('    while(_unlikely_(i>16)){ seed=_wymix(_wyr8(p)^secret[1],_wyr8(p+8)^seed); i-=16; p+=16; }')
	g.sb.writeln('    a=_wyr8(p+i-16); b=_wyr8(p+i-8);')
	g.sb.writeln('  }')
	g.sb.writeln('  a^=secret[1]; b^=seed; _wymum(&a,&b);')
	g.sb.writeln('  return _wymix(a^secret[0]^len,b^secret[1]);')
	g.sb.writeln('}')
	g.sb.writeln('static const uint64_t _wyp[4] = {0x2d358dccaa6c78a5ull, 0x8bb84b93962eacc9ull, 0x4b33a62ed433d4a3ull, 0x4d5a2da51de1aa47ull};')
	g.sb.writeln('static inline uint64_t wyhash64(uint64_t A, uint64_t B){ A^=0x2d358dccaa6c78a5ull; B^=0x8bb84b93962eacc9ull; _wymum(&A,&B); return _wymix(A^0x2d358dccaa6c78a5ull,B^0x8bb84b93962eacc9ull);}')
	g.sb.writeln('#endif')
	g.sb.writeln('#define _MOV')
	g.sb.writeln('typedef u8 termios__Cc;')
	// sync__RwMutex for shared variables
	g.sb.writeln('typedef struct sync__RwMutex { pthread_rwlock_t mutex; } sync__RwMutex;')
	g.sb.writeln('static inline void sync__RwMutex_rlock(sync__RwMutex* m) { pthread_rwlock_rdlock(&m->mutex); }')
	g.sb.writeln('static inline void sync__RwMutex_runlock(sync__RwMutex* m) { pthread_rwlock_unlock(&m->mutex); }')
	g.sb.writeln('static inline void sync__RwMutex_lock(sync__RwMutex* m) { pthread_rwlock_wrlock(&m->mutex); }')
	g.sb.writeln('static inline void sync__RwMutex_unlock(sync__RwMutex* m) { pthread_rwlock_unlock(&m->mutex); }')
	g.sb.writeln('')
	g.sb.writeln('')
}

fn (g &Gen) use_minimal_preamble() bool {
	return g.emit_modules.len == 1 && 'main' in g.emit_modules
}

fn (mut g Gen) emit_runtime_aliases() {
	mut array_names := g.array_aliases.keys()
	array_names.sort()
	// Emit dynamic array aliases (skip fixed arrays)
	for name in array_names {
		if name.starts_with('Array_fixed_') {
			continue
		}
		g.sb.writeln('typedef array ${name};')
	}
	// Emit pointer element typedefs needed by array helper functions.
	// e.g. Array_Coordptr needs 'typedef Coord* Coordptr;'
	// Must come after array aliases so Array_int etc. are defined first.
	for name in array_names {
		if name.starts_with('Array_fixed_') {
			continue
		}
		elem := name['Array_'.len..]
		if elem.len > 3 && elem.ends_with('ptr') {
			base := elem[..elem.len - 3]
			if base !in ['void', 'char', 'byte'] && !elem.starts_with('Array_')
				&& !elem.starts_with('Map_') {
				g.sb.writeln('typedef ${base}* ${elem};')
			}
		}
	}
	// Emit primitive fixed array typedefs (non-primitive ones deferred until after struct defs)
	for name in array_names {
		if !name.starts_with('Array_fixed_') {
			continue
		}
		if info := g.collected_fixed_array_types[name] {
			if info.elem_type in primitive_types
				|| info.elem_type in ['char', 'voidptr', 'charptr', 'byteptr', 'void*', 'char*'] {
				g.sb.writeln('typedef ${info.elem_type} ${name} [${info.size}];')
				alias_key := 'alias_${name}'
				body_key := 'body_${name}'
				g.emitted_types[alias_key] = true
				g.emitted_types[body_key] = true
				// Emit fallback str macros for fixed array types
				g.sb.writeln('#define ${name}_str(a) ((string){.str = "${name}", .len = ${name.len}, .is_lit = 1})')
				g.sb.writeln('#define ${name}__str(a) ${name}_str(a)')
			}
		}
	}
	g.sb.writeln('typedef array VArg_string;')
	mut map_names := g.map_aliases.keys()
	map_names.sort()
	for name in map_names {
		g.sb.writeln('typedef map ${name};')
		// Emit fallback str macro for map types without explicit str() functions
		map_str_fn := '${name}_str'
		if map_str_fn !in g.fn_return_types {
			g.sb.writeln('#define ${name}_str(v) ((string){.str = "${name}", .len = ${name.len}, .is_lit = 1})')
		}
	}
	// Option/Result forward declarations (struct definitions emitted later
	// after IError is defined, via emit_option_result_structs)
	mut option_names := g.option_aliases.keys()
	option_names.sort()
	for name in option_names {
		val_type := option_value_type(name)
		if g.option_result_payload_invalid(val_type) {
			continue
		}
		if val_type != '' && val_type != 'void' {
			g.sb.writeln('typedef struct ${name} ${name};')
		} else {
			g.sb.writeln('typedef _option ${name};')
		}
	}
	mut result_names := g.result_aliases.keys()
	result_names.sort()
	for name in result_names {
		val_type := g.result_value_type(name)
		if g.option_result_payload_invalid(val_type) {
			continue
		}
		if val_type != '' && val_type != 'void' {
			g.sb.writeln('typedef struct ${name} ${name};')
		} else {
			g.sb.writeln('typedef _result ${name};')
		}
	}
}

fn (mut g Gen) get_enum_name(node ast.EnumDecl) string {
	if g.cur_module != '' && g.cur_module != 'main' && g.cur_module != 'builtin' {
		return '${g.cur_module}__${node.name}'
	}
	return node.name
}

fn (mut g Gen) gen_enum_decl(node ast.EnumDecl) {
	name := g.get_enum_name(node)
	enum_key := 'enum_${name}'
	if enum_key in g.emitted_types {
		return
	}
	g.emitted_types[enum_key] = true
	mut is_flag := false
	for attribute in node.attributes {
		if attribute.name == 'flag' {
			is_flag = true
			break
		}
		if attribute.name == '' && attribute.value is ast.Ident && attribute.value.name == 'flag' {
			is_flag = true
			break
		}
	}

	g.sb.writeln('typedef enum {')
	for i, field in node.fields {
		g.sb.write_string('\t${name}__${field.name}')
		if field.value !is ast.EmptyExpr {
			g.sb.write_string(' = ')
			g.expr(field.value)
		} else if is_flag {
			g.sb.write_string(' = ${u64(1) << i}U')
		}
		if i < node.fields.len - 1 {
			g.sb.writeln(',')
		} else {
			g.sb.writeln('')
		}
	}
	g.sb.writeln('} ${name};')
	g.sb.writeln('')
	enum_str_fn := '${name}__str'
	if enum_str_fn !in g.fn_return_types {
		g.sb.writeln('#define ${name}__str(v) int__str((int)(v))')
	}
	enum_short_str_fn := '${name}_str'
	if enum_short_str_fn !in g.fn_return_types {
		g.sb.writeln('#define ${name}_str(v) ${name}__str(v)')
	}
	g.sb.writeln('')
}
