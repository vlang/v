import math { max, min }
import cli { Command }
import math.complex { Complex, complex }
import os {
	file_ext,
	user_os,
}
import mod {
	AliasTarget,
	Enum,
	FnAliasParam,
	FnAliasRet,
	FnArg,
	FnArgGeneric,
	FnArgTypeParam1,
	FnArgTypeParam2,
	FnArgVariadic,
	FnRet,
	FnRetGeneric,
	FnRetTypeParam1,
	FnRetTypeParam2,
	InterfaceField,
	InterfaceMethodArg,
	InterfaceMethodRet,
	RightOfAs,
	RightOfIs,
	StructArrayFieldElem,
	StructEmbed,
	StructField,
	StructFixedArrayFieldElem,
	StructMapFieldKey,
	StructMapFieldValue,
	StructMethodArg,
	StructMethodArgGeneric,
	StructMethodRet,
	StructMethodRetGeneric,
	StructRefField,
	SumVariant1,
	SumVariant2,
}

type Alias = AliasTarget
type SumType = SumVariant1 | SumVariant2
type Fn = fn (FnAliasParam) FnAliasRet

struct Struct {
	StructEmbed
	v         StructField
	ref       &StructRefField
	map       map[StructMapFieldKey]StructMapFieldValue
	arr       []StructArrayFieldElem
	arr_fixed [2]StructFixedArrayFieldElem
}

fn (s Struct) method(v StructMethodArg) StructMethodRet {
	return StructMethodRet{}
}

fn (s Struct) method_generic[T](v StructMethodArgGeneric[T]) StructMethodRetGeneric[T] {
	return StructMethodRet[T]{}
}

interface Interface {
	v InterfaceField
	f(InterfaceMethodArg) InterfaceMethodRet
}

fn f(v FnArg, vv ...FnArgVariadic) FnRet {
	if v is RightOfIs {
	}
	_ = v as RightOfAs

	println(Enum.val)

	return FnRet{}
}

fn f2(v Generic[FnArgTypeParam1, FnArgTypeParam2]) Generic[FnRetTypeParam1, FnRetTypeParam2] {}

fn f_generic[T](v FnArgGeneric[T]) FnRetGeneric[T] {
	return FnRetGeneric[T]{}
}

struct App {
	command &Command
}

struct MyCommand {
	Command
}

fn imaginary(im f64) Complex {
	return complex(0, im)
}

fn main() {
	println(max(0.1, 0.2))
	println(min(0.1, 0.2))
	println(user_os())
	println(file_ext('main.v'))
	println(imaginary(1))
}
