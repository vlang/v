//import moda
//import modb as mb

import localmod

const (
	pi = 3
	pi2 = pi
	//s = 'hi'

)

struct User {
	age int
}

enum Color {
	red green blue
}

/*
struct One {
	two Two
}

struct Two {

}
*/


fn main() {
	a := 10
	//bb := 2 + 'hi'
	a++
	negative := -a
	2 < 3
	a == 1
	a++
	foo(3)
	ak := 10
	mypi := pi
	color := Color.red
	localmod.pub_foo()
	ten := localmod.get_int_10()
	println(localmod.pub_int_const)
	g := int(3.0)
}
	/*
	user := User{}
	user.age = 10
	mut x := if user.age == 10 { 20 } else { user.age * 2 }
	for x > 3 {

	}
	*/

fn foo(a int) {
	for true {

	}
	for i := 0; i < 10; i++ {

	}
	nums := [1,2,3]
	nums2 := nums[..2]
	number := nums[0]
	bools := [true, false]
	users := [User{}]
	//ptr := &User{}
	b := bools[0]
	mystrings := ['a', 'b']
	s := mystrings[0]
	//////////
	mut x := 0
	x=get_int2()
	n := get_int2()
	q := true || false
	b2 := bools[0] || true
	b3 := get_bool() || true
	f := nums.first()
	//cloned = nums.clone()
	//cloned1 := cloned[0]
	//println(cloned1 == 1)
	/*
	mut strings := ['hi', 'hello']
	strings << 'a' + b
	*/

}

fn (u mut User) inc_age(n int) {
	u.age += n
}

fn get_int(a string) int {
	return 10
}

fn get_bool() bool {
	return true
}

fn get_int2() int {
	a := 'hello'
	//return get_int('sdf')
	return get_int(a)
}

fn myuser() {
	x := 1
	q := x | 0x1004
	user := User{age:30}
	age := user.age + 1 // crash here
	boo := 2
	boo2 := boo+1
	b := age > 0
	b2 := user.age > 0
	mut user2 := User{age:20}
	user2.age = 20 + boo
}

fn multi_return() (int,string) {
	return 4, 'four'
}

fn variadic(a ...int) {
	x := path_sep
	y := if true { 1 } else { 0 } // TODO cgen
}

fn ensure_cap(required int, cap int) {
	if required < cap {
		return
	}
}

fn println(s string){}

fn matches() {
	a := 100
	match a {
		10 {
			println('10')
		}
		20 {
			k := a + 1
		}
	}
	/*
	n := match a {
		1 { 10 }
		2 { 20 }
		else { 30 }
	}
	*/
}

const (
	path_sep = 10
)

fn end() {
	i := 2
	key := 10
	x := i != -1 && key == 10 // key == keys[i]
	e := 2 + 3 * 4
	//mut a := [1,2,3]
	//(a << 4) + 2

}


