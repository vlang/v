fn multret1(i int, j int) (int, int) {
	return if i > j { i, 10 } else { 10, j }
}

fn multret2(i int, j int) (int, int) {
	return match i > j {
		true { i, 10 }
		false { 10, j }
	}
}

fn multret3(i int, j int) (int, int) {
	if i > j {
		return i, 10
	} else {
		return 10, j
	}
}

fn multret4(i int, j int) (int, int) {
	match i > j {
		true { return i, 10 }
		false { return 10, j }
	}
}

fn fn_multi_return_test() { // from fn_multi_return_test.v
	mut a, mut b := 0, 0

	a, b = multret1(3, 14)
	assert a == 10
	assert b == 14

	a, b = multret2(3, 14)
	assert a == 10
	assert b == 14

	a, b = multret3(3, 14)
	assert a == 10
	assert b == 14

	a, b = multret4(3, 14)
	assert a == 10
	assert b == 14
}

struct Zoo {
mut:
	a int
	b int
}

fn cross_assign_of_struct_test() { // from cross_assign_test.v
	mut x := Zoo{
		a: 1
		b: 2
	}
	x.a, x.b = x.b, x.a
	// println(x)
	assert x.a == 2
	assert x.b == 1
}

struct MyStruct {
        a int
        b u64
        c u16
        d u8
}

struct MyStruct2 {
        a u8
        b u8
        c u8
}

fn struct_multi_return() (int, MyStruct) {
        return 3, MyStruct{4, 5, 6, 7}
}

fn struct_multi_return2() (int, MyStruct2) {
        return 3, MyStruct2{4, 5, 6}
}

fn struct_multi_return_test() {
        a, b := struct_multi_return()
        assert a == 3
        assert b.a == 4
        assert b.b == 5
        assert b.c == 6
        assert b.d == 7

        c, d := struct_multi_return2()
        assert c == 3
        assert d.a == 4
        assert d.b == 5
        assert d.c == 6
}

fn main() {
	fn_multi_return_test()
	cross_assign_of_struct_test()
	struct_multi_return_test()
}
