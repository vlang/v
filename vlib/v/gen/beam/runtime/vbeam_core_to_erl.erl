%% vbeam_core_to_erl - Core Erlang to Erlang source transpiler
%%
%% Parses Core Erlang source text and emits equivalent Erlang source code.
%% This enables an optional Erlang source output mode for better cold-start
%% performance: V -> .core -> .erl -> erlc -> .beam
%%
%% Uses the cerl module to walk the parsed Core Erlang AST, transforms
%% nodes to erl_syntax trees, and emits via erl_prettypr.
%%
%% Exports:
%%   transpile/1       - Core Erlang source string -> Erlang source string
%%   transpile_file/2  - Read .core file, write .erl file
-module(vbeam_core_to_erl).
-export([transpile/1, transpile_file/2]).

%% @doc Transpile Core Erlang source text to Erlang source text.
-spec transpile(string()) -> string().
transpile(CoreText) when is_list(CoreText) ->
    true = CoreText =/= [],
    {ok, Tokens, _} = core_scan:string(CoreText),
    {ok, CoreMod} = core_parse:parse(Tokens),
    ErlForms = transform_module(CoreMod),
    lists:flatten([erl_prettypr:format(F) ++ "\n" || F <- ErlForms]).

%% @doc Read a .core file, transpile to Erlang, write a .erl file.
-spec transpile_file(string(), string()) -> ok | {error, term()}.
transpile_file(CoreFile, ErlFile) when is_list(CoreFile), is_list(ErlFile) ->
    true = filename:extension(CoreFile) =:= ".core",
    true = filename:extension(ErlFile) =:= ".erl",
    case file:read_file(CoreFile) of
        {ok, Bin} ->
            ErlText = transpile(binary_to_list(Bin)),
            file:write_file(ErlFile, ErlText);
        {error, Reason} ->
            {error, {read_error, CoreFile, Reason}}
    end.

%% ---------------------------------------------------------------------------
%% Module-level transformation
%% ---------------------------------------------------------------------------

transform_module(CoreMod) ->
    ModNameLit = cerl:module_name(CoreMod),
    ModAtom = cerl:concrete(ModNameLit),
    Exports = cerl:module_exports(CoreMod),
    Defs = cerl:module_defs(CoreMod),
    Attrs = cerl:module_attrs(CoreMod),

    %% -module(Name).
    ModForm = erl_syntax:attribute(
        erl_syntax:atom(module),
        [erl_syntax:atom(ModAtom)]),

    %% -export([f/a, ...]).
    %% Filter out module_info/0 and module_info/1 — Erlang compiler auto-generates these.
    FilteredExports = [E || E <- Exports,
                       not is_module_info(cerl:fname_id(E), cerl:fname_arity(E))],
    ExportEntries = [erl_syntax:arity_qualifier(
                        erl_syntax:atom(cerl:fname_id(E)),
                        erl_syntax:integer(cerl:fname_arity(E)))
                     || E <- FilteredExports],
    ExportForm = erl_syntax:attribute(
        erl_syntax:atom(export),
        [erl_syntax:list(ExportEntries)]),

    %% Module attributes (e.g. -behaviour)
    AttrForms = transform_attrs(Attrs),

    %% Function definitions (skip module_info — auto-generated by erlc)
    FilteredDefs = [{Name, Body} || {Name, Body} <- Defs,
                    not is_module_info(cerl:fname_id(Name), cerl:fname_arity(Name))],
    FunForms = lists:flatmap(fun({Name, Body}) ->
        transform_fundef(cerl:fname_id(Name), cerl:fname_arity(Name), Body)
    end, FilteredDefs),

    [ModForm, ExportForm | AttrForms ++ FunForms].

%% Transform module attributes to Erlang attribute forms.
transform_attrs(Attrs) ->
    lists:filtermap(fun({Key, Val}) ->
        K = cerl:concrete(Key),
        V = cerl:concrete(Val),
        case K of
            _ when V =:= [] -> false;
            _ -> {true, erl_syntax:attribute(erl_syntax:atom(K),
                    [erl_syntax:abstract(V)])}
        end
    end, Attrs).

%% ---------------------------------------------------------------------------
%% Function definition transformation
%% ---------------------------------------------------------------------------

%% A Core Erlang fundef is Name/Arity = fun(Params) -> Body.
%% We turn it into an Erlang function with one clause.
transform_fundef(FnName, _Arity, FunNode) ->
    Params = cerl:fun_vars(FunNode),
    Body = cerl:fun_body(FunNode),
    ErlParams = [transform_pattern(P) || P <- Params],
    ErlBody = transform_expr(Body),
    Clause = erl_syntax:clause(ErlParams, none, wrap_body(ErlBody)),
    [erl_syntax:function(erl_syntax:atom(FnName), [Clause])].

%% ---------------------------------------------------------------------------
%% Expression transformation (Core Erlang -> erl_syntax)
%% ---------------------------------------------------------------------------

transform_expr(Node) ->
    case cerl:type(Node) of
        literal ->
            transform_literal(Node);
        var ->
            transform_var(Node);
        cons ->
            Hd = transform_expr(cerl:cons_hd(Node)),
            Tl = transform_expr(cerl:cons_tl(Node)),
            erl_syntax:list([Hd], Tl);
        tuple ->
            Es = [transform_expr(E) || E <- cerl:tuple_es(Node)],
            erl_syntax:tuple(Es);
        binary ->
            Segs = [transform_bitstr(S) || S <- cerl:binary_segments(Node)],
            erl_syntax:binary(Segs);
        'let' ->
            transform_let(Node);
        seq ->
            transform_seq(Node);
        'case' ->
            transform_case(Node);
        clause ->
            %% Handled inside transform_case
            transform_clause(Node);
        apply ->
            transform_apply(Node);
        call ->
            transform_call(Node);
        primop ->
            transform_primop(Node);
        'try' ->
            transform_try(Node);
        'catch' ->
            transform_catch(Node);
        'fun' ->
            transform_fun(Node);
        letrec ->
            transform_letrec(Node);
        'receive' ->
            transform_receive(Node);
        values ->
            %% Multiple return values -> tuple
            Es = [transform_expr(E) || E <- cerl:values_es(Node)],
            case Es of
                [Single] -> Single;
                _ -> erl_syntax:tuple(Es)
            end;
        map ->
            transform_map(Node);
        _Other ->
            %% Fallback: try to get concrete value
            try
                erl_syntax:abstract(cerl:concrete(Node))
            catch
                _:_ ->
                    erl_syntax:comment([lists:flatten(
                        io_lib:format("%% unsupported cerl type: ~p", [_Other]))])
            end
    end.

%% ---------------------------------------------------------------------------
%% Literal values
%% ---------------------------------------------------------------------------

transform_literal(Node) ->
    Val = cerl:concrete(Node),
    erl_syntax:abstract(Val).

%% ---------------------------------------------------------------------------
%% Variables
%% ---------------------------------------------------------------------------

transform_var(Node) ->
    case cerl:var_name(Node) of
        {FName, FArity} ->
            %% Function variable reference: fun Name/Arity
            erl_syntax:implicit_fun(
                erl_syntax:atom(FName),
                erl_syntax:integer(FArity));
        Name when is_atom(Name) ->
            ErlName = sanitize_var_name(Name),
            erl_syntax:variable(ErlName)
    end.

%% Transform a Core Erlang variable name atom to a valid Erlang variable name.
%% Core Erlang vars:
%%   _cor5  -> Cor5 (underscore prefix with lowercase -> capitalize)
%%   _0     -> V_0  (numeric SSA var)
%%   A      -> A    (already valid)
%%   X_0    -> X_0  (SSA version, already valid)
%%   _      -> _    (wildcard stays)
sanitize_var_name('_') -> '_';
sanitize_var_name(Name) ->
    S = atom_to_list(Name),
    case S of
        "_" -> '_';
        %% Leading underscore: make it a valid Erlang var
        [$_ | Rest] ->
            case Rest of
                [] -> '_';
                [C | _] when C >= $0, C =< $9 ->
                    %% _0, _1 etc -> V_0, V_1
                    list_to_atom("V" ++ S);
                [C | T] when C >= $a, C =< $z ->
                    %% _cor5 -> Cor5
                    list_to_atom([C - 32 | T]);
                [C | _] when C >= $A, C =< $Z ->
                    %% _Foo -> Foo (already capitalized after _)
                    list_to_atom(Rest);
                _ ->
                    %% _other -> V_other
                    list_to_atom("V" ++ S)
            end;
        [C | _] when C >= $a, C =< $z ->
            %% Lowercase start: capitalize
            list_to_atom([C - 32 | tl(S)]);
        [C | _] when C >= $A, C =< $Z ->
            %% Already valid Erlang variable
            Name;
        _ ->
            %% Anything else: prefix with V_
            list_to_atom("V_" ++ S)
    end.

%% ---------------------------------------------------------------------------
%% Pattern transformation (used in clause patterns)
%% ---------------------------------------------------------------------------

transform_pattern(Node) ->
    case cerl:type(Node) of
        literal ->
            transform_literal(Node);
        var ->
            transform_var(Node);
        cons ->
            Hd = transform_pattern(cerl:cons_hd(Node)),
            Tl = transform_pattern(cerl:cons_tl(Node)),
            erl_syntax:list([Hd], Tl);
        tuple ->
            Es = [transform_pattern(E) || E <- cerl:tuple_es(Node)],
            erl_syntax:tuple(Es);
        binary ->
            Segs = [transform_bitstr_pattern(S) || S <- cerl:binary_segments(Node)],
            erl_syntax:binary(Segs);
        alias ->
            Var = transform_pattern(cerl:alias_var(Node)),
            Pat = transform_pattern(cerl:alias_pat(Node)),
            erl_syntax:match_expr(Var, Pat);
        map ->
            transform_map_pattern(Node);
        _ ->
            %% Fallback: try as expression
            transform_expr(Node)
    end.

%% ---------------------------------------------------------------------------
%% Binary segments
%% ---------------------------------------------------------------------------

transform_bitstr(Seg) ->
    Val = transform_expr(cerl:bitstr_val(Seg)),
    Size = transform_expr(cerl:bitstr_size(Seg)),
    Unit = cerl:concrete(cerl:bitstr_unit(Seg)),
    Type = cerl:concrete(cerl:bitstr_type(Seg)),
    Flags = cerl:concrete(cerl:bitstr_flags(Seg)),
    %% Build size and type specifiers
    Specs = build_bitstr_specs(Size, Unit, Type, Flags),
    case Specs of
        [] -> erl_syntax:binary_field(Val);
        _ -> erl_syntax:binary_field(Val, Specs)
    end.

transform_bitstr_pattern(Seg) ->
    transform_bitstr(Seg).

build_bitstr_specs(Size, Unit, Type, Flags) ->
    SizeSpec = case erl_syntax:type(Size) of
        integer ->
            case erl_syntax:integer_value(Size) of
                8 -> [];  %% Default for integer
                N -> [erl_syntax:integer(N)]
            end;
        _ -> [erl_syntax:size_qualifier(erl_syntax:atom(size), Size)]
    end,
    TypeSpec = case Type of
        integer -> [];
        _ -> [erl_syntax:atom(Type)]
    end,
    UnitSpec = case Unit of
        1 -> [];
        _ -> [erl_syntax:size_qualifier(erl_syntax:atom(unit), erl_syntax:integer(Unit))]
    end,
    FlagSpecs = lists:filtermap(fun(F) ->
        case F of
            unsigned -> false;  %% default
            big -> false;       %% default
            _ -> {true, erl_syntax:atom(F)}
        end
    end, Flags),
    SizeSpec ++ TypeSpec ++ UnitSpec ++ FlagSpecs.

%% ---------------------------------------------------------------------------
%% Let expressions: let <Vars> = Arg in Body
%% Flatten into a sequence of match expressions followed by the body.
%% ---------------------------------------------------------------------------

transform_let(Node) ->
    Vars = cerl:let_vars(Node),
    Arg = cerl:let_arg(Node),
    Body = cerl:let_body(Node),
    ErlVars = [transform_pattern(V) || V <- Vars],
    ErlArg = transform_expr(Arg),
    ErlBody = transform_expr(Body),
    %% Create: Var = Arg, Body
    LHS = case ErlVars of
        [Single] -> Single;
        Multiple -> erl_syntax:tuple(Multiple)
    end,
    Match = erl_syntax:match_expr(LHS, ErlArg),
    make_block([Match | wrap_body(ErlBody)]).

%% ---------------------------------------------------------------------------
%% Seq expressions: do Arg Body (like Erlang's comma sequencing)
%% ---------------------------------------------------------------------------

transform_seq(Node) ->
    Arg = cerl:seq_arg(Node),
    Body = cerl:seq_body(Node),
    ErlArg = transform_expr(Arg),
    ErlBody = transform_expr(Body),
    make_block([ErlArg | wrap_body(ErlBody)]).

%% ---------------------------------------------------------------------------
%% Case expressions
%% ---------------------------------------------------------------------------

transform_case(Node) ->
    Arg = cerl:case_arg(Node),
    Clauses = cerl:case_clauses(Node),
    ErlArg = transform_expr(Arg),
    ErlClauses = [transform_clause(C) || C <- Clauses],
    erl_syntax:case_expr(ErlArg, ErlClauses).

transform_clause(Node) ->
    Pats = cerl:clause_pats(Node),
    Guard = cerl:clause_guard(Node),
    Body = cerl:clause_body(Node),
    ErlPats = [transform_pattern(P) || P <- Pats],
    ErlGuard = transform_guard(Guard),
    ErlBody = transform_expr(Body),
    %% Case clause expects a single pattern
    Pat = case ErlPats of
        [Single] -> Single;
        Multiple -> erl_syntax:tuple(Multiple)
    end,
    erl_syntax:clause([Pat], ErlGuard, wrap_body(ErlBody)).

transform_guard(Guard) ->
    case cerl:type(Guard) of
        literal ->
            case cerl:concrete(Guard) of
                true -> none;
                _ -> [transform_expr(Guard)]
            end;
        _ ->
            [transform_expr(Guard)]
    end.

%% ---------------------------------------------------------------------------
%% Apply (local function call)
%% ---------------------------------------------------------------------------

transform_apply(Node) ->
    Op = cerl:apply_op(Node),
    Args = cerl:apply_args(Node),
    ErlArgs = [transform_expr(A) || A <- Args],
    case cerl:type(Op) of
        var ->
            case cerl:var_name(Op) of
                {FName, FArity} ->
                    %% Check if this is a letrec-local function (should call via variable)
                    case get({letrec_fun, FName, FArity}) of
                        undefined ->
                            erl_syntax:application(
                                erl_syntax:atom(FName),
                                ErlArgs);
                        VarName ->
                            erl_syntax:application(
                                erl_syntax:variable(VarName),
                                ErlArgs)
                    end;
                VarName ->
                    %% Apply a variable (higher-order)
                    ErlVar = erl_syntax:variable(sanitize_var_name(VarName)),
                    erl_syntax:application(ErlVar, ErlArgs)
            end;
        _ ->
            %% General expression in operator position
            ErlOp = transform_expr(Op),
            erl_syntax:application(ErlOp, ErlArgs)
    end.

%% ---------------------------------------------------------------------------
%% Call (remote function call: Module:Function(Args))
%% ---------------------------------------------------------------------------

transform_call(Node) ->
    Mod = cerl:call_module(Node),
    Fun = cerl:call_name(Node),
    Args = cerl:call_args(Node),
    ErlMod = transform_expr(Mod),
    ErlFun = transform_expr(Fun),
    ErlArgs = [transform_expr(A) || A <- Args],
    erl_syntax:application(
        erl_syntax:module_qualifier(ErlMod, ErlFun),
        ErlArgs).

%% ---------------------------------------------------------------------------
%% Primop (primitive operations: raise, match_fail, etc.)
%% ---------------------------------------------------------------------------

transform_primop(Node) ->
    Name = cerl:primop_name(Node),
    Args = cerl:primop_args(Node),
    NameAtom = cerl:concrete(Name),
    ErlArgs = [transform_expr(A) || A <- Args],
    case NameAtom of
        match_fail ->
            %% erlang:error(badmatch, ...)
            erl_syntax:application(
                erl_syntax:module_qualifier(
                    erl_syntax:atom(erlang),
                    erl_syntax:atom(error)),
                [erl_syntax:tuple(
                    [erl_syntax:atom(badmatch) | ErlArgs])]);
        raise ->
            %% erlang:raise(Class, Reason, Stacktrace)
            erl_syntax:application(
                erl_syntax:module_qualifier(
                    erl_syntax:atom(erlang),
                    erl_syntax:atom(raise)),
                ErlArgs);
        recv_peek_message ->
            %% Internal to receive, shouldn't appear standalone
            erl_syntax:atom(recv_peek_message);
        recv_wait_timeout ->
            erl_syntax:atom(recv_wait_timeout);
        recv_next ->
            erl_syntax:atom(recv_next);
        remove_message ->
            erl_syntax:atom(remove_message);
        _ ->
            %% Generic: emit as erlang:PrimopName(Args)
            erl_syntax:application(
                erl_syntax:module_qualifier(
                    erl_syntax:atom(erlang),
                    erl_syntax:atom(NameAtom)),
                ErlArgs)
    end.

%% ---------------------------------------------------------------------------
%% Try/catch expressions
%% ---------------------------------------------------------------------------

transform_try(Node) ->
    Arg = cerl:try_arg(Node),
    Vars = cerl:try_vars(Node),
    Body = cerl:try_body(Node),
    EVars = cerl:try_evars(Node),
    Handler = cerl:try_handler(Node),
    ErlArg = transform_expr(Arg),
    %% Build the try expression
    %% In Core Erlang: try Arg of <Vars> -> Body catch <EVars> -> Handler
    ErlVars = [transform_pattern(V) || V <- Vars],
    ErlBody = transform_expr(Body),
    ErlEVars = [transform_pattern(V) || V <- EVars],
    ErlHandler = transform_expr(Handler),
    %% Construct try/of/catch
    OfPat = case ErlVars of
        [Single] -> Single;
        Multiple -> erl_syntax:tuple(Multiple)
    end,
    OfClause = erl_syntax:clause([OfPat], none, wrap_body(ErlBody)),
    %% Catch clause: Class:Reason:Stack
    CatchPat = case ErlEVars of
        [V1, V2, V3] ->
            erl_syntax:class_qualifier(V1, V2, V3);
        [V1, V2] ->
            erl_syntax:class_qualifier(V1, V2);
        [V1] ->
            V1;
        _ ->
            erl_syntax:underscore()
    end,
    CatchClause = erl_syntax:clause([CatchPat], none, wrap_body(ErlHandler)),
    erl_syntax:try_expr(wrap_body(ErlArg), [OfClause], [CatchClause]).

%% ---------------------------------------------------------------------------
%% Catch expression (simple catch, not try/catch)
%% ---------------------------------------------------------------------------

transform_catch(Node) ->
    Body = cerl:catch_body(Node),
    ErlBody = transform_expr(Body),
    erl_syntax:catch_expr(ErlBody).

%% ---------------------------------------------------------------------------
%% Fun (anonymous function / lambda)
%% ---------------------------------------------------------------------------

transform_fun(Node) ->
    Vars = cerl:fun_vars(Node),
    Body = cerl:fun_body(Node),
    ErlVars = [transform_pattern(V) || V <- Vars],
    ErlBody = transform_expr(Body),
    Clause = erl_syntax:clause(ErlVars, none, wrap_body(ErlBody)),
    erl_syntax:fun_expr([Clause]).

%% ---------------------------------------------------------------------------
%% Letrec (local recursive function definitions)
%% ---------------------------------------------------------------------------

transform_letrec(Node) ->
    Defs = cerl:letrec_defs(Node),
    Body = cerl:letrec_body(Node),
    %% Register letrec function names so transform_apply can resolve them
    %% to variable references instead of atom function calls.
    NameMap = lists:map(fun({Name, _FunNode}) ->
        {FnId, FnArity} = cerl:var_name(Name),
        SanitizedName = sanitize_var_name(FnId),
        put({letrec_fun, FnId, FnArity}, SanitizedName),
        {FnId, FnArity, SanitizedName}
    end, Defs),
    %% Transform each local function definition (with letrec scope active)
    LocalFuns = lists:map(fun({Name, FunNode}) ->
        {FnId, _FnArity} = cerl:var_name(Name),
        Vars = cerl:fun_vars(FunNode),
        FBody = cerl:fun_body(FunNode),
        ErlVars = [transform_pattern(V) || V <- Vars],
        ErlBody = transform_expr(FBody),
        SanitizedName = sanitize_var_name(FnId),
        {SanitizedName, ErlVars, ErlBody}
    end, Defs),
    %% For letrec with a single local fun that's immediately applied
    %% (common pattern for loops), emit a named fun and call it.
    %% NOTE: letrec scope is still active here so apply args transform correctly.
    Result = case {LocalFuns, cerl:type(Body)} of
        {[{FunName, FunVars, FunBody}], apply} ->
            %% Body is an apply of the letrec function
            Clause = erl_syntax:clause(FunVars, none, wrap_body(FunBody)),
            NamedFun = erl_syntax:named_fun_expr(
                erl_syntax:variable(FunName), [Clause]),
            ApplyArgs = [transform_expr(A) || A <- cerl:apply_args(Body)],
            %% Bind the named fun to a variable, then apply it
            FunVar = erl_syntax:variable(FunName),
            Match = erl_syntax:match_expr(FunVar, NamedFun),
            Call = erl_syntax:application(FunVar, ApplyArgs),
            make_block([Match, Call]);
        _ ->
            %% General case: bind each local fun, then evaluate body
            ErlBody = transform_expr(Body),
            Bindings = lists:map(fun({FunName, FunVars, FunBody}) ->
                Clause = erl_syntax:clause(FunVars, none, wrap_body(FunBody)),
                NamedFun = erl_syntax:named_fun_expr(
                    erl_syntax:variable(FunName), [Clause]),
                FunVar = erl_syntax:variable(FunName),
                erl_syntax:match_expr(FunVar, NamedFun)
            end, LocalFuns),
            make_block(Bindings ++ wrap_body(ErlBody))
    end,
    %% Clean up letrec scope
    lists:foreach(fun({FnId, FnArity, _}) ->
        erase({letrec_fun, FnId, FnArity})
    end, NameMap),
    Result.

%% ---------------------------------------------------------------------------
%% Receive expressions
%% ---------------------------------------------------------------------------

transform_receive(Node) ->
    Clauses = cerl:receive_clauses(Node),
    Timeout = cerl:receive_timeout(Node),
    Action = cerl:receive_action(Node),
    ErlClauses = [transform_clause(C) || C <- Clauses],
    case cerl:type(Timeout) of
        literal ->
            case cerl:concrete(Timeout) of
                infinity ->
                    erl_syntax:receive_expr(ErlClauses);
                TimeoutVal ->
                    ErlAction = transform_expr(Action),
                    erl_syntax:receive_expr(
                        ErlClauses,
                        erl_syntax:abstract(TimeoutVal),
                        wrap_body(ErlAction))
            end;
        _ ->
            ErlTimeout = transform_expr(Timeout),
            ErlAction = transform_expr(Action),
            erl_syntax:receive_expr(ErlClauses, ErlTimeout, wrap_body(ErlAction))
    end.

%% ---------------------------------------------------------------------------
%% Map expressions
%% ---------------------------------------------------------------------------

transform_map(Node) ->
    %% Core Erlang maps use cerl:map_arg (base map) and cerl:map_es (pairs)
    Arg = cerl:map_arg(Node),
    Pairs = cerl:map_es(Node),
    ErlPairs = [transform_map_pair(P) || P <- Pairs],
    case cerl:type(Arg) of
        literal ->
            case cerl:concrete(Arg) of
                M when is_map(M), map_size(M) =:= 0 ->
                    %% Empty base: #{K => V, ...}
                    erl_syntax:map_expr(ErlPairs);
                _ ->
                    ErlArg = transform_expr(Arg),
                    erl_syntax:map_expr(ErlArg, ErlPairs)
            end;
        _ ->
            ErlArg = transform_expr(Arg),
            erl_syntax:map_expr(ErlArg, ErlPairs)
    end.

transform_map_pair(Pair) ->
    Key = cerl:map_pair_key(Pair),
    Val = cerl:map_pair_val(Pair),
    Op = cerl:map_pair_op(Pair),
    ErlKey = transform_expr(Key),
    ErlVal = transform_expr(Val),
    OpAtom = cerl:concrete(Op),
    case OpAtom of
        assoc ->
            erl_syntax:map_field_assoc(ErlKey, ErlVal);
        exact ->
            erl_syntax:map_field_exact(ErlKey, ErlVal)
    end.

transform_map_pattern(Node) ->
    Pairs = cerl:map_es(Node),
    ErlPairs = lists:map(fun(Pair) ->
        Key = cerl:map_pair_key(Pair),
        Val = cerl:map_pair_val(Pair),
        ErlKey = transform_pattern(Key),
        ErlVal = transform_pattern(Val),
        erl_syntax:map_field_exact(ErlKey, ErlVal)
    end, Pairs),
    erl_syntax:map_expr(ErlPairs).

%% ---------------------------------------------------------------------------
%% Predicates
%% ---------------------------------------------------------------------------

%% module_info/0 and module_info/1 are auto-generated by the Erlang compiler.
%% We must not emit them or they'll conflict.
is_module_info(module_info, 0) -> true;
is_module_info(module_info, 1) -> true;
is_module_info(_, _) -> false.

%% ---------------------------------------------------------------------------
%% Helpers
%% ---------------------------------------------------------------------------

%% Wrap an expression in a list if it isn't already a list suitable for
%% clause bodies (which need a list of expressions).
wrap_body(Expr) ->
    case erl_syntax:type(Expr) of
        block_expr ->
            erl_syntax:block_expr_body(Expr);
        _ ->
            [Expr]
    end.

%% Create a begin...end block from a list of expressions, or return
%% the single expression if there's only one.
make_block([Single]) -> Single;
make_block(Exprs) -> erl_syntax:block_expr(Exprs).
