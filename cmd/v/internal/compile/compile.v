// Copyright (c) 2019-2020 Alexander Medvednikov. All rights reserved.
// Use of this source code is governed by an MIT license
// that can be found in the LICENSE file.
module compile

import (
	benchmark
	os
	v.builder
	v.pref
	v.util
	strings
)

pub struct V {
pub mut:
	mod_file_cacher     &builder.ModFileCacher // used during lookup for v.mod to support @VROOT
	out_name_c          string // name of the temporary C file
	files               []string // all V files that need to be parsed and compiled
	compiled_dir        string // contains os.real_path() of the dir of the final file beeing compiled, or the dir itself when doing `v .`
	pref                &pref.Preferences // all the preferences and settings extracted to a struct for reusability
	vgen_buf            strings.Builder // temporary buffer for generated V code (.str() etc)
	file_parser_idx     map[string]int // map absolute file path to v.parsers index
	gen_parser_idx      map[string]int
	cached_mods         []string
	module_lookup_paths []string

	v_fmt_all           bool   // << input set by cmd/tools/vfmt.v
	v_fmt_file          string // << file given by the user from cmd/tools/vfmt.v
	v_fmt_file_result   string // >> file with formatted output generated by vlib/compiler/vfmt.v
}

pub fn new_v(pref &pref.Preferences) &V {
	rdir := os.real_path(pref.path)

	mut out_name_c := get_vtmp_filename(pref.out_name, '.tmp.c')
	if pref.is_so {
		out_name_c = get_vtmp_filename(pref.out_name, '.tmp.so.c')
	}

	mut vgen_buf := strings.new_builder(1000)
	vgen_buf.writeln('module vgen\nimport strings')
	compiled_dir := if os.is_dir(rdir) { rdir } else { os.dir(rdir) }

	return &V{
		mod_file_cacher: builder.new_mod_file_cacher()
		compiled_dir:compiled_dir// if os.is_dir(rdir) { rdir } else { os.dir(rdir) }
		out_name_c: out_name_c
		pref: pref
		vgen_buf: vgen_buf
	}
}

// make v2 from v1
fn (v &V) new_v2() builder.Builder {
	mut b := builder.new_builder(v.pref)
	b = { b|
		os: v.pref.os,
		module_path: pref.default_module_path,
		compiled_dir: v.compiled_dir,
		module_search_paths: v.module_lookup_paths
	}
	return b
}

fn get_vtmp_folder() string {
	vtmp := os.join_path(os.temp_dir(), 'v')
	if !os.is_dir(vtmp) {
		os.mkdir(vtmp) or {
			panic(err)
		}
	}
	return vtmp
}

fn get_vtmp_filename(base_file_name string, postfix string) string {
	vtmp := get_vtmp_folder()
	return os.real_path(os.join_path(vtmp, os.file_name(os.real_path(base_file_name)) + postfix))
}


pub fn (v mut V) compile_x64() {
	$if !linux {
		println('v -x64 can only generate Linux binaries for now')
		println('You are not on a Linux system, so you will not ' + 'be able to run the resulting executable')
	}
	//v.files << v.v_files_from_dir(os.join_path(v.pref.vlib_path,'builtin','bare'))
	v.files << v.pref.path
	v.set_module_lookup_paths()
	mut b := v.new_v2()
	// move all this logic to v2
	b.build_x64(v.files, v.pref.out_name)
}

pub fn (v mut V) compile2() {
	if os.user_os() != 'windows' && v.pref.ccompiler == 'msvc' {
		verror('Cannot build with msvc on ${os.user_os()}')
	}
	//cgen.genln('// Generated by V')
	//println('compile2()')
	if v.pref.verbosity.is_higher_or_equal(.level_three) {
		println('all .v files before:')
		println(v.files)
	}
	// v1 compiler files
	//v.add_v_files_to_compile()
	//v.files << v.dir
	// v2 compiler
	v.files << v.get_builtin_files()
	v.files << v.get_user_files()
	v.set_module_lookup_paths()
	if v.pref.verbosity.is_higher_or_equal(.level_three) {
		println('all .v files:')
		println(v.files)
	}
	mut b := v.new_v2()
	b.build_c(v.files, v.out_name_c)// v.pref.out_name + '.c')
	v.cc()
}


pub fn compile(command string, args []string) {
	// Construct the V object from command line arguments
	parse_and_output_new_format(args)
	prefs, remaining := parse_arguments(args)
	check_for_common_mistake(args, prefs)
	mut v := new_v(prefs)
	if v.pref.verbosity.is_higher_or_equal(.level_two) {
		println(args)
	}
	mut tmark := benchmark.new_benchmark()
	if v.pref.backend == .x64 {
		v.compile_x64()
	}
	else if v.pref.backend == .experimental {
		v.compile2()
	}
	else {
		//v.compile()
		v.compile2()
	}
	if v.pref.is_stats {
		tmark.stop()
		println('compilation took: ' + tmark.total_duration().str() + 'ms')
	}
	if v.pref.is_test || v.pref.is_run {
		run_compiled_executable_and_exit(v, remaining)
	}
	//v.finalize_compilation()
}

pub fn run_compiled_executable_and_exit(v &V, remaining_args []string) {
	if v.pref.verbosity.is_higher_or_equal(.level_two) {
		println('============ running $v.pref.out_name ============')
	}
	mut cmd := '"${v.pref.out_name}"'
	for i in 1..remaining_args.len {
		// Determine if there are spaces in the parameters
		if remaining_args[i].index_byte(` `) > 0 {
			cmd += ' "' + remaining_args[i] + '"'
		}
		else {
			cmd += ' ' + remaining_args[i]
		}
	}
	if v.pref.verbosity.is_higher_or_equal(.level_two) {
		println('command to run executable: $cmd')
	}
	if v.pref.is_test {
		ret := os.system(cmd)
		if ret != 0 {
			exit(1)
		}
	}
	if v.pref.is_run {
		ret := os.system(cmd)
		// TODO: make the runner wrapping as transparent as possible
		// (i.e. use execve when implemented). For now though, the runner
		// just returns the same exit code as the child process.
		exit(ret)
	}
	exit(0)
}

// 'strings' => 'VROOT/vlib/strings'
// 'installed_mod' => '~/.vmodules/installed_mod'
// 'local_mod' => '/path/to/current/dir/local_mod'
fn (v mut V) set_module_lookup_paths() {
	// Module search order:
	// 0) V test files are very commonly located right inside the folder of the
	// module, which they test. Adding the parent folder of the module folder
	// with the _test.v files, *guarantees* that the tested module can be found
	// without needing to set custom options/flags.
	// 1) search in the *same* directory, as the compiled final v program source
	// (i.e. the . in `v .` or file.v in `v file.v`)
	// 2) search in the modules/ in the same directory.
	// 3) search in the provided paths
	// By default, these are what (3) contains:
	// 3.1) search in vlib/
	// 3.2) search in ~/.vmodules/ (i.e. modules installed with vpm)
	v.module_lookup_paths = []
	if v.pref.is_test {
		v.module_lookup_paths << os.base_dir(v.compiled_dir) // pdir of _test.v
	}
	v.module_lookup_paths << v.compiled_dir
	x := os.join_path(v.compiled_dir, 'modules')
	if v.pref.verbosity.is_higher_or_equal(.level_two) {
		println('x: "$x"')
	}
	v.module_lookup_paths << os.join_path(v.compiled_dir, 'modules')
	v.module_lookup_paths << v.pref.lookup_path
	if v.pref.verbosity.is_higher_or_equal(.level_two) {
		v.log('v.module_lookup_paths') //: $v.module_lookup_paths')
		println(v.module_lookup_paths)
	}
}

pub fn (v &V) get_builtin_files() []string {
	// Lookup for built-in folder in lookup path.
	// Assumption: `builtin/` folder implies usable implementation of builtin
	for location in v.pref.lookup_path {
		if !os.exists(os.join_path(location, 'builtin')) {
			continue
		}
		if v.pref.is_bare {
			return v.v_files_from_dir(os.join_path(location, 'builtin', 'bare'))
		}
		$if js {
			return v.v_files_from_dir(os.join_path(location, 'builtin', 'js'))
		}
		return v.v_files_from_dir(os.join_path(location, 'builtin'))
	}
	// Panic. We couldn't find the folder.
	verror('`builtin/` not included on module lookup path.
Did you forget to add vlib to the path? (Use @vlib for default vlib)')
	panic('Unreachable code reached.')
}


pub fn (v &V) get_user_files() []string {
	mut dir := v.pref.path
	v.log('get_v_files($dir)')
	// Need to store user files separately, because they have to be added after
	// libs, but we dont know	which libs need to be added yet
	mut user_files := []string

	// See cmd/tools/preludes/README.md for more info about what preludes are
	vroot := os.dir(pref.vexe_path())
	preludes_path := os.join_path(vroot, 'cmd', 'tools', 'preludes')
	if v.pref.is_live {
		user_files << os.join_path(preludes_path, 'live_main.v')
	}
	if v.pref.is_solive {
		user_files << os.join_path(preludes_path, 'live_shared.v')
	}
	if v.pref.is_test {
		user_files << os.join_path(preludes_path, 'tests_assertions.v')
	}
	if v.pref.is_test && v.pref.is_stats {
		user_files << os.join_path(preludes_path, 'tests_with_stats.v')
	}

	is_test := dir.ends_with('_test.v')
	mut is_internal_module_test := false
	if is_test {
		tcontent := os.read_file(dir)or{
			panic('$dir does not exist')
		}
		slines := tcontent.trim_space().split_into_lines()
		for sline in slines {
			line := sline.trim_space()
			if line.len > 2 {
				if line[0] == `/` && line[1] == `/` {
					continue
				}
				if line.starts_with('module ') && !line.starts_with('module main') {
					is_internal_module_test = true
					break
				}
			}
		}
	}
	if is_internal_module_test {
		// v volt/slack_test.v: compile all .v files to get the environment
		single_test_v_file := os.real_path(dir)
		if v.pref.verbosity.is_higher_or_equal(.level_two) {
			v.log('> Compiling an internal module _test.v file $single_test_v_file .')
			v.log('> That brings in all other ordinary .v files in the same module too .')
		}
		user_files << single_test_v_file
		dir = os.base_dir(single_test_v_file)
	}
	is_real_file := os.exists(dir) && !os.is_dir(dir)
	if is_real_file && ( dir.ends_with('.v') || dir.ends_with('.vsh') ) {
		single_v_file := dir
		// Just compile one file and get parent dir
		user_files << single_v_file
		if v.pref.verbosity.is_higher_or_equal(.level_two) {
			v.log('> just compile one file: "${single_v_file}"')
		}
	}
	else {
		if v.pref.verbosity.is_higher_or_equal(.level_two) {
			v.log('> add all .v files from directory "${dir}" ...')
		}
		// Add .v files from the directory being compiled
		files := v.v_files_from_dir(dir)
		for file in files {
			user_files << file
		}
	}
	if user_files.len == 0 {
		println('No input .v files')
		exit(1)
	}
	if v.pref.verbosity.is_higher_or_equal(.level_two) {
		v.log('user_files: $user_files')
	}
	return user_files
}

pub fn (v &V) log(s string) {
	if !v.pref.verbosity.is_higher_or_equal(.level_two) {
		return
	}
	println(s)
}

pub fn (v &V) v_files_from_dir(dir string) []string {
	mut res := []string
	if !os.exists(dir) {
		if dir == 'compiler' && os.is_dir('vlib') {
			println('looks like you are trying to build V with an old command')
			println('use `v -o v cmd/v` instead of `v -o v compiler`')
		}
		verror("$dir doesn't exist")
	}
	else if !os.is_dir(dir) {
		verror("$dir isn't a directory!")
	}
	mut files := os.ls(dir) or {
		panic(err)
	}
	if v.pref.verbosity.is_higher_or_equal(.level_three) {
		println('v_files_from_dir ("$dir")')
	}
	files.sort()
	for file in files {
		if !file.ends_with('.v') && !file.ends_with('.vh') {
			continue
		}
		if file.ends_with('_test.v') {
			continue
		}
		if (file.ends_with('_win.v') || file.ends_with('_windows.v')) && v.pref.os != .windows {
			continue
		}
		if (file.ends_with('_lin.v') || file.ends_with('_linux.v')) && v.pref.os != .linux {
			continue
		}
		if (file.ends_with('_mac.v') || file.ends_with('_darwin.v')) && v.pref.os != .mac {
			continue
		}
		if file.ends_with('_nix.v') && v.pref.os == .windows {
			continue
		}
		if file.ends_with('_android.v') && v.pref.os != .android {
			continue
		}
		if file.ends_with('_freebsd.v') && v.pref.os != .freebsd {
			continue
		}
		if file.ends_with('_solaris.v') && v.pref.os != .solaris {
			continue
		}
		if file.ends_with('_js.v') && v.pref.os != .js {
			continue
		}
		if file.ends_with('_c.v') && v.pref.os == .js {
			continue
		}
		if v.pref.compile_defines_all.len > 0 && file.contains('_d_') {
			mut allowed := false
			for cdefine in v.pref.compile_defines {
				file_postfix := '_d_${cdefine}.v'
				if file.ends_with(file_postfix) {
					allowed = true
					break
				}
			}
			if !allowed {
				continue
			}
		}
		res << os.join_path(dir, file)
	}
	return res
}

pub fn verror(s string) {
	util.verror('compiler error', s)
}
